; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\bsp_spi_bus.crf ..\User\bsp_stm32f4xx\src\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;61     */
;;;62     void bsp_InitSPIBus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;63     {
;;;64     #ifdef SOFT_SPI		/* 软件SPI */
;;;65     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;66     
;;;67     	/* 打开GPIO时钟 */
;;;68     	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);
;;;69     
;;;70     	/* 配置几个推完输出IO */
;;;71     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
;;;72     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;73     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
;;;74     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 */
;;;75     
;;;76     	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
;;;77     	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
;;;78     
;;;79     	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
;;;80     	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
;;;81     
;;;82     	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;83     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
;;;84     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;85     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
;;;86     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;	/* IO口最大速度 */
;;;87     
;;;88     	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
;;;89     	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
;;;90     #endif
;;;91     
;;;92     #ifdef HARD_SPI
;;;93     	/* 硬件SPI */
;;;94     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;95     
;;;96     	/* 开启GPIO时钟 */
;;;97     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000002  2101              MOVS     r1,#1
000004  0308              LSLS     r0,r1,#12
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;98     
;;;99     	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;100    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI3);
;;;101    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI3);
;;;102    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI3);
;;;103    	/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;104    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
00000a  2205              MOVS     r2,#5
00000c  2103              MOVS     r1,#3
00000e  4811              LDR      r0,|L1.84|
000010  f7fffffe          BL       GPIO_PinAFConfig
;;;105    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
000014  2205              MOVS     r2,#5
000016  2104              MOVS     r1,#4
000018  480e              LDR      r0,|L1.84|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;106    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
00001e  2205              MOVS     r2,#5
000020  4611              MOV      r1,r2
000022  480c              LDR      r0,|L1.84|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;107    
;;;108    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000028  2002              MOVS     r0,#2
00002a  f88d0004          STRB     r0,[sp,#4]
;;;109    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
00002e  2001              MOVS     r0,#1
000030  f88d0005          STRB     r0,[sp,#5]
;;;110    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000034  2000              MOVS     r0,#0
000036  f88d0006          STRB     r0,[sp,#6]
;;;111    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00003a  f88d0007          STRB     r0,[sp,#7]
;;;112    
;;;113    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
00003e  2038              MOVS     r0,#0x38
000040  9000              STR      r0,[sp,#0]
;;;114    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4803              LDR      r0,|L1.84|
000046  f7fffffe          BL       GPIO_Init
;;;115    
;;;116    	/* 打开SPI时钟 */
;;;117    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  0308              LSLS     r0,r1,#12
00004e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;118    
;;;119    #endif
;;;120    }
000052  bd1c              POP      {r2-r4,pc}
;;;121    
                          ENDP

                  |L1.84|
                          DCD      0x40020400

                          AREA ||i.bsp_SPI_Init||, CODE, READONLY, ALIGN=2

                  bsp_SPI_Init PROC
;;;129    */
;;;130    void bsp_SPI_Init(uint16_t _cr1)
000000  4903              LDR      r1,|L2.16|
;;;131    {
;;;132    	SPI1->CR1 = ((SPI1->CR1 & 0x3040) | _cr1);
000002  8809              LDRH     r1,[r1,#0]
000004  f4015141          AND      r1,r1,#0x3040
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L2.16|
00000c  8011              STRH     r1,[r2,#0]
;;;133    }
00000e  4770              BX       lr
;;;134    
                          ENDP

                  |L2.16|
                          DCD      0x40013000

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;384    */
;;;385    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L3.8|
;;;386    {
;;;387    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;388    }
000004  4770              BX       lr
;;;389    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;358    */
;;;359    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;360    {
;;;361    	g_spi_busy = 1;
000002  4901              LDR      r1,|L4.8|
000004  7008              STRB     r0,[r1,#0]
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP

                  |L4.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;371    */
;;;372    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;373    {
;;;374    	g_spi_busy = 0;
000002  4901              LDR      r1,|L5.8|
000004  7008              STRB     r0,[r1,#0]
;;;375    }
000006  4770              BX       lr
;;;376    
                          ENDP

                  |L5.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiDelay||, CODE, READONLY, ALIGN=1

                  bsp_spiDelay PROC
;;;142    */
;;;143    void bsp_spiDelay(void)
000000  2000              MOVS     r0,#0
;;;144    {
;;;145    #if 1
;;;146    	uint32_t i;
;;;147    
;;;148    	/*
;;;149    		延迟5时， F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 480ns (大约2M)
;;;150    	*/
;;;151    	for (i = 0; i < 5; i++);
000002  e000              B        |L6.6|
                  |L6.4|
000004  1c40              ADDS     r0,r0,#1
                  |L6.6|
000006  2805              CMP      r0,#5
000008  d3fc              BCC      |L6.4|
;;;152    #else
;;;153    	/*
;;;154    		不添加延迟语句， F407 (168MHz主频） GPIO模拟，实测 SCK 周期 = 200ns (大约5M)
;;;155    	*/
;;;156    #endif
;;;157    }
00000a  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.bsp_spiRead0||, CODE, READONLY, ALIGN=2

                  bsp_spiRead0 PROC
;;;213    */
;;;214    uint8_t bsp_spiRead0(void)
000000  b510              PUSH     {r4,lr}
;;;215    {
;;;216    #ifdef SOFT_SPI		/* 软件SPI */
;;;217    	uint8_t i;
;;;218    	uint8_t read = 0;
;;;219    
;;;220    	for (i = 0; i < 8; i++)
;;;221    	{
;;;222    		read = read<<1;
;;;223    
;;;224    		if (MISO_IS_HIGH())
;;;225    		{
;;;226    			read++;
;;;227    		}
;;;228    		SCK_1();
;;;229    		bsp_spiDelay();
;;;230    		SCK_0();
;;;231    		bsp_spiDelay();
;;;232    	}
;;;233    	return read;
;;;234    #endif
;;;235    
;;;236    #ifdef HARD_SPI		/* 硬件SPI */
;;;237    	uint8_t read;
;;;238    
;;;239    	/* 等待发送缓冲区空 */
;;;240    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L7.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L7.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L7.4|
;;;241    
;;;242    	/* 发送一个字节 */
;;;243    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L7.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;244    
;;;245    	/* 等待数据接收完毕 */
;;;246    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L7.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L7.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L7.26|
;;;247    
;;;248    	/* 读取接收到的数据 */
;;;249    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L7.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;250    
;;;251    	/* 返回读到的数据 */
;;;252    	return read;
00002e  4620              MOV      r0,r4
;;;253    #endif
;;;254    }
000030  bd10              POP      {r4,pc}
;;;255    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiRead1||, CODE, READONLY, ALIGN=2

                  bsp_spiRead1 PROC
;;;309    */
;;;310    uint8_t bsp_spiRead1(void)
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312    #ifdef SOFT_SPI		/* 软件SPI */
;;;313    	uint8_t i;
;;;314    	uint8_t read = 0;
;;;315    
;;;316    	for (i = 0; i < 8; i++)
;;;317    	{
;;;318    		SCK_0();
;;;319    		bsp_spiDelay();
;;;320    		read = read<<1;
;;;321    		if (MISO_IS_HIGH())
;;;322    		{
;;;323    			read++;
;;;324    		}
;;;325    		SCK_1();
;;;326    		bsp_spiDelay();
;;;327    	}
;;;328    	return read;
;;;329    #endif
;;;330    
;;;331    #ifdef HARD_SPI		/* 硬件SPI */
;;;332    	uint8_t read;
;;;333    
;;;334    	/* 等待发送缓冲区空 */
;;;335    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L8.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L8.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L8.4|
;;;336    
;;;337    	/* 发送一个字节 */
;;;338    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L8.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;339    
;;;340    	/* 等待数据接收完毕 */
;;;341    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L8.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L8.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L8.26|
;;;342    
;;;343    	/* 读取接收到的数据 */
;;;344    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L8.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;345    
;;;346    	/* 返回读到的数据 */
;;;347    	return read;
00002e  4620              MOV      r0,r4
;;;348    #endif
;;;349    }
000030  bd10              POP      {r4,pc}
;;;350    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWrite0||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite0 PROC
;;;166    */
;;;167    void bsp_spiWrite0(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;168    {
000002  4604              MOV      r4,r0
;;;169    #ifdef SOFT_SPI		/* 软件SPI */
;;;170    	uint8_t i;
;;;171    
;;;172    	for(i = 0; i < 8; i++)
;;;173    	{
;;;174    		if (_ucByte & 0x80)
;;;175    		{
;;;176    			MOSI_1();
;;;177    		}
;;;178    		else
;;;179    		{
;;;180    			MOSI_0();
;;;181    		}
;;;182    		bsp_spiDelay();
;;;183    		SCK_1();
;;;184    		_ucByte <<= 1;
;;;185    		bsp_spiDelay();
;;;186    		SCK_0();
;;;187    	}
;;;188    	bsp_spiDelay();
;;;189    #endif
;;;190    
;;;191    #ifdef HARD_SPI		/* 硬件SPI */
;;;192    	/* 等待发送缓冲区空 */
;;;193    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L9.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L9.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L9.6|
;;;194    
;;;195    	/* 发送一个字节 */
;;;196    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L9.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;197    
;;;198    	/* 等待数据接收完毕 */
;;;199    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L9.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L9.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L9.28|
;;;200    
;;;201    	/* 读取接收到的数据 */
;;;202    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L9.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;203    #endif
;;;204    }
00002e  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  |L9.48|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWrite1||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite1 PROC
;;;263    */
;;;264    void bsp_spiWrite1(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;265    {
000002  4604              MOV      r4,r0
;;;266    #ifdef SOFT_SPI		/* 软件SPI */
;;;267    	uint8_t i;
;;;268    
;;;269    	for(i = 0; i < 8; i++)
;;;270    	{
;;;271    		if (_ucByte & 0x80)
;;;272    		{
;;;273    			MOSI_1();
;;;274    		}
;;;275    		else
;;;276    		{
;;;277    			MOSI_0();
;;;278    		}
;;;279    		SCK_0();
;;;280    		_ucByte <<= 1;
;;;281    		bsp_spiDelay();
;;;282    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
;;;283    		bsp_spiDelay();
;;;284    	}
;;;285    #endif
;;;286    
;;;287    #ifdef HARD_SPI		/* 硬件SPI */
;;;288    	/* 等待发送缓冲区空 */
;;;289    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L10.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L10.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L10.6|
;;;290    
;;;291    	/* 发送一个字节 */
;;;292    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L10.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;293    
;;;294    	/* 等待数据接收完毕 */
;;;295    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L10.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L10.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L10.28|
;;;296    
;;;297    	/* 读取接收到的数据 */
;;;298    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L10.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;299    #endif
;;;300    }
00002e  bd10              POP      {r4,pc}
;;;301    
                          ENDP

                  |L10.48|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 144
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
