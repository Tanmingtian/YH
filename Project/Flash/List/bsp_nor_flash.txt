; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_nor_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_nor_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\bsp_nor_flash.crf ..\User\bsp_stm32f4xx\src\bsp_nor_flash.c]
                          THUMB

                          AREA ||i.NOR_CheckStatus||, CODE, READONLY, ALIGN=1

                  NOR_CheckStatus PROC
;;;404    */
;;;405    uint8_t NOR_CheckStatus(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;406    {
;;;407    	uint16_t val1 = 0x00;
000004  2400              MOVS     r4,#0
;;;408    	uint16_t val2 = 0x00;
000006  2600              MOVS     r6,#0
;;;409    	uint8_t status = NOR_ONGOING;
000008  2701              MOVS     r7,#1
;;;410    	uint32_t timeout = 10;
00000a  250a              MOVS     r5,#0xa
;;;411    	
;;;412    	/*
;;;413    		- DQ 6 编程时跳变
;;;414    		- DQ 6 和 DQ 2 在擦除时跳变
;;;415    		- DQ 2 在擦除挂起时跳变
;;;416    		- DQ 1 在编程错误时置1
;;;417    		- DQ 5 在超时时置1
;;;418    	*/
;;;419    	/* 通过读取DQ6, DQ5 的数据位是否存在翻转现象判断NOR 内部操作是否完成。如果正忙，则第2次读和第1次读的数据不同 */
;;;420    	while ((timeout != 0x00) && (status != NOR_SUCCESS))
00000c  e025              B        |L1.90|
                  |L1.14|
;;;421    	{
;;;422    		timeout--;
00000e  1e6d              SUBS     r5,r5,#1
;;;423    
;;;424    		/* Read DQ6 */
;;;425    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000010  f04f40c8          MOV      r0,#0x64000000
000014  8804              LDRH     r4,[r0,#0]
;;;426    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000016  8806              LDRH     r6,[r0,#0]
;;;427    
;;;428    		/* If DQ6 did not toggle between the two reads then return NOR_Success */
;;;429    		if ((val1 & 0x0040) == (val2 & 0x0040))
000018  f0040040          AND      r0,r4,#0x40
00001c  f0060140          AND      r1,r6,#0x40
000020  4288              CMP      r0,r1
000022  d102              BNE      |L1.42|
;;;430    		{
;;;431    			return NOR_SUCCESS;
000024  2000              MOVS     r0,#0
                  |L1.38|
;;;432    		}
;;;433    
;;;434    		/* Read DQ2 */
;;;435    		if((val1 & 0x0020) != 0x0020)
;;;436    		{
;;;437    			status = NOR_ONGOING;
;;;438    		}
;;;439    
;;;440    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
;;;441    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
;;;442    
;;;443    		if((val1 & 0x0040) == (val2 & 0x0040))
;;;444    		{
;;;445    			return NOR_SUCCESS;
;;;446    		}
;;;447    		else if ((val1 & 0x0020) == 0x0020)
;;;448    		{
;;;449    			status = NOR_ERROR;
;;;450    			NOR_QuitToReadStatus();
;;;451    		}
;;;452    	}
;;;453    
;;;454    	if (timeout == 0x00)
;;;455    	{
;;;456    		status = NOR_TIMEOUT;
;;;457    		//NOR_QuitToReadStatus();
;;;458    	}
;;;459    
;;;460    	/* 返回操作状态 */
;;;461    	return (status);
;;;462    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L1.42|
00002a  f0040020          AND      r0,r4,#0x20           ;435
00002e  2820              CMP      r0,#0x20              ;435
000030  d000              BEQ      |L1.52|
000032  2701              MOVS     r7,#1                 ;437
                  |L1.52|
000034  f04f40c8          MOV      r0,#0x64000000        ;440
000038  8804              LDRH     r4,[r0,#0]            ;440
00003a  8806              LDRH     r6,[r0,#0]            ;441
00003c  f0040040          AND      r0,r4,#0x40           ;443
000040  f0060140          AND      r1,r6,#0x40           ;443
000044  4288              CMP      r0,r1                 ;443
000046  d101              BNE      |L1.76|
000048  2000              MOVS     r0,#0                 ;445
00004a  e7ec              B        |L1.38|
                  |L1.76|
00004c  f0040020          AND      r0,r4,#0x20           ;447
000050  2820              CMP      r0,#0x20              ;447
000052  d102              BNE      |L1.90|
000054  2702              MOVS     r7,#2                 ;449
000056  f7fffffe          BL       NOR_QuitToReadStatus
                  |L1.90|
00005a  b10d              CBZ      r5,|L1.96|
00005c  2f00              CMP      r7,#0                 ;420
00005e  d1d6              BNE      |L1.14|
                  |L1.96|
000060  b905              CBNZ     r5,|L1.100|
000062  2703              MOVS     r7,#3                 ;456
                  |L1.100|
000064  4638              MOV      r0,r7                 ;461
000066  e7de              B        |L1.38|
;;;463    
                          ENDP


                          AREA ||i.NOR_EraseChip||, CODE, READONLY, ALIGN=2

                  NOR_EraseChip PROC
;;;364    */
;;;365    uint8_t NOR_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000002  20aa              MOVS     r0,#0xaa
000004  490a              LDR      r1,|L2.48|
000006  8008              STRH     r0,[r1,#0]
;;;368    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  2055              MOVS     r0,#0x55
00000a  490a              LDR      r1,|L2.52|
00000c  8008              STRH     r0,[r1,#0]
;;;369    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2080              MOVS     r0,#0x80
000010  4907              LDR      r1,|L2.48|
000012  8008              STRH     r0,[r1,#0]
;;;370    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000014  20aa              MOVS     r0,#0xaa
000016  8008              STRH     r0,[r1,#0]
;;;371    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000018  2055              MOVS     r0,#0x55
00001a  4906              LDR      r1,|L2.52|
00001c  8008              STRH     r0,[r1,#0]
;;;372    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0010);
00001e  2010              MOVS     r0,#0x10
000020  4903              LDR      r1,|L2.48|
000022  8008              STRH     r0,[r1,#0]
;;;373    
;;;374    	return (NOR_GetStatus(ChipErase_Timeout));
000024  f04f5040          MOV      r0,#0x30000000
000028  f7fffffe          BL       NOR_GetStatus
;;;375    }
00002c  bd10              POP      {r4,pc}
;;;376    
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x64000aaa
                  |L2.52|
                          DCD      0x64000554

                          AREA ||i.NOR_EraseSector||, CODE, READONLY, ALIGN=2

                  NOR_EraseSector PROC
;;;471    */
;;;472    uint8_t NOR_EraseSector(uint32_t _uiBlockAddr)
000000  b510              PUSH     {r4,lr}
;;;473    {
000002  4604              MOV      r4,r0
;;;474    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  20aa              MOVS     r0,#0xaa
000006  490b              LDR      r1,|L3.52|
000008  8008              STRH     r0,[r1,#0]
;;;475    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
00000a  2055              MOVS     r0,#0x55
00000c  490a              LDR      r1,|L3.56|
00000e  8008              STRH     r0,[r1,#0]
;;;476    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
000010  2080              MOVS     r0,#0x80
000012  4908              LDR      r1,|L3.52|
000014  8008              STRH     r0,[r1,#0]
;;;477    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000016  20aa              MOVS     r0,#0xaa
000018  8008              STRH     r0,[r1,#0]
;;;478    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
00001a  2055              MOVS     r0,#0x55
00001c  4906              LDR      r1,|L3.56|
00001e  8008              STRH     r0,[r1,#0]
;;;479    	NOR_WRITE((NOR_FLASH_ADDR + _uiBlockAddr), 0x30);
000020  2130              MOVS     r1,#0x30
000022  f04f40c8          MOV      r0,#0x64000000
000026  5301              STRH     r1,[r0,r4]
;;;480    
;;;481    	return (NOR_GetStatus(BlockErase_Timeout));
000028  f44f0020          MOV      r0,#0xa00000
00002c  f7fffffe          BL       NOR_GetStatus
;;;482    }
000030  bd10              POP      {r4,pc}
;;;483    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x64000aaa
                  |L3.56|
                          DCD      0x64000554

                          AREA ||i.NOR_GetStatus||, CODE, READONLY, ALIGN=2

                  NOR_GetStatus PROC
;;;284    */
;;;285    static uint8_t NOR_GetStatus(uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;286    {
000004  4604              MOV      r4,r0
;;;287    	uint16_t val1 = 0x00;
000006  2500              MOVS     r5,#0
;;;288    	uint16_t val2 = 0x00;
000008  2700              MOVS     r7,#0
;;;289    	uint8_t status = NOR_ONGOING;
00000a  f04f0801          MOV      r8,#1
;;;290    	uint32_t timeout = Timeout;
00000e  4626              MOV      r6,r4
;;;291    
;;;292    	/* 等待NOR输出忙信号，高电平时等待。避免NOR的忙信号还未反映过来导致CPU提前认为不忙了 */
;;;293    	while ((!NOR_IS_BUSY()) && (timeout > 0))
000010  e000              B        |L4.20|
                  |L4.18|
;;;294    	{
;;;295    		timeout--;
000012  1e76              SUBS     r6,r6,#1
                  |L4.20|
000014  2140              MOVS     r1,#0x40              ;293
000016  4822              LDR      r0,|L4.160|
000018  f7fffffe          BL       GPIO_ReadInputDataBit
00001c  b108              CBZ      r0,|L4.34|
00001e  2e00              CMP      r6,#0                 ;293
000020  d1f7              BNE      |L4.18|
                  |L4.34|
;;;296    	}
;;;297    
;;;298    	/* 等待NOR忙信号结束，低电平时等待 */
;;;299    	timeout = Timeout;
000022  4626              MOV      r6,r4
;;;300    	while(NOR_IS_BUSY() && (timeout > 0))
000024  e000              B        |L4.40|
                  |L4.38|
;;;301    	{
;;;302    		timeout--;
000026  1e76              SUBS     r6,r6,#1
                  |L4.40|
000028  2140              MOVS     r1,#0x40              ;300
00002a  481d              LDR      r0,|L4.160|
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  b908              CBNZ     r0,|L4.54|
000032  2e00              CMP      r6,#0                 ;300
000034  d1f7              BNE      |L4.38|
                  |L4.54|
;;;303    	}
;;;304    
;;;305    	/*
;;;306    		- DQ 6 编程时跳变
;;;307    		- DQ 6 和 DQ 2 在擦除时跳变
;;;308    		- DQ 2 在擦除挂起时跳变
;;;309    		- DQ 1 在编程错误时置1
;;;310    		- DQ 5 在超时时置1
;;;311    	*/
;;;312    	/* 通过读取DQ6, DQ5 的数据位是否存在翻转现象判断NOR 内部操作是否完成。如果正忙，则第2次读和第1次读的数据不同 */
;;;313    	while ((Timeout != 0x00) && (status != NOR_SUCCESS))
000036  e027              B        |L4.136|
                  |L4.56|
;;;314    	{
;;;315    		Timeout--;
000038  1e64              SUBS     r4,r4,#1
;;;316    
;;;317    		/* Read DQ6 */
;;;318    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
00003a  f04f40c8          MOV      r0,#0x64000000
00003e  8805              LDRH     r5,[r0,#0]
;;;319    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000040  8807              LDRH     r7,[r0,#0]
;;;320    
;;;321    		/* If DQ6 did not toggle between the two reads then return NOR_Success */
;;;322    		if ((val1 & 0x0040) == (val2 & 0x0040))
000042  f0050040          AND      r0,r5,#0x40
000046  f0070140          AND      r1,r7,#0x40
00004a  4288              CMP      r0,r1
00004c  d102              BNE      |L4.84|
;;;323    		{
;;;324    			return NOR_SUCCESS;
00004e  2000              MOVS     r0,#0
                  |L4.80|
;;;325    		}
;;;326    
;;;327    		/* Read DQ2 */
;;;328    		if((val1 & 0x0020) != 0x0020)
;;;329    		{
;;;330    			status = NOR_ONGOING;
;;;331    		}
;;;332    
;;;333    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
;;;334    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
;;;335    
;;;336    		if((val1 & 0x0040) == (val2 & 0x0040))
;;;337    		{
;;;338    			return NOR_SUCCESS;
;;;339    		}
;;;340    		else if ((val1 & 0x0020) == 0x0020)
;;;341    		{
;;;342    			status = NOR_ERROR;
;;;343    			NOR_QuitToReadStatus();
;;;344    		}
;;;345    	}
;;;346    
;;;347    	if (Timeout == 0x00)
;;;348    	{
;;;349    		status = NOR_TIMEOUT;
;;;350    		NOR_QuitToReadStatus();
;;;351    	}
;;;352    
;;;353    	/* 返回操作状态 */
;;;354    	return (status);
;;;355    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L4.84|
000054  f0050020          AND      r0,r5,#0x20           ;328
000058  2820              CMP      r0,#0x20              ;328
00005a  d001              BEQ      |L4.96|
00005c  f04f0801          MOV      r8,#1                 ;330
                  |L4.96|
000060  f04f40c8          MOV      r0,#0x64000000        ;333
000064  8805              LDRH     r5,[r0,#0]            ;333
000066  8807              LDRH     r7,[r0,#0]            ;334
000068  f0050040          AND      r0,r5,#0x40           ;336
00006c  f0070140          AND      r1,r7,#0x40           ;336
000070  4288              CMP      r0,r1                 ;336
000072  d101              BNE      |L4.120|
000074  2000              MOVS     r0,#0                 ;338
000076  e7eb              B        |L4.80|
                  |L4.120|
000078  f0050020          AND      r0,r5,#0x20           ;340
00007c  2820              CMP      r0,#0x20              ;340
00007e  d103              BNE      |L4.136|
000080  f04f0802          MOV      r8,#2                 ;342
000084  f7fffffe          BL       NOR_QuitToReadStatus
                  |L4.136|
000088  b114              CBZ      r4,|L4.144|
00008a  f1b80f00          CMP      r8,#0                 ;313
00008e  d1d3              BNE      |L4.56|
                  |L4.144|
000090  b91c              CBNZ     r4,|L4.154|
000092  f04f0803          MOV      r8,#3                 ;349
000096  f7fffffe          BL       NOR_QuitToReadStatus
                  |L4.154|
00009a  4640              MOV      r0,r8                 ;354
00009c  e7d8              B        |L4.80|
;;;356    
                          ENDP

00009e  0000              DCW      0x0000
                  |L4.160|
                          DCD      0x40020c00

                          AREA ||i.NOR_QuitToReadStatus||, CODE, READONLY, ALIGN=2

                  NOR_QuitToReadStatus PROC
;;;269    */
;;;270    static void NOR_QuitToReadStatus(void)
000000  20aa              MOVS     r0,#0xaa
;;;271    {
;;;272    	NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA);
000002  4905              LDR      r1,|L5.24|
000004  8008              STRH     r0,[r1,#0]
;;;273    	NOR_WRITE(ADDR_SHIFT(0x002AA), 0x0055);
000006  2055              MOVS     r0,#0x55
000008  4904              LDR      r1,|L5.28|
00000a  8008              STRH     r0,[r1,#0]
;;;274    	NOR_WRITE(NOR_FLASH_ADDR, 0x00F0 );
00000c  20f0              MOVS     r0,#0xf0
00000e  f04f41c8          MOV      r1,#0x64000000
000012  8008              STRH     r0,[r1,#0]
;;;275    }
000014  4770              BX       lr
;;;276    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x64000aaa
                  |L5.28|
                          DCD      0x64000554

                          AREA ||i.NOR_ReadBuffer||, CODE, READONLY, ALIGN=1

                  NOR_ReadBuffer PROC
;;;517    */
;;;518    void NOR_ReadBuffer(uint8_t *_pBuf, uint32_t _uiWriteAddr, uint32_t _uiBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;519    {
000002  4616              MOV      r6,r2
;;;520    	uint16_t usHalfWord;
;;;521    	uint16_t *pNor16;
;;;522    	uint32_t i;
;;;523    	uint32_t uiNum;
;;;524    
;;;525    	uiNum = _uiBytes;
000004  4634              MOV      r4,r6
;;;526    	/* 处理首字节 */
;;;527    	if (_uiWriteAddr % 2)	/* 奇数地址 */
000006  f0010701          AND      r7,r1,#1
00000a  b13f              CBZ      r7,|L6.28|
;;;528    	{
;;;529    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
00000c  f06f471c          MVN      r7,#0x9c000000
000010  5a7a              LDRH     r2,[r7,r1]
;;;530    		*_pBuf++ = (usHalfWord >> 8);	/* 取高8Bit */
000012  1217              ASRS     r7,r2,#8
000014  f8007b01          STRB     r7,[r0],#1
;;;531    		uiNum--;
000018  1e64              SUBS     r4,r4,#1
;;;532    		_uiWriteAddr++;		/* 变为偶数 */
00001a  1c49              ADDS     r1,r1,#1
                  |L6.28|
;;;533    	}
;;;534    
;;;535    	/* 按照双字节模式连续读取NOR数据至缓冲区_pBuf */
;;;536    	pNor16 = (uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
00001c  f10143c8          ADD      r3,r1,#0x64000000
;;;537    	for (i = 0; i < uiNum / 2; i++)
000020  2500              MOVS     r5,#0
000022  e008              B        |L6.54|
                  |L6.36|
;;;538    	{
;;;539    		usHalfWord = *pNor16++;
000024  f8332b02          LDRH     r2,[r3],#2
;;;540    		*_pBuf++ = usHalfWord;
000028  f8002b01          STRB     r2,[r0],#1
;;;541    		*_pBuf++ = usHalfWord >> 8;
00002c  1217              ASRS     r7,r2,#8
00002e  f8007b01          STRB     r7,[r0],#1
;;;542    		uiNum -= 2;
000032  1ea4              SUBS     r4,r4,#2
000034  1c6d              ADDS     r5,r5,#1              ;537
                  |L6.54|
000036  ebb50f54          CMP      r5,r4,LSR #1          ;537
00003a  d3f3              BCC      |L6.36|
;;;543    	}
;;;544    
;;;545    	/* 处理最后1个字节 */
;;;546    	if (uiNum == 1)
00003c  2c01              CMP      r4,#1
00003e  d102              BNE      |L6.70|
;;;547    	{
;;;548    		*_pBuf++ = *pNor16;
000040  781f              LDRB     r7,[r3,#0]
000042  f8007b01          STRB     r7,[r0],#1
                  |L6.70|
;;;549    	}
;;;550    }
000046  bdf0              POP      {r4-r7,pc}
;;;551    
                          ENDP


                          AREA ||i.NOR_ReadByte||, CODE, READONLY, ALIGN=1

                  NOR_ReadByte PROC
;;;491    */
;;;492    uint8_t NOR_ReadByte(uint32_t _uiWriteAddr)
000000  4602              MOV      r2,r0
;;;493    {
;;;494    	uint16_t usHalfWord;
;;;495    
;;;496    	if (_uiWriteAddr % 2)	/* 奇数地址 */
000002  f0020001          AND      r0,r2,#1
000006  b120              CBZ      r0,|L7.18|
;;;497    	{
;;;498    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
000008  f06f401c          MVN      r0,#0x9c000000
00000c  5a81              LDRH     r1,[r0,r2]
;;;499    		return (usHalfWord >> 8);	/* 取高8Bit */
00000e  1208              ASRS     r0,r1,#8
                  |L7.16|
;;;500    	}
;;;501    	else	/* 偶数地址 */
;;;502    	{
;;;503    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
;;;504    		return usHalfWord;	/* 取低8Bit */
;;;505    	}
;;;506    }
000010  4770              BX       lr
                  |L7.18|
000012  f04f40c8          MOV      r0,#0x64000000        ;503
000016  5a81              LDRH     r1,[r0,r2]            ;503
000018  b2c8              UXTB     r0,r1                 ;504
00001a  e7f9              B        |L7.16|
;;;507    
                          ENDP


                          AREA ||i.NOR_ReadID||, CODE, READONLY, ALIGN=2

                  NOR_ReadID PROC
;;;240    */
;;;241    uint32_t NOR_ReadID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;242    {
;;;243    	uint32_t uiID;
;;;244    	uint8_t id1, id2, id3, id4;
;;;245    
;;;246    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000002  25aa              MOVS     r5,#0xaa
000004  4e11              LDR      r6,|L8.76|
000006  8035              STRH     r5,[r6,#0]
;;;247    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  2555              MOVS     r5,#0x55
00000a  4e11              LDR      r6,|L8.80|
00000c  8035              STRH     r5,[r6,#0]
;;;248    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0090);
00000e  2590              MOVS     r5,#0x90
000010  4e0e              LDR      r6,|L8.76|
000012  8035              STRH     r5,[r6,#0]
;;;249    
;;;250    	id1 = *(__IO uint16_t *) ADDR_SHIFT(0x0000);
000014  f04f45c8          MOV      r5,#0x64000000
000018  882d              LDRH     r5,[r5,#0]
00001a  b2e9              UXTB     r1,r5
;;;251    	id2 = *(__IO uint16_t *) ADDR_SHIFT(0x0001);
00001c  f04f45c8          MOV      r5,#0x64000000
000020  886d              LDRH     r5,[r5,#2]
000022  b2ea              UXTB     r2,r5
;;;252    	id3 = *(__IO uint16_t *) ADDR_SHIFT(0x000E);
000024  f04f45c8          MOV      r5,#0x64000000
000028  8bad              LDRH     r5,[r5,#0x1c]
00002a  b2eb              UXTB     r3,r5
;;;253    	id4 = *(__IO uint16_t *) ADDR_SHIFT(0x000F);
00002c  f04f45c8          MOV      r5,#0x64000000
000030  8bed              LDRH     r5,[r5,#0x1e]
000032  b2ec              UXTB     r4,r5
;;;254    
;;;255    	uiID = ((uint32_t)id1 << 24) | ((uint32_t)id2 << 16)  | ((uint32_t)id3 << 8) | id4;
000034  060d              LSLS     r5,r1,#24
000036  ea454502          ORR      r5,r5,r2,LSL #16
00003a  ea452503          ORR      r5,r5,r3,LSL #8
00003e  ea450004          ORR      r0,r5,r4
;;;256    
;;;257    	NOR_WRITE(NOR_FLASH_ADDR, 0x00F0 );		/* 退出ID模式 */
000042  25f0              MOVS     r5,#0xf0
000044  f04f46c8          MOV      r6,#0x64000000
000048  8035              STRH     r5,[r6,#0]
;;;258    
;;;259    	return uiID;
;;;260    }
00004a  bd70              POP      {r4-r6,pc}
;;;261    
                          ENDP

                  |L8.76|
                          DCD      0x64000aaa
                  |L8.80|
                          DCD      0x64000554

                          AREA ||i.NOR_StartEraseChip||, CODE, READONLY, ALIGN=2

                  NOR_StartEraseChip PROC
;;;384    */
;;;385    void NOR_StartEraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;386    {
;;;387    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000002  20aa              MOVS     r0,#0xaa
000004  490a              LDR      r1,|L9.48|
000006  8008              STRH     r0,[r1,#0]
;;;388    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  2055              MOVS     r0,#0x55
00000a  490a              LDR      r1,|L9.52|
00000c  8008              STRH     r0,[r1,#0]
;;;389    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2080              MOVS     r0,#0x80
000010  4907              LDR      r1,|L9.48|
000012  8008              STRH     r0,[r1,#0]
;;;390    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000014  20aa              MOVS     r0,#0xaa
000016  8008              STRH     r0,[r1,#0]
;;;391    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000018  2055              MOVS     r0,#0x55
00001a  4906              LDR      r1,|L9.52|
00001c  8008              STRH     r0,[r1,#0]
;;;392    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0010);
00001e  2010              MOVS     r0,#0x10
000020  4903              LDR      r1,|L9.48|
000022  8008              STRH     r0,[r1,#0]
;;;393    	
;;;394    	NOR_GetStatus(1000);
000024  f44f707a          MOV      r0,#0x3e8
000028  f7fffffe          BL       NOR_GetStatus
;;;395    }
00002c  bd10              POP      {r4,pc}
;;;396    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      0x64000aaa
                  |L9.52|
                          DCD      0x64000554

                          AREA ||i.NOR_WriteBuffer||, CODE, READONLY, ALIGN=1

                  NOR_WriteBuffer PROC
;;;676    */
;;;677    uint8_t NOR_WriteBuffer(uint8_t *_pBuf, uint32_t _uiWriteAddr, uint32_t _uiBytes)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;678    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4692              MOV      r10,r2
;;;679    	uint16_t usHalfWord;
;;;680    	uint32_t i;
;;;681    	uint32_t uiNum;
;;;682    	uint8_t ucStatus;
;;;683    
;;;684    	uiNum = _uiBytes;
00000a  46d1              MOV      r9,r10
;;;685    	/* 处理首字节 */
;;;686    	if (_uiWriteAddr % 2)	/* 奇数地址 */
00000c  f0050001          AND      r0,r5,#1
000010  b188              CBZ      r0,|L10.54|
;;;687    	{
;;;688    		/* 读出2字节数据，然后改写高字节，维持以前的低字节数据不变 */
;;;689    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
000012  f06f401c          MVN      r0,#0x9c000000
000016  5b46              LDRH     r6,[r0,r5]
;;;690    		usHalfWord &= 0x00FF;
000018  b2f6              UXTB     r6,r6
;;;691    		usHalfWord |= ((*_pBuf++) << 8);
00001a  f8141b01          LDRB     r1,[r4],#1
00001e  ea462601          ORR      r6,r6,r1,LSL #8
;;;692    
;;;693    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr - 1, usHalfWord);
000022  1e68              SUBS     r0,r5,#1
000024  4631              MOV      r1,r6
000026  f7fffffe          BL       NOR_WriteHalfWord
00002a  4607              MOV      r7,r0
;;;694    		if (ucStatus != NOR_SUCCESS)
00002c  b107              CBZ      r7,|L10.48|
;;;695    		{
;;;696    			goto err_quit;
00002e  e02c              B        |L10.138|
                  |L10.48|
;;;697    		}
;;;698    
;;;699    		uiNum--;
000030  f1a90901          SUB      r9,r9,#1
;;;700    		_uiWriteAddr++;		/* 变为偶数 */
000034  1c6d              ADDS     r5,r5,#1
                  |L10.54|
;;;701    	}
;;;702    
;;;703    	/* 按照双字节模式连续编程NOR数据 */
;;;704    	for (i = 0; i < uiNum / 2; i++)
000036  f04f0800          MOV      r8,#0
00003a  e00f              B        |L10.92|
                  |L10.60|
;;;705    	{
;;;706    		usHalfWord = *_pBuf++;
00003c  f8146b01          LDRB     r6,[r4],#1
;;;707    		usHalfWord |= ((*_pBuf++) << 8);
000040  f8141b01          LDRB     r1,[r4],#1
000044  ea462601          ORR      r6,r6,r1,LSL #8
;;;708    
;;;709    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
000048  4631              MOV      r1,r6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       NOR_WriteHalfWord
000050  4607              MOV      r7,r0
;;;710    		if (ucStatus != NOR_SUCCESS)
000052  b107              CBZ      r7,|L10.86|
;;;711    		{
;;;712    			goto err_quit;
000054  e019              B        |L10.138|
                  |L10.86|
;;;713    		}
;;;714    
;;;715    		_uiWriteAddr += 2;
000056  1cad              ADDS     r5,r5,#2
000058  f1080801          ADD      r8,r8,#1              ;704
                  |L10.92|
00005c  ebb80f59          CMP      r8,r9,LSR #1          ;704
000060  d3ec              BCC      |L10.60|
;;;716    	}
;;;717    
;;;718    	/* 处理最后1个字节 */
;;;719    	if (uiNum % 2)
000062  f0090001          AND      r0,r9,#1
000066  b170              CBZ      r0,|L10.134|
;;;720    	{
;;;721    		/* 读取NOR原始数据，保留高字节 */
;;;722    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
000068  f04f40c8          MOV      r0,#0x64000000
00006c  5b46              LDRH     r6,[r0,r5]
;;;723    		usHalfWord &= 0xFF00;
00006e  f406467f          AND      r6,r6,#0xff00
;;;724    		usHalfWord |= (*_pBuf++);
000072  f8140b01          LDRB     r0,[r4],#1
000076  4306              ORRS     r6,r6,r0
;;;725    
;;;726    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
000078  4631              MOV      r1,r6
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       NOR_WriteHalfWord
000080  4607              MOV      r7,r0
;;;727    		if (ucStatus != NOR_SUCCESS)
000082  b107              CBZ      r7,|L10.134|
;;;728    		{
;;;729    			goto err_quit;
000084  e001              B        |L10.138|
                  |L10.134|
;;;730    		}
;;;731    	}
;;;732    	ucStatus = NOR_SUCCESS;
000086  2700              MOVS     r7,#0
;;;733    err_quit:
000088  bf00              NOP      
                  |L10.138|
;;;734    	return 	ucStatus;
00008a  4638              MOV      r0,r7
;;;735    }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;736    
                          ENDP


                          AREA ||i.NOR_WriteByte||, CODE, READONLY, ALIGN=1

                  NOR_WriteByte PROC
;;;582    */
;;;583    uint8_t NOR_WriteByte(uint32_t _uiWriteAddr, uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;584    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;585    	uint16_t usHalfWord;
;;;586    
;;;587    	if (_uiWriteAddr % 2)	/* 奇数地址 */
000006  f0050001          AND      r0,r5,#1
00000a  b130              CBZ      r0,|L11.26|
;;;588    	{
;;;589    		/* 读出2字节数据，然后改写高字节，维持以前的低字节数据不变 */
;;;590    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
00000c  f06f401c          MVN      r0,#0x9c000000
000010  5b44              LDRH     r4,[r0,r5]
;;;591    		usHalfWord &= 0x00FF;
000012  b2e4              UXTB     r4,r4
;;;592    		usHalfWord |= (_ucByte << 8);
000014  ea442406          ORR      r4,r4,r6,LSL #8
000018  e005              B        |L11.38|
                  |L11.26|
;;;593    	}
;;;594    	else
;;;595    	{
;;;596    		/* 读取NOR原始数据，保留高字节 */
;;;597    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
00001a  f04f40c8          MOV      r0,#0x64000000
00001e  5b44              LDRH     r4,[r0,r5]
;;;598    		usHalfWord &= 0xFF00;
000020  f404447f          AND      r4,r4,#0xff00
;;;599    		usHalfWord |= _ucByte;
000024  4334              ORRS     r4,r4,r6
                  |L11.38|
;;;600    	}
;;;601    	return NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       NOR_WriteHalfWord
;;;602    }
00002e  bd70              POP      {r4-r6,pc}
;;;603    
                          ENDP


                          AREA ||i.NOR_WriteHalfWord||, CODE, READONLY, ALIGN=2

                  NOR_WriteHalfWord PROC
;;;562    */
;;;563    uint8_t NOR_WriteHalfWord(uint32_t _uiWriteAddr, uint16_t _usData)
000000  b570              PUSH     {r4-r6,lr}
;;;564    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;565    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000006  20aa              MOVS     r0,#0xaa
000008  4907              LDR      r1,|L12.40|
00000a  8008              STRH     r0,[r1,#0]
;;;566    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
00000c  2055              MOVS     r0,#0x55
00000e  4907              LDR      r1,|L12.44|
000010  8008              STRH     r0,[r1,#0]
;;;567    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00A0);
000012  20a0              MOVS     r0,#0xa0
000014  4904              LDR      r1,|L12.40|
000016  8008              STRH     r0,[r1,#0]
;;;568    	NOR_WRITE(NOR_FLASH_ADDR + _uiWriteAddr, _usData);
000018  f04f40c8          MOV      r0,#0x64000000
00001c  5344              STRH     r4,[r0,r5]
;;;569    
;;;570    	return (NOR_GetStatus(Program_Timeout));
00001e  f44f50a0          MOV      r0,#0x1400
000022  f7fffffe          BL       NOR_GetStatus
;;;571    }
000026  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

                  |L12.40|
                          DCD      0x64000aaa
                  |L12.44|
                          DCD      0x64000554

                          AREA ||i.NOR_WriteInPage||, CODE, READONLY, ALIGN=2

                  NOR_WriteInPage PROC
;;;614    */
;;;615    uint8_t NOR_WriteInPage(uint16_t *pBuffer, uint32_t _uiWriteAddr,  uint16_t _usNumHalfword)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;616    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;617    	uint32_t lastloadedaddress;
;;;618    	uint32_t currentaddress;
;;;619    	uint32_t endaddress;
;;;620    
;;;621    	/* pdf 表7.7 写入缓冲器编程
;;;622    
;;;623    		写入缓冲器编程允许系统在一个编程操作中写入最多32 个字。与标准的“ 字” 编程算法相比，这可以有效地
;;;624    		加快字编程速度。
;;;625    	*/
;;;626    	
;;;627    	if (_usNumHalfword > 32)
00000a  2f20              CMP      r7,#0x20
00000c  dd02              BLE      |L13.20|
;;;628    	{
;;;629    		return NOR_ERROR;
00000e  2002              MOVS     r0,#2
                  |L13.16|
;;;630    	}
;;;631    	
;;;632    	if ((_uiWriteAddr % 2) != 0)
;;;633    	{
;;;634    		return NOR_ERROR;
;;;635    	}
;;;636    	
;;;637    	_uiWriteAddr = _uiWriteAddr / 2;
;;;638    
;;;639    	currentaddress = _uiWriteAddr;
;;;640    	endaddress = _uiWriteAddr + _usNumHalfword - 1;
;;;641    	lastloadedaddress = _uiWriteAddr;
;;;642    
;;;643    	/* 解锁命令序列 */
;;;644    	NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA);
;;;645    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
;;;646    
;;;647    	/* Write Write Buffer Load Command */
;;;648    	NOR_WRITE(ADDR_SHIFT(_uiWriteAddr), 0x0025);
;;;649    	NOR_WRITE(ADDR_SHIFT(_uiWriteAddr), (_usNumHalfword - 1));
;;;650    
;;;651    	/*  Load Data into NOR Buffer */
;;;652    	while (currentaddress <= endaddress)
;;;653    	{
;;;654    		/* Store last loaded address & data value (for polling) */
;;;655    		lastloadedaddress = currentaddress;
;;;656    
;;;657    		NOR_WRITE(ADDR_SHIFT(currentaddress), *pBuffer++);
;;;658    		currentaddress += 1;
;;;659    	}
;;;660    
;;;661    	NOR_WRITE(ADDR_SHIFT(lastloadedaddress), 0x29);
;;;662    
;;;663    	return (NOR_GetStatus(Program_Timeout));
;;;664    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L13.20|
000014  f0060001          AND      r0,r6,#1              ;632
000018  b108              CBZ      r0,|L13.30|
00001a  2002              MOVS     r0,#2                 ;634
00001c  e7f8              B        |L13.16|
                  |L13.30|
00001e  0876              LSRS     r6,r6,#1              ;637
000020  4634              MOV      r4,r6                 ;639
000022  19f0              ADDS     r0,r6,r7              ;640
000024  f1a00901          SUB      r9,r0,#1              ;640
000028  4625              MOV      r5,r4                 ;641
00002a  20aa              MOVS     r0,#0xaa              ;644
00002c  4912              LDR      r1,|L13.120|
00002e  8008              STRH     r0,[r1,#0]            ;644
000030  2055              MOVS     r0,#0x55              ;645
000032  4912              LDR      r1,|L13.124|
000034  8008              STRH     r0,[r1,#0]            ;645
000036  2125              MOVS     r1,#0x25              ;648
000038  0070              LSLS     r0,r6,#1              ;648
00003a  f10040c8          ADD      r0,r0,#0x64000000     ;648
00003e  8001              STRH     r1,[r0,#0]            ;648
000040  1e78              SUBS     r0,r7,#1              ;649
000042  b281              UXTH     r1,r0                 ;649
000044  0070              LSLS     r0,r6,#1              ;649
000046  f10040c8          ADD      r0,r0,#0x64000000     ;649
00004a  8001              STRH     r1,[r0,#0]            ;649
00004c  e007              B        |L13.94|
                  |L13.78|
00004e  4625              MOV      r5,r4                 ;655
000050  f8381b02          LDRH     r1,[r8],#2            ;657
000054  0060              LSLS     r0,r4,#1              ;657
000056  f10040c8          ADD      r0,r0,#0x64000000     ;657
00005a  8001              STRH     r1,[r0,#0]            ;657
00005c  1c64              ADDS     r4,r4,#1              ;658
                  |L13.94|
00005e  454c              CMP      r4,r9                 ;652
000060  d9f5              BLS      |L13.78|
000062  2129              MOVS     r1,#0x29              ;661
000064  0068              LSLS     r0,r5,#1              ;661
000066  f10040c8          ADD      r0,r0,#0x64000000     ;661
00006a  8001              STRH     r1,[r0,#0]            ;661
00006c  f44f50a0          MOV      r0,#0x1400            ;663
000070  f7fffffe          BL       NOR_GetStatus
000074  e7cc              B        |L13.16|
;;;665    
                          ENDP

000076  0000              DCW      0x0000
                  |L13.120|
                          DCD      0x64000aaa
                  |L13.124|
                          DCD      0x64000554

                          AREA ||i.bsp_InitNorFlash||, CODE, READONLY, ALIGN=2

                  bsp_InitNorFlash PROC
;;;49     */
;;;50     void bsp_InitNorFlash(void)
000000  b500              PUSH     {lr}
;;;51     {
000002  b099              SUB      sp,sp,#0x64
;;;52     	FMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;53     	FMC_NORSRAMTimingInitTypeDef  p;
;;;54     	GPIO_InitTypeDef GPIO_InitStructure;
;;;55     
;;;56     	/* 使能GPIO时钟 */
;;;57     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOF |
000004  2101              MOVS     r1,#1
000006  2078              MOVS     r0,#0x78
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;58     	             RCC_AHB1Periph_GPIOG, ENABLE);
;;;59     
;;;60     	/* 使能 FSMC 时钟 */
;;;61     	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;62     
;;;63     	/* NOR Flash 的 GPIO ：
;;;64     		PD0/FSMC_D2
;;;65     		PD1/FSMC_D3
;;;66     		PD4/FSMC_NOE
;;;67     		PD5/FSMC_NWE
;;;68     
;;;69     		PD6/FSMC_NWAIT		- 忙信号，配置为GPIO，输入模式，通过软件查询方式判忙
;;;70     
;;;71     		PD8/FSMC_D13
;;;72     		PD9/FSMC_D14
;;;73     		PD10/FSMC_D15
;;;74     		PD11/FSMC_CLE/FSMC_A16
;;;75     		PD12/FSMC_ALE/FSMC_A17
;;;76     		PD13/FSMC_A18
;;;77     		PD14/FSMC_D0
;;;78     		PD15/FSMC_D1
;;;79     
;;;80     		PE3/FSMC_A19
;;;81     		PE4/FSMC_A20
;;;82     		PE5/FSMC_A21
;;;83     		PE6/FSMC_A22
;;;84     		PE7/FSMC_D4
;;;85     		PE8/FSMC_D5
;;;86     		PE9/FSMC_D6
;;;87     		PE10/FSMC_D7
;;;88     		PE11/FSMC_D8
;;;89     		PE12/FSMC_D9
;;;90     		PE13/FSMC_D10
;;;91     		PE14/FSMC_D11
;;;92     		PE15/FSMC_D12
;;;93     
;;;94     		PF0/FSMC_A0
;;;95     		PF1/FSMC_A1
;;;96     		PF2/FSMC_A2
;;;97     		PF3/FSMC_A3
;;;98     		PF4/FSMC_A4
;;;99     		PF5/FSMC_A5
;;;100    		PF12/FSMC_A6
;;;101    		PF13/FSMC_A7
;;;102    		PF14/FSMC_A8
;;;103    		PF15/FSMC_A9
;;;104    
;;;105    		PG0/FSMC_A10
;;;106    		PG1/FSMC_A11
;;;107    		PG2/FSMC_A12
;;;108    		PG3/FSMC_A13
;;;109    		PG4/FSMC_A14
;;;110    		PG5/FSMC_A15
;;;111    		PG9/FSMC_NE2	- 片选信号
;;;112    	*/
;;;113    
;;;114    	/* GPIOD configuration */
;;;115    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FMC);
000014  220c              MOVS     r2,#0xc
000016  2100              MOVS     r1,#0
000018  489a              LDR      r0,|L14.644|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;116    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FMC);
00001e  220c              MOVS     r2,#0xc
000020  2101              MOVS     r1,#1
000022  4898              LDR      r0,|L14.644|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;117    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FMC);
000028  220c              MOVS     r2,#0xc
00002a  2104              MOVS     r1,#4
00002c  4895              LDR      r0,|L14.644|
00002e  f7fffffe          BL       GPIO_PinAFConfig
;;;118    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FMC);
000032  220c              MOVS     r2,#0xc
000034  2105              MOVS     r1,#5
000036  4893              LDR      r0,|L14.644|
000038  f7fffffe          BL       GPIO_PinAFConfig
;;;119    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FMC);
00003c  220c              MOVS     r2,#0xc
00003e  2108              MOVS     r1,#8
000040  4890              LDR      r0,|L14.644|
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;120    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FMC);
000046  220c              MOVS     r2,#0xc
000048  2109              MOVS     r1,#9
00004a  488e              LDR      r0,|L14.644|
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;121    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FMC);
000050  220c              MOVS     r2,#0xc
000052  210a              MOVS     r1,#0xa
000054  488b              LDR      r0,|L14.644|
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;122    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FMC);
00005a  220c              MOVS     r2,#0xc
00005c  210b              MOVS     r1,#0xb
00005e  4889              LDR      r0,|L14.644|
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;123    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FMC);
000064  220c              MOVS     r2,#0xc
000066  4611              MOV      r1,r2
000068  4886              LDR      r0,|L14.644|
00006a  f7fffffe          BL       GPIO_PinAFConfig
;;;124    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FMC);
00006e  220c              MOVS     r2,#0xc
000070  210d              MOVS     r1,#0xd
000072  4884              LDR      r0,|L14.644|
000074  f7fffffe          BL       GPIO_PinAFConfig
;;;125    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FMC);
000078  220c              MOVS     r2,#0xc
00007a  210e              MOVS     r1,#0xe
00007c  4881              LDR      r0,|L14.644|
00007e  f7fffffe          BL       GPIO_PinAFConfig
;;;126    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FMC);
000082  220c              MOVS     r2,#0xc
000084  210f              MOVS     r1,#0xf
000086  487f              LDR      r0,|L14.644|
000088  f7fffffe          BL       GPIO_PinAFConfig
;;;127    
;;;128    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_4  | GPIO_Pin_5  |
00008c  f64f7033          MOV      r0,#0xff33
000090  9000              STR      r0,[sp,#0]
;;;129    	                    GPIO_Pin_8  | GPIO_Pin_9  | GPIO_Pin_10 | GPIO_Pin_11 |
;;;130    	                    GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;131    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000092  2002              MOVS     r0,#2
000094  f88d0004          STRB     r0,[sp,#4]
;;;132    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000098  2003              MOVS     r0,#3
00009a  f88d0005          STRB     r0,[sp,#5]
;;;133    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00009e  2000              MOVS     r0,#0
0000a0  f88d0006          STRB     r0,[sp,#6]
;;;134    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000a4  f88d0007          STRB     r0,[sp,#7]
;;;135    
;;;136    	GPIO_Init(GPIOD, &GPIO_InitStructure);
0000a8  4669              MOV      r1,sp
0000aa  4876              LDR      r0,|L14.644|
0000ac  f7fffffe          BL       GPIO_Init
;;;137    
;;;138    	/* GPIOE configuration */
;;;139    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource3 , GPIO_AF_FMC);
0000b0  220c              MOVS     r2,#0xc
0000b2  2103              MOVS     r1,#3
0000b4  4874              LDR      r0,|L14.648|
0000b6  f7fffffe          BL       GPIO_PinAFConfig
;;;140    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FMC);
0000ba  220c              MOVS     r2,#0xc
0000bc  2104              MOVS     r1,#4
0000be  4872              LDR      r0,|L14.648|
0000c0  f7fffffe          BL       GPIO_PinAFConfig
;;;141    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FMC);
0000c4  220c              MOVS     r2,#0xc
0000c6  2105              MOVS     r1,#5
0000c8  486f              LDR      r0,|L14.648|
0000ca  f7fffffe          BL       GPIO_PinAFConfig
;;;142    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource6 , GPIO_AF_FMC);
0000ce  220c              MOVS     r2,#0xc
0000d0  2106              MOVS     r1,#6
0000d2  486d              LDR      r0,|L14.648|
0000d4  f7fffffe          BL       GPIO_PinAFConfig
;;;143    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FMC);
0000d8  220c              MOVS     r2,#0xc
0000da  2107              MOVS     r1,#7
0000dc  486a              LDR      r0,|L14.648|
0000de  f7fffffe          BL       GPIO_PinAFConfig
;;;144    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FMC);
0000e2  220c              MOVS     r2,#0xc
0000e4  2108              MOVS     r1,#8
0000e6  4868              LDR      r0,|L14.648|
0000e8  f7fffffe          BL       GPIO_PinAFConfig
;;;145    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FMC);
0000ec  220c              MOVS     r2,#0xc
0000ee  2109              MOVS     r1,#9
0000f0  4865              LDR      r0,|L14.648|
0000f2  f7fffffe          BL       GPIO_PinAFConfig
;;;146    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FMC);
0000f6  220c              MOVS     r2,#0xc
0000f8  210a              MOVS     r1,#0xa
0000fa  4863              LDR      r0,|L14.648|
0000fc  f7fffffe          BL       GPIO_PinAFConfig
;;;147    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FMC);
000100  220c              MOVS     r2,#0xc
000102  210b              MOVS     r1,#0xb
000104  4860              LDR      r0,|L14.648|
000106  f7fffffe          BL       GPIO_PinAFConfig
;;;148    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FMC);
00010a  220c              MOVS     r2,#0xc
00010c  4611              MOV      r1,r2
00010e  485e              LDR      r0,|L14.648|
000110  f7fffffe          BL       GPIO_PinAFConfig
;;;149    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FMC);
000114  220c              MOVS     r2,#0xc
000116  210d              MOVS     r1,#0xd
000118  485b              LDR      r0,|L14.648|
00011a  f7fffffe          BL       GPIO_PinAFConfig
;;;150    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FMC);
00011e  220c              MOVS     r2,#0xc
000120  210e              MOVS     r1,#0xe
000122  4859              LDR      r0,|L14.648|
000124  f7fffffe          BL       GPIO_PinAFConfig
;;;151    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FMC);
000128  220c              MOVS     r2,#0xc
00012a  210f              MOVS     r1,#0xf
00012c  4856              LDR      r0,|L14.648|
00012e  f7fffffe          BL       GPIO_PinAFConfig
;;;152    
;;;153    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 |
000132  f64f70f8          MOV      r0,#0xfff8
000136  9000              STR      r0,[sp,#0]
;;;154    	                    GPIO_Pin_4  | GPIO_Pin_5  | GPIO_Pin_6 | GPIO_Pin_7 |
;;;155    	                    GPIO_Pin_8  | GPIO_Pin_9  | GPIO_Pin_10 | GPIO_Pin_11|
;;;156    	                    GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;157    
;;;158    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000138  4669              MOV      r1,sp
00013a  4853              LDR      r0,|L14.648|
00013c  f7fffffe          BL       GPIO_Init
;;;159    
;;;160    
;;;161    	/* GPIOF configuration */
;;;162    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource0 , GPIO_AF_FMC);
000140  220c              MOVS     r2,#0xc
000142  2100              MOVS     r1,#0
000144  4851              LDR      r0,|L14.652|
000146  f7fffffe          BL       GPIO_PinAFConfig
;;;163    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource1 , GPIO_AF_FMC);
00014a  220c              MOVS     r2,#0xc
00014c  2101              MOVS     r1,#1
00014e  484f              LDR      r0,|L14.652|
000150  f7fffffe          BL       GPIO_PinAFConfig
;;;164    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource2 , GPIO_AF_FMC);
000154  220c              MOVS     r2,#0xc
000156  2102              MOVS     r1,#2
000158  484c              LDR      r0,|L14.652|
00015a  f7fffffe          BL       GPIO_PinAFConfig
;;;165    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource3 , GPIO_AF_FMC);
00015e  220c              MOVS     r2,#0xc
000160  2103              MOVS     r1,#3
000162  484a              LDR      r0,|L14.652|
000164  f7fffffe          BL       GPIO_PinAFConfig
;;;166    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource4 , GPIO_AF_FMC);
000168  220c              MOVS     r2,#0xc
00016a  2104              MOVS     r1,#4
00016c  4847              LDR      r0,|L14.652|
00016e  f7fffffe          BL       GPIO_PinAFConfig
;;;167    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource5 , GPIO_AF_FMC);
000172  220c              MOVS     r2,#0xc
000174  2105              MOVS     r1,#5
000176  4845              LDR      r0,|L14.652|
000178  f7fffffe          BL       GPIO_PinAFConfig
;;;168    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource12 , GPIO_AF_FMC);
00017c  220c              MOVS     r2,#0xc
00017e  4611              MOV      r1,r2
000180  4842              LDR      r0,|L14.652|
000182  f7fffffe          BL       GPIO_PinAFConfig
;;;169    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource13 , GPIO_AF_FMC);
000186  220c              MOVS     r2,#0xc
000188  210d              MOVS     r1,#0xd
00018a  4840              LDR      r0,|L14.652|
00018c  f7fffffe          BL       GPIO_PinAFConfig
;;;170    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource14 , GPIO_AF_FMC);
000190  220c              MOVS     r2,#0xc
000192  210e              MOVS     r1,#0xe
000194  483d              LDR      r0,|L14.652|
000196  f7fffffe          BL       GPIO_PinAFConfig
;;;171    	GPIO_PinAFConfig(GPIOF, GPIO_PinSource15 , GPIO_AF_FMC);
00019a  220c              MOVS     r2,#0xc
00019c  210f              MOVS     r1,#0xf
00019e  483b              LDR      r0,|L14.652|
0001a0  f7fffffe          BL       GPIO_PinAFConfig
;;;172    
;;;173    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_2  | GPIO_Pin_3  |
0001a4  f24f003f          MOV      r0,#0xf03f
0001a8  9000              STR      r0,[sp,#0]
;;;174    	                    GPIO_Pin_4  | GPIO_Pin_5  | GPIO_Pin_12 | GPIO_Pin_13 |
;;;175    	                    GPIO_Pin_14 | GPIO_Pin_15;
;;;176    
;;;177    	GPIO_Init(GPIOF, &GPIO_InitStructure);
0001aa  4669              MOV      r1,sp
0001ac  4837              LDR      r0,|L14.652|
0001ae  f7fffffe          BL       GPIO_Init
;;;178    
;;;179    
;;;180    	/* GPIOG configuration */
;;;181    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource0 , GPIO_AF_FMC);
0001b2  220c              MOVS     r2,#0xc
0001b4  2100              MOVS     r1,#0
0001b6  4836              LDR      r0,|L14.656|
0001b8  f7fffffe          BL       GPIO_PinAFConfig
;;;182    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource1 , GPIO_AF_FMC);
0001bc  220c              MOVS     r2,#0xc
0001be  2101              MOVS     r1,#1
0001c0  4833              LDR      r0,|L14.656|
0001c2  f7fffffe          BL       GPIO_PinAFConfig
;;;183    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource2 , GPIO_AF_FMC);
0001c6  220c              MOVS     r2,#0xc
0001c8  2102              MOVS     r1,#2
0001ca  4831              LDR      r0,|L14.656|
0001cc  f7fffffe          BL       GPIO_PinAFConfig
;;;184    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource3 , GPIO_AF_FMC);
0001d0  220c              MOVS     r2,#0xc
0001d2  2103              MOVS     r1,#3
0001d4  482e              LDR      r0,|L14.656|
0001d6  f7fffffe          BL       GPIO_PinAFConfig
;;;185    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource4 , GPIO_AF_FMC);
0001da  220c              MOVS     r2,#0xc
0001dc  2104              MOVS     r1,#4
0001de  482c              LDR      r0,|L14.656|
0001e0  f7fffffe          BL       GPIO_PinAFConfig
;;;186    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource5 , GPIO_AF_FMC);
0001e4  220c              MOVS     r2,#0xc
0001e6  2105              MOVS     r1,#5
0001e8  4829              LDR      r0,|L14.656|
0001ea  f7fffffe          BL       GPIO_PinAFConfig
;;;187    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource9 , GPIO_AF_FMC);
0001ee  220c              MOVS     r2,#0xc
0001f0  2109              MOVS     r1,#9
0001f2  4827              LDR      r0,|L14.656|
0001f4  f7fffffe          BL       GPIO_PinAFConfig
;;;188    
;;;189    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_2  | GPIO_Pin_3 |
0001f8  f240203f          MOV      r0,#0x23f
0001fc  9000              STR      r0,[sp,#0]
;;;190    	                    GPIO_Pin_4  | GPIO_Pin_5  | GPIO_Pin_9;
;;;191    
;;;192    	GPIO_Init(GPIOG, &GPIO_InitStructure);
0001fe  4669              MOV      r1,sp
000200  4823              LDR      r0,|L14.656|
000202  f7fffffe          BL       GPIO_Init
;;;193    
;;;194    	/* PD6 作为忙信号, 配置为GPIO输入模式，软件查询 */
;;;195    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000206  2040              MOVS     r0,#0x40
000208  9000              STR      r0,[sp,#0]
;;;196    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 输入模式 */
00020a  2000              MOVS     r0,#0
00020c  f88d0004          STRB     r0,[sp,#4]
;;;197    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000210  2003              MOVS     r0,#3
000212  f88d0005          STRB     r0,[sp,#5]
;;;198    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000216  2000              MOVS     r0,#0
000218  f88d0006          STRB     r0,[sp,#6]
;;;199    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00021c  f88d0007          STRB     r0,[sp,#7]
;;;200    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000220  4669              MOV      r1,sp
000222  4818              LDR      r0,|L14.644|
000224  f7fffffe          BL       GPIO_Init
;;;201    
;;;202    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;203    	p.FMC_AddressSetupTime = 0x07;			/* 0x05正常， 0x04 出错 2014-12-06 由6修改为 7 */
000228  2007              MOVS     r0,#7
00022a  9002              STR      r0,[sp,#8]
;;;204    	p.FMC_AddressHoldTime = 0x01;
00022c  2001              MOVS     r0,#1
00022e  9003              STR      r0,[sp,#0xc]
;;;205    	p.FMC_DataSetupTime = 0x0D;			/* 0x0B正常， 0x0A 出错 2014-12-06 由C修改为 D*/
000230  200d              MOVS     r0,#0xd
000232  9004              STR      r0,[sp,#0x10]
;;;206    	p.FMC_BusTurnAroundDuration = 0x00;
000234  2000              MOVS     r0,#0
000236  9005              STR      r0,[sp,#0x14]
;;;207    	p.FMC_CLKDivision = 0x00;
000238  9006              STR      r0,[sp,#0x18]
;;;208    	p.FMC_DataLatency = 0x00;
00023a  9007              STR      r0,[sp,#0x1c]
;;;209    	p.FMC_AccessMode = FMC_AccessMode_B;
00023c  f04f5080          MOV      r0,#0x10000000
000240  9008              STR      r0,[sp,#0x20]
;;;210    
;;;211    	FSMC_NORSRAMInitStructure.FMC_Bank = FMC_Bank1_NORSRAM2;
000242  2002              MOVS     r0,#2
000244  9009              STR      r0,[sp,#0x24]
;;;212    	FSMC_NORSRAMInitStructure.FMC_DataAddressMux = FMC_DataAddressMux_Disable;
000246  2000              MOVS     r0,#0
000248  900a              STR      r0,[sp,#0x28]
;;;213    	FSMC_NORSRAMInitStructure.FMC_MemoryType = FMC_MemoryType_NOR;
00024a  2008              MOVS     r0,#8
00024c  900b              STR      r0,[sp,#0x2c]
;;;214    	FSMC_NORSRAMInitStructure.FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
00024e  2010              MOVS     r0,#0x10
000250  900c              STR      r0,[sp,#0x30]
;;;215    	FSMC_NORSRAMInitStructure.FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
000252  2000              MOVS     r0,#0
000254  900d              STR      r0,[sp,#0x34]
;;;216    	FSMC_NORSRAMInitStructure.FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;
000256  9014              STR      r0,[sp,#0x50]
;;;217    	FSMC_NORSRAMInitStructure.FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
000258  900e              STR      r0,[sp,#0x38]
;;;218    	FSMC_NORSRAMInitStructure.FMC_WrapMode = FMC_WrapMode_Disable;
00025a  900f              STR      r0,[sp,#0x3c]
;;;219    	FSMC_NORSRAMInitStructure.FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
00025c  9010              STR      r0,[sp,#0x40]
;;;220    	FSMC_NORSRAMInitStructure.FMC_WriteOperation = FMC_WriteOperation_Enable;
00025e  f44f5080          MOV      r0,#0x1000
000262  9011              STR      r0,[sp,#0x44]
;;;221    	FSMC_NORSRAMInitStructure.FMC_WaitSignal = FMC_WaitSignal_Disable;
000264  2000              MOVS     r0,#0
000266  9012              STR      r0,[sp,#0x48]
;;;222    	FSMC_NORSRAMInitStructure.FMC_ExtendedMode = FMC_ExtendedMode_Disable;
000268  9013              STR      r0,[sp,#0x4c]
;;;223    	FSMC_NORSRAMInitStructure.FMC_WriteBurst = FMC_WriteBurst_Disable;
00026a  9015              STR      r0,[sp,#0x54]
;;;224    	FSMC_NORSRAMInitStructure.FMC_ReadWriteTimingStruct = &p;
00026c  a802              ADD      r0,sp,#8
00026e  9017              STR      r0,[sp,#0x5c]
;;;225    	FSMC_NORSRAMInitStructure.FMC_WriteTimingStruct = &p;
000270  9018              STR      r0,[sp,#0x60]
;;;226    
;;;227    	FMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
000272  a809              ADD      r0,sp,#0x24
000274  f7fffffe          BL       FMC_NORSRAMInit
;;;228    
;;;229    	/*!< Enable FSMC Bank1_SRAM2 Bank */
;;;230    	FMC_NORSRAMCmd(FMC_Bank1_NORSRAM2, ENABLE);
000278  2101              MOVS     r1,#1
00027a  2002              MOVS     r0,#2
00027c  f7fffffe          BL       FMC_NORSRAMCmd
;;;231    }
000280  b019              ADD      sp,sp,#0x64
000282  bd00              POP      {pc}
;;;232    
                          ENDP

                  |L14.644|
                          DCD      0x40020c00
                  |L14.648|
                          DCD      0x40021000
                  |L14.652|
                          DCD      0x40021400
                  |L14.656|
                          DCD      0x40021800

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\bsp_nor_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_nor_flash_c_0115485a____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_nor_flash_c_0115485a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_nor_flash_c_0115485a____REVSH|
#line 144
|__asm___15_bsp_nor_flash_c_0115485a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
