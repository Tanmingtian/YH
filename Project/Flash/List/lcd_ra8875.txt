; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\lcd_ra8875.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\lcd_ra8875.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IF:\keil\ARM\RV31\INC -IF:\keil\ARM\CMSIS\Include -IF:\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\lcd_ra8875.crf ..\User\bsp_stm32f4xx\src\LCD_RA8875.c]
                          THUMB

                          AREA ||i.BTE_SetOperateCode||, CODE, READONLY, ALIGN=1

                  BTE_SetOperateCode PROC
;;;586    */
;;;587    void BTE_SetOperateCode(uint8_t _ucOperate)
000000  b510              PUSH     {r4,lr}
;;;588    {
000002  4604              MOV      r4,r0
;;;589    	/*  设定BTE 操作码和光栅运算码  */
;;;590    	RA8875_WriteReg(0x51, _ucOperate);
000004  4621              MOV      r1,r4
000006  2051              MOVS     r0,#0x51
000008  f7fffffe          BL       RA8875_WriteReg
;;;591    }
00000c  bd10              POP      {r4,pc}
;;;592    
                          ENDP


                          AREA ||i.BTE_SetTarBlock||, CODE, READONLY, ALIGN=1

                  BTE_SetTarBlock PROC
;;;553    */
;;;554    void BTE_SetTarBlock(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t _ucLayer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;555    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;556    	/* 设置起点坐标 */
;;;557    	RA8875_WriteReg(0x58, _usX);
000010  b2e9              UXTB     r1,r5
000012  2058              MOVS     r0,#0x58
000014  f7fffffe          BL       RA8875_WriteReg
;;;558    	RA8875_WriteReg(0x59, _usX >> 8);
000018  1229              ASRS     r1,r5,#8
00001a  2059              MOVS     r0,#0x59
00001c  f7fffffe          BL       RA8875_WriteReg
;;;559    
;;;560    	RA8875_WriteReg(0x5A, _usY);
000020  b2e1              UXTB     r1,r4
000022  205a              MOVS     r0,#0x5a
000024  f7fffffe          BL       RA8875_WriteReg
;;;561    	if (_ucLayer == 0)	/* 图层2 */
000028  f1b80f00          CMP      r8,#0
00002c  d104              BNE      |L2.56|
;;;562    	{
;;;563    		RA8875_WriteReg(0x5B, _usY >> 8);
00002e  1221              ASRS     r1,r4,#8
000030  205b              MOVS     r0,#0x5b
000032  f7fffffe          BL       RA8875_WriteReg
000036  e005              B        |L2.68|
                  |L2.56|
;;;564    	}
;;;565    	else
;;;566    	{
;;;567    		RA8875_WriteReg(0x5B, (1 << 7) | (_usY >> 8));	/* Bit7 表示图层， 0 图层1； 1 图层2*/
000038  2080              MOVS     r0,#0x80
00003a  ea402124          ORR      r1,r0,r4,ASR #8
00003e  205b              MOVS     r0,#0x5b
000040  f7fffffe          BL       RA8875_WriteReg
                  |L2.68|
;;;568    	}
;;;569    
;;;570    	/* 设置区块宽度 */
;;;571    	RA8875_WriteReg(0x5C, _usWidth);
000044  b2f9              UXTB     r1,r7
000046  205c              MOVS     r0,#0x5c
000048  f7fffffe          BL       RA8875_WriteReg
;;;572    	RA8875_WriteReg(0x5D, _usWidth >> 8);
00004c  1239              ASRS     r1,r7,#8
00004e  205d              MOVS     r0,#0x5d
000050  f7fffffe          BL       RA8875_WriteReg
;;;573    
;;;574    	/* 设置区块高度 */
;;;575    	RA8875_WriteReg(0x5E, _usHeight);
000054  b2f1              UXTB     r1,r6
000056  205e              MOVS     r0,#0x5e
000058  f7fffffe          BL       RA8875_WriteReg
;;;576    	RA8875_WriteReg(0x5F, _usHeight >> 8);
00005c  1231              ASRS     r1,r6,#8
00005e  205f              MOVS     r0,#0x5f
000060  f7fffffe          BL       RA8875_WriteReg
;;;577    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;578    
                          ENDP


                          AREA ||i.BTE_Start||, CODE, READONLY, ALIGN=2

                  BTE_Start PROC
;;;631    */
;;;632    void BTE_Start(void)
000000  b510              PUSH     {r4,lr}
;;;633    {
;;;634    	s_ucRA8875BusyNow = 1;
000002  2001              MOVS     r0,#1
000004  4904              LDR      r1,|L3.24|
000006  7008              STRB     r0,[r1,#0]
;;;635    	/* RA8875_WriteReg(0x50, 0x80);  不能使用这个函数，因为内部已经操作了 s_ucRA8875BusyNow 标志 */
;;;636    	RA8875_WriteCmd(0x50);	/* 设置寄存器地址 */
000008  2050              MOVS     r0,#0x50
00000a  f7fffffe          BL       RA8875_WriteCmd
;;;637    	RA8875_WriteData(0x80);	/* 写入寄存器值 */
00000e  2080              MOVS     r0,#0x80
000010  f7fffffe          BL       RA8875_WriteData
;;;638    }
000014  bd10              POP      {r4,pc}
;;;639    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.BTE_Wait||, CODE, READONLY, ALIGN=2

                  BTE_Wait PROC
;;;647    */
;;;648    void BTE_Wait(void)
000000  b510              PUSH     {r4,lr}
;;;649    {
;;;650    	while ((RA8875_ReadStatus() & 0x40) == 0x40);
000002  bf00              NOP      
                  |L4.4|
000004  f7fffffe          BL       RA8875_ReadStatus
000008  f0000040          AND      r0,r0,#0x40
00000c  2840              CMP      r0,#0x40
00000e  d0f9              BEQ      |L4.4|
;;;651    	s_ucRA8875BusyNow = 0;
000010  2000              MOVS     r0,#0
000012  4901              LDR      r1,|L4.24|
000014  7008              STRB     r0,[r1,#0]
;;;652    }
000016  bd10              POP      {r4,pc}
;;;653    
                          ENDP

                  |L4.24|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_ClrScr||, CODE, READONLY, ALIGN=2

                  RA8875_ClrScr PROC
;;;1011   */
;;;1012   void RA8875_ClrScr(uint16_t _usColor)
000000  b538              PUSH     {r3-r5,lr}
;;;1013   {
000002  4604              MOV      r4,r0
;;;1014   	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */
;;;1015   
;;;1016   	/* 单色填满功能, 中文pdf 第162页
;;;1017   	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。
;;;1018   
;;;1019   	操作步骤:
;;;1020   		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
;;;1021   		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
;;;1022   		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
;;;1023   		4. 设定前景色  REG[63h], [64h], [65h]
;;;1024   		5. 开启BTE 功能  REG[50h] Bit7 = 1
;;;1025   		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
;;;1026   	*/
;;;1027   	BTE_SetTarBlock(s_WinX, s_WinY, s_WinHeight, s_WinWidth, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  480a              LDR      r0,|L5.52|
00000a  8803              LDRH     r3,[r0,#0]  ; s_WinWidth
00000c  480a              LDR      r0,|L5.56|
00000e  8802              LDRH     r2,[r0,#0]  ; s_WinHeight
000010  480a              LDR      r0,|L5.60|
000012  8801              LDRH     r1,[r0,#0]  ; s_WinY
000014  480a              LDR      r0,|L5.64|
000016  8800              LDRH     r0,[r0,#0]  ; s_WinX
000018  f7fffffe          BL       BTE_SetTarBlock
;;;1028   	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
00001c  200c              MOVS     r0,#0xc
00001e  f7fffffe          BL       BTE_SetOperateCode
;;;1029   	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RA8875_SetFrontColor
;;;1030   	BTE_Start();					/* 开启BTE 功能 */
000028  f7fffffe          BL       BTE_Start
;;;1031   	BTE_Wait();						/* 等待操作结束 */
00002c  f7fffffe          BL       BTE_Wait
;;;1032   }
000030  bd38              POP      {r3-r5,pc}
;;;1033   
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      s_WinWidth
                  |L5.56|
                          DCD      s_WinHeight
                  |L5.60|
                          DCD      s_WinY
                  |L5.64|
                          DCD      s_WinX

                          AREA ||i.RA8875_CtrlGPO||, CODE, READONLY, ALIGN=1

                  RA8875_CtrlGPO PROC
;;;1937   */
;;;1938   void RA8875_CtrlGPO(uint8_t _pin, uint8_t _value)
000000  b570              PUSH     {r4-r6,lr}
;;;1939   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1940   	RA8875_WriteReg(0x13, _value << _pin);
000006  fa05f004          LSL      r0,r5,r4
00000a  b2c1              UXTB     r1,r0
00000c  2013              MOVS     r0,#0x13
00000e  f7fffffe          BL       RA8875_WriteReg
;;;1941   }
000012  bd70              POP      {r4-r6,pc}
;;;1942   
                          ENDP


                          AREA ||i.RA8875_DispAscii||, CODE, READONLY, ALIGN=2

                  RA8875_DispAscii PROC
;;;1625   */
;;;1626   void RA8875_DispAscii(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1627   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1628   	/*
;;;1629   		RA8875 内建8x16 点的ASCII 字型ROM，提供使用者更方便的方式用特定编码 (Code) 输入文
;;;1630   		字。内建的字集支持ISO/IEC 8859-1~4 编码标准，此外，使用者可以透过REG[60h~62h] 选择
;;;1631   		文字前景颜色，以及透过REG[63h~65h] 选择背景颜色.
;;;1632   
;;;1633   		ISO/IEC 8859-1，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。
;;;1634   		它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。
;;;1635   
;;;1636   		ISO/IEC 8859-2 Latin-2或“中欧语言”，是国际标准化组织内ISO/IEC 8859的其中一个8位字符集 .
;;;1637   		ISO/IEC 8859-3 南欧语言字符集
;;;1638   		ISO/IEC 8859-4 北欧语言字符集
;;;1639   	*/
;;;1640   
;;;1641   	/*
;;;1642   	(1) Text mode  REG[40h] bit7=1
;;;1643   	(2) Internal Font ROM Select   REG[21h] bit7=0, bit5=0
;;;1644   	(3) Font foreground and background color Select  REG[63h~65h], REG[60h~62h]
;;;1645   	(4) Write the font Code  CMD_WR[02h]    DATA_WR[font_code]
;;;1646   	*/
;;;1647   	
;;;1648   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1649   
;;;1650   	s_reg_40H |= (1 << 7);
000010  481a              LDR      r0,|L7.124|
000012  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000014  f0400080          ORR      r0,r0,#0x80
000018  4918              LDR      r1,|L7.124|
00001a  7008              STRB     r0,[r1,#0]
;;;1651   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
00001c  4608              MOV      r0,r1
00001e  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000020  2040              MOVS     r0,#0x40
000022  f7fffffe          BL       RA8875_WriteReg
;;;1652   
;;;1653   	/* 选择CGROM font; 选择内部CGROM; 内部CGROM 编码选择ISO/IEC 8859-1. */
;;;1654   	RA8875_WriteReg(0x2F, 0x00);
000026  2100              MOVS     r1,#0
000028  202f              MOVS     r0,#0x2f
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1655   	RA8875_WriteReg(0x21, (0 << 7) | (0 << 5) | (0 << 1) | (0 << 0));
00002e  2100              MOVS     r1,#0
000030  2021              MOVS     r0,#0x21
000032  f7fffffe          BL       RA8875_WriteReg
;;;1656   
;;;1657   	s_ucRA8875BusyNow = 1;
000036  2001              MOVS     r0,#1
000038  4911              LDR      r1,|L7.128|
00003a  7008              STRB     r0,[r1,#0]
;;;1658   
;;;1659   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RA8875_WriteCmd
;;;1660   
;;;1661   	/* 开始循环处理字符 */
;;;1662   	while (*_ptr != 0)
000042  e00a              B        |L7.90|
                  |L7.68|
;;;1663   	{
;;;1664   		RA8875_WriteData(*_ptr);
000044  7820              LDRB     r0,[r4,#0]
000046  f7fffffe          BL       RA8875_WriteData
;;;1665   		while ((RA8875_ReadStatus() & 0x80) == 0x80);	/* 必须等待内部写屏操作完成 */
00004a  bf00              NOP      
                  |L7.76|
00004c  f7fffffe          BL       RA8875_ReadStatus
000050  f0000080          AND      r0,r0,#0x80
000054  2880              CMP      r0,#0x80
000056  d0f9              BEQ      |L7.76|
;;;1666   		_ptr++;
000058  1c64              ADDS     r4,r4,#1
                  |L7.90|
00005a  7820              LDRB     r0,[r4,#0]            ;1662
00005c  2800              CMP      r0,#0                 ;1662
00005e  d1f1              BNE      |L7.68|
;;;1667   	}
;;;1668   	s_ucRA8875BusyNow = 0;
000060  4907              LDR      r1,|L7.128|
000062  7008              STRB     r0,[r1,#0]
;;;1669   
;;;1670   	s_reg_40H &= 0x7F;
000064  4805              LDR      r0,|L7.124|
000066  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000068  f000007f          AND      r0,r0,#0x7f
00006c  4903              LDR      r1,|L7.124|
00006e  7008              STRB     r0,[r1,#0]
;;;1671   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000070  4608              MOV      r0,r1
000072  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000074  2040              MOVS     r0,#0x40
000076  f7fffffe          BL       RA8875_WriteReg
;;;1672   }
00007a  bd70              POP      {r4-r6,pc}
;;;1673   
                          ENDP

                  |L7.124|
                          DCD      s_reg_40H
                  |L7.128|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DispBmpInFlash||, CODE, READONLY, ALIGN=2

                  RA8875_DispBmpInFlash PROC
;;;1046   */
;;;1047   void RA8875_DispBmpInFlash(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1048   	uint32_t _uiFlashAddr)
;;;1049   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;1050   	/* pdf 179页 7-10-1 连续内存直接存取模式
;;;1051   		1. 设定工作窗口范围 (REG[30h] ~REG[37h])和内存写入位置 (REG[46h] ~REG[49h])
;;;1052   		2. 设定Serial Flash/ROM 组态 (REG[05h])
;;;1053   		3. 设定 内存直接存取数据来源起始位置 (REG[B0h] ~REG[B2h])
;;;1054   		4. 设定 内存直接存取区块宽度 (REG[B4h] 和REG[B5h])
;;;1055   		5. 设定 内存直接存取区块高度 (REG[B6h] 和 REG[B7h])
;;;1056   		6. 设定内存直接存取来源图片宽度 (REG[B8h] 和 REG[B9h])
;;;1057   		7. 开启内存直接存取为区块搬移模式 (REG[BFh] bit 1)
;;;1058   		8. 开启内存直接存取起始讯号且检查内存直接存取忙碌讯号 (REG[BFh] bit 0)
;;;1059   	*/
;;;1060   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);	/* REG[30h] ~REG[37h] 和 REG[46h] ~REG[49h] */
00000e  4623              MOV      r3,r4
000010  4632              MOV      r2,r6
000012  4641              MOV      r1,r8
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       RA8875_SetDispWin
;;;1061   
;;;1062   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1063   		7	Serial Flash/ROM I/F # 选择
;;;1064   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板图库芯片接在 1 接口]
;;;1065   				1:选择Serial Flash/ROM 1 接口。
;;;1066   		6	Serial Flash/ROM 寻址模式
;;;1067   				0: 24 位寻址模式。
;;;1068   				此位必须设为0。
;;;1069   		5	Serial Flash/ROM 波形模式
;;;1070   				0: 波形模式 0。
;;;1071   				1: 波形模式 3。
;;;1072   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1073   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1074   			01b: 5 bus ??1 byte 空周期。
;;;1075   			1Xb: 6 bus ??2 byte 空周期。
;;;1076   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1077   			0: 字型模式 。
;;;1078   			1: DMA 模式。
;;;1079   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1080   			0Xb: 单一模式。
;;;1081   			10b: 双倍模式0。
;;;1082   			11b: 双倍模式1。
;;;1083   	*/
;;;1084   	
;;;1085   	/* 对于铁框屏，一片 W25Q128，前面2MB是字库。后面14MB是图片 */
;;;1086   	if (g_tW25.ChipID == W25Q128)
00001a  482c              LDR      r0,|L8.204|
00001c  6800              LDR      r0,[r0,#0]  ; g_tW25
00001e  492c              LDR      r1,|L8.208|
000020  4288              CMP      r0,r1
000022  d106              BNE      |L8.50|
;;;1087   	{
;;;1088   		_uiFlashAddr += PIC_OFFSET;	/* 前面2MB分配给字库 */	
000024  f5051500          ADD      r5,r5,#0x200000
;;;1089   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1090   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000028  2126              MOVS     r1,#0x26
00002a  2005              MOVS     r0,#5
00002c  f7fffffe          BL       RA8875_WriteReg
000030  e003              B        |L8.58|
                  |L8.50|
;;;1091   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1092   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1093   		#endif		
;;;1094   	}	
;;;1095   	else	/* 增强型屏，1片W25Q64(8MB)做字库，1片W25Q64(8MB)做图库 */
;;;1096   	{
;;;1097   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1098   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000032  21a6              MOVS     r1,#0xa6
000034  2005              MOVS     r0,#5
000036  f7fffffe          BL       RA8875_WriteReg
                  |L8.58|
;;;1099   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1100   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1101   		#endif	
;;;1102   	}
;;;1103   
;;;1104   	/*
;;;1105   		Serial Flash/ROM 频率频率设定
;;;1106   			0xb: SFCL 频率 = 系统频率频率(当DMA 为使能状态，并且色彩深度为256 色，则SFCL 频率
;;;1107   				固定为=系统频率频率/ 2)
;;;1108   			10b: SFCL 频率 =系统频率频率/ 2
;;;1109   			11b: SFCL 频率 =系统频率频率/ 4
;;;1110   
;;;1111   		安富莱TFT驱动板。4.3寸系统频率为 68MHz； 7寸系统频率为 81.25MHz。
;;;1112   
;;;1113   		8M串行Flash的访问速度:SPI 时钟频率:80MHz(max.)
;;;1114   		因此可以设置为 1 分频
;;;1115   	*/
;;;1116   	RA8875_WriteReg(0x06, (0 << 0));	/* 设置SCL时钟频率 */
00003a  2100              MOVS     r1,#0
00003c  2006              MOVS     r0,#6
00003e  f7fffffe          BL       RA8875_WriteReg
;;;1117   
;;;1118   	/* 设定源地址
;;;1119   		B0H   DMA 来源开始位置[7:0]
;;;1120   		B1H   DMA 来源开始位置[15:8]
;;;1121   		B2H   DMA 来源开始位置[23:16]
;;;1122   	*/
;;;1123   	RA8875_WriteReg(0xB0, (uint8_t)_uiFlashAddr);
000042  b2e9              UXTB     r1,r5
000044  20b0              MOVS     r0,#0xb0
000046  f7fffffe          BL       RA8875_WriteReg
;;;1124   	RA8875_WriteReg(0xB1, (uint8_t)(_uiFlashAddr >> 8));
00004a  f3c52107          UBFX     r1,r5,#8,#8
00004e  20b1              MOVS     r0,#0xb1
000050  f7fffffe          BL       RA8875_WriteReg
;;;1125   	RA8875_WriteReg(0xB2, (uint8_t)(_uiFlashAddr >> 16));
000054  f3c54107          UBFX     r1,r5,#16,#8
000058  20b2              MOVS     r0,#0xb2
00005a  f7fffffe          BL       RA8875_WriteReg
;;;1126   
;;;1127   	/*
;;;1128   		设置区块大小
;;;1129   		B4   DMA 区块宽度[7:0]
;;;1130   		B5   DMA 区块宽度[9:8]
;;;1131   		B6   DMA 区块高度[7:0]
;;;1132   	    B7   DMA 区块高度[9:8]
;;;1133   	    B8   DMA 来源图片宽度[7:0]
;;;1134   	    B9   DMA 来源图片宽度[9:8]
;;;1135   	*/
;;;1136   	RA8875_WriteReg(0xB4, _usWidth);		/* DMA 区块宽度 */
00005e  b2e1              UXTB     r1,r4
000060  20b4              MOVS     r0,#0xb4
000062  f7fffffe          BL       RA8875_WriteReg
;;;1137   	RA8875_WriteReg(0xB5, _usWidth >> 8);
000066  1221              ASRS     r1,r4,#8
000068  20b5              MOVS     r0,#0xb5
00006a  f7fffffe          BL       RA8875_WriteReg
;;;1138   
;;;1139   	RA8875_WriteReg(0xB6, _usHeight);		/* DMA 区块高度 */
00006e  b2f1              UXTB     r1,r6
000070  20b6              MOVS     r0,#0xb6
000072  f7fffffe          BL       RA8875_WriteReg
;;;1140   	RA8875_WriteReg(0xB7, _usHeight >> 8);
000076  1231              ASRS     r1,r6,#8
000078  20b7              MOVS     r0,#0xb7
00007a  f7fffffe          BL       RA8875_WriteReg
;;;1141   
;;;1142   	RA8875_WriteReg(0xB8, _usWidth);		/* DMA 来源图片宽度 */
00007e  b2e1              UXTB     r1,r4
000080  20b8              MOVS     r0,#0xb8
000082  f7fffffe          BL       RA8875_WriteReg
;;;1143   	RA8875_WriteReg(0xB9, _usWidth >> 8);
000086  1221              ASRS     r1,r4,#8
000088  20b9              MOVS     r0,#0xb9
00008a  f7fffffe          BL       RA8875_WriteReg
;;;1144   
;;;1145   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
00008e  2102              MOVS     r1,#2
000090  20bf              MOVS     r0,#0xbf
000092  f7fffffe          BL       RA8875_WriteReg
;;;1146   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
000096  2102              MOVS     r1,#2
000098  20bf              MOVS     r0,#0xbf
00009a  f7fffffe          BL       RA8875_WriteReg
;;;1147   
;;;1148   	s_ucRA8875BusyNow = 1;
00009e  2001              MOVS     r0,#1
0000a0  490c              LDR      r1,|L8.212|
0000a2  7008              STRB     r0,[r1,#0]
;;;1149   	RA8875_WriteCmd(0xBF);
0000a4  20bf              MOVS     r0,#0xbf
0000a6  f7fffffe          BL       RA8875_WriteCmd
;;;1150   	RA8875_WriteData((1 << 1) | (1 << 0));
0000aa  2003              MOVS     r0,#3
0000ac  f7fffffe          BL       RA8875_WriteData
;;;1151   	while (RA8875_ReadReg_Int(0xBF) & (1 << 0));	/* 等待结束 */
0000b0  bf00              NOP      
                  |L8.178|
0000b2  20bf              MOVS     r0,#0xbf
0000b4  f7fffffe          BL       RA8875_ReadReg_Int
0000b8  f0100f01          TST      r0,#1
0000bc  d1f9              BNE      |L8.178|
;;;1152   	s_ucRA8875BusyNow = 0;
0000be  2000              MOVS     r0,#0
0000c0  4904              LDR      r1,|L8.212|
0000c2  7008              STRB     r0,[r1,#0]
;;;1153   
;;;1154   	RA8875_QuitWinMode();					/* 退出小窗口绘图模式 */
0000c4  f7fffffe          BL       RA8875_QuitWinMode
;;;1155   }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;1156   
                          ENDP

                  |L8.204|
                          DCD      g_tW25
                  |L8.208|
                          DCD      0x00ef4018
                  |L8.212|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DispOff||, CODE, READONLY, ALIGN=1

                  RA8875_DispOff PROC
;;;893    */
;;;894    void RA8875_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;895    {
;;;896    	RA8875_WriteReg(0x01, 0x00);
000002  2100              MOVS     r1,#0
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;897    }
00000a  bd10              POP      {r4,pc}
;;;898    
                          ENDP


                          AREA ||i.RA8875_DispOn||, CODE, READONLY, ALIGN=1

                  RA8875_DispOn PROC
;;;880    */
;;;881    void RA8875_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;882    {
;;;883    	RA8875_WriteReg(0x01, 0x80);
000002  2180              MOVS     r1,#0x80
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;884    }
00000a  bd10              POP      {r4,pc}
;;;885    
                          ENDP


                          AREA ||i.RA8875_DispStr||, CODE, READONLY, ALIGN=2

                  RA8875_DispStr PROC
;;;1685   */
;;;1686   void RA8875_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1687   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1688   	/*
;;;1689   		RA8875 透过使用 ― 上海集通公司 (Genitop Inc) 外部串行式字体内存 (Font ROM)，可支持各样
;;;1690   		的文字写入到DDRAM 中。RA8875 与上海集通公司 (Genitop Inc) 兼容的产品包含 :
;;;1691   		GT21L16TW/GT21H16T1W 、GT23L16U2W 、GT23L24T3Y/GT23H24T3Y 、GT23L24M1Z 、
;;;1692   		及 GT23L32S4W/GT23H32S4W。这些字体包含16x16, 24x24, 32x32 点 (Dot) 与不同的字
;;;1693   
;;;1694   		安富莱RA8875驱动板集成的字库芯片为 集通字库芯片_GT23l32S4W
;;;1695   
;;;1696   		GT23L32S4W是一款内含11X12点阵、15X16点、24X24点阵、32X32点阵的汉字库芯片，支持GB2312
;;;1697   		国标汉字（含有国家信标委合法授权）及SCII字符。排列格式为横置横排。用户通过字符内码，利用本手
;;;1698   		册提供的方法计算出该字符点阵在芯片中的地址，可从该地址连续读出字符点阵信息。
;;;1699   	*/
;;;1700   
;;;1701   	/* 设置文本显示位置，注意文本模式的写入光标和图形模式的写入光标是不同的寄存器 */
;;;1702   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1703   
;;;1704   	//RA8875_SetTextZoom(0, 0);	/* for test */
;;;1705   	
;;;1706   	s_reg_40H |= (1 << 7);
000010  481e              LDR      r0,|L11.140|
000012  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000014  f0400080          ORR      r0,r0,#0x80
000018  491c              LDR      r1,|L11.140|
00001a  7008              STRB     r0,[r1,#0]
;;;1707   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
00001c  4608              MOV      r0,r1
00001e  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000020  2040              MOVS     r0,#0x40
000022  f7fffffe          BL       RA8875_WriteReg
;;;1708   
;;;1709   	/*
;;;1710   		Serial Flash/ROM 频率频率设定
;;;1711   			0xb: SFCL 频率 = 系统频率频率(当DMA 为致能状态，并且色彩深度为256 色，则SFCL 频率
;;;1712   				固定为=系统频率频率/ 2)
;;;1713   			10b: SFCL 频率 =系统频率频率/ 2
;;;1714   			11b: SFCL 频率 =系统频率频率/ 4
;;;1715   
;;;1716   		安富莱驱动板系统频率为 68MHz
;;;1717   
;;;1718   		GT23L32S4W的访问速度:SPI 时钟频率:20MHz(max.)
;;;1719   
;;;1720   		因此需要设置 4 分频, 17MHz
;;;1721   	*/
;;;1722   	RA8875_WriteReg(0x06, (3 << 0));	/* 设置为文本模式 */
000026  2103              MOVS     r1,#3
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1723   
;;;1724   	/* 选择外部字体ROM */
;;;1725   	RA8875_WriteReg(0x21, (0 << 7) | (1 << 5));
00002e  2120              MOVS     r1,#0x20
000030  2021              MOVS     r0,#0x21
000032  f7fffffe          BL       RA8875_WriteReg
;;;1726   
;;;1727   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1728   		7	Serial Flash/ROM I/F # 选择
;;;1729   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板字库芯片接在 0 接口]
;;;1730   				1:选择Serial Flash/ROM 1 接口。
;;;1731   		6	Serial Flash/ROM 寻址模式
;;;1732   				0: 24 位寻址模式。
;;;1733   				此位必须设为0。
;;;1734   		5	Serial Flash/ROM 波形模式
;;;1735   				0: 波形模式 0。
;;;1736   				1: 波形模式 3。
;;;1737   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1738   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1739   			01b: 5 bus ??1 byte 空周期。
;;;1740   			1Xb: 6 bus ??2 byte 空周期。
;;;1741   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1742   			0: 字型模式 。
;;;1743   			1: DMA 模式。
;;;1744   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1745   			0Xb: 单一模式。
;;;1746   			10b: 双倍模式0。
;;;1747   			11b: 双倍模式1。
;;;1748   	*/
;;;1749   	RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (1 << 3) | (0 << 2) | (0 << 1));
000036  2128              MOVS     r1,#0x28
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       RA8875_WriteReg
;;;1750   
;;;1751   	/*
;;;1752   		设置外部字体芯片型号为 GT23L32S4W, 编码为GB2312,
;;;1753   
;;;1754   		Bit1:0 决定ASCII字符的格式:
;;;1755   			0 = NORMAL		 [笔画细, 和汉字顶部对齐]
;;;1756   			1 = Arial		 [笔画粗，和汉字底部对齐]
;;;1757   			2 = Roman		 [笔画细, 和汉字底部对齐]
;;;1758   			3 = Bold		 [乱码,不可用]
;;;1759   	 */
;;;1760   	RA8875_WriteReg(0x2F, (4 << 5) | (0 << 2) | (1 << 0));
00003e  2181              MOVS     r1,#0x81
000040  202f              MOVS     r0,#0x2f
000042  f7fffffe          BL       RA8875_WriteReg
;;;1761   
;;;1762   	s_ucRA8875BusyNow = 1;
000046  2001              MOVS     r0,#1
000048  4911              LDR      r1,|L11.144|
00004a  7008              STRB     r0,[r1,#0]
;;;1763   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00004c  2002              MOVS     r0,#2
00004e  f7fffffe          BL       RA8875_WriteCmd
;;;1764   
;;;1765   	/* 开始循环处理字符 */
;;;1766   	while (*_ptr != 0)
000052  e00a              B        |L11.106|
                  |L11.84|
;;;1767   	{
;;;1768   		RA8875_WriteData(*_ptr);
000054  7820              LDRB     r0,[r4,#0]
000056  f7fffffe          BL       RA8875_WriteData
;;;1769   		while ((RA8875_ReadStatus() & 0x80) == 0x80);
00005a  bf00              NOP      
                  |L11.92|
00005c  f7fffffe          BL       RA8875_ReadStatus
000060  f0000080          AND      r0,r0,#0x80
000064  2880              CMP      r0,#0x80
000066  d0f9              BEQ      |L11.92|
;;;1770   		//while ((RA8875_ReadStatus() & 0x01) != 0);	
;;;1771   		//while(RA8875_ReadBusy());
;;;1772   		_ptr++;
000068  1c64              ADDS     r4,r4,#1
                  |L11.106|
00006a  7820              LDRB     r0,[r4,#0]            ;1766
00006c  2800              CMP      r0,#0                 ;1766
00006e  d1f1              BNE      |L11.84|
;;;1773   	}
;;;1774   	s_ucRA8875BusyNow = 0;
000070  4907              LDR      r1,|L11.144|
000072  7008              STRB     r0,[r1,#0]
;;;1775   
;;;1776   	s_reg_40H &= 0x7F;
000074  4805              LDR      r0,|L11.140|
000076  7800              LDRB     r0,[r0,#0]  ; s_reg_40H
000078  f000007f          AND      r0,r0,#0x7f
00007c  4903              LDR      r1,|L11.140|
00007e  7008              STRB     r0,[r1,#0]
;;;1777   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000080  4608              MOV      r0,r1
000082  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
000084  2040              MOVS     r0,#0x40
000086  f7fffffe          BL       RA8875_WriteReg
;;;1778   }
00008a  bd70              POP      {r4-r6,pc}
;;;1779   
                          ENDP

                  |L11.140|
                          DCD      s_reg_40H
                  |L11.144|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawBMP||, CODE, READONLY, ALIGN=2

                  RA8875_DrawBMP PROC
;;;1168   */
;;;1169   void RA8875_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1170   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;1171   	uint32_t index = 0;
000010  2600              MOVS     r6,#0
;;;1172   	const uint16_t *p;
;;;1173   
;;;1174   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1175   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
000012  462b              MOV      r3,r5
000014  4622              MOV      r2,r4
000016  4649              MOV      r1,r9
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       RA8875_SetDispWin
;;;1176   
;;;1177   	s_ucRA8875BusyNow = 1;
00001e  2001              MOVS     r0,#1
000020  490b              LDR      r1,|L12.80|
000022  7008              STRB     r0,[r1,#0]
;;;1178   
;;;1179   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RA8875_WriteCmd
;;;1180   
;;;1181   	p = _ptr;
00002a  4657              MOV      r7,r10
;;;1182   	for (index = 0; index < _usHeight * _usWidth; index++)
00002c  bf00              NOP      
00002e  e004              B        |L12.58|
                  |L12.48|
;;;1183   	{
;;;1184   		/*
;;;1185   			armfly : 进行优化, 函数就地展开
;;;1186   			RA8875_WriteRAM(_ptr[index]);
;;;1187   
;;;1188   			此处可考虑用DMA操作
;;;1189   		*/
;;;1190   		RA8875_WriteData16(*p++);
000030  f8370b02          LDRH     r0,[r7],#2
000034  f7fffffe          BL       RA8875_WriteData16
000038  1c76              ADDS     r6,r6,#1              ;1182
                  |L12.58|
00003a  fb04f005          MUL      r0,r4,r5              ;1182
00003e  42b0              CMP      r0,r6                 ;1182
000040  d8f6              BHI      |L12.48|
;;;1191   	}
;;;1192   	s_ucRA8875BusyNow = 0;
000042  2000              MOVS     r0,#0
000044  4902              LDR      r1,|L12.80|
000046  7008              STRB     r0,[r1,#0]
;;;1193   
;;;1194   	/* 退出窗口绘图模式 */
;;;1195   	RA8875_QuitWinMode();
000048  f7fffffe          BL       RA8875_QuitWinMode
;;;1196   }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;1197   
                          ENDP

                  |L12.80|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawCircle||, CODE, READONLY, ALIGN=2

                  RA8875_DrawCircle PROC
;;;1447   */
;;;1448   void RA8875_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1449   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1450   	/*
;;;1451   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1452   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1453   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1454   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1455   		画出空心圆 (Not Fill
;;;1456   	*/
;;;1457   	/* 设置圆的半径 */
;;;1458   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L13.20|
                  |L13.16|
;;;1459   	{
;;;1460   		return;
;;;1461   	}
;;;1462   
;;;1463   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1464   	{
;;;1465   		uint16_t temp;
;;;1466   		
;;;1467   		temp = _usX;
;;;1468   		_usX = _usY;
;;;1469   		_usY = temp;
;;;1470   	}
;;;1471   	
;;;1472   	/* 设置圆心坐标 */
;;;1473   	RA8875_WriteReg(0x99, _usX);
;;;1474   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1475   	RA8875_WriteReg(0x9B, _usY);
;;;1476   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1477   
;;;1478   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1479   
;;;1480   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1481   
;;;1482   	s_ucRA8875BusyNow = 1;
;;;1483   //	RA8875_WriteReg(0x90, (1 << 6) | (0 << 5));				/* 开始画圆, 不填充  */
;;;1484   	RA8875_WriteCmd(0x90);
;;;1485   	RA8875_WriteData( (1 << 6) | (0 << 5));
;;;1486   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1487   	RA8875_WaitBusy();
;;;1488   	s_ucRA8875BusyNow = 0;
;;;1489   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L13.20|
000014  4817              LDR      r0,|L13.116|
000016  7800              LDRB     r0,[r0,#0]            ;1463  ; g_LcdDirection
000018  2801              CMP      r0,#1                 ;1463
00001a  dd03              BLE      |L13.36|
00001c  4620              MOV      r0,r4                 ;1467
00001e  462c              MOV      r4,r5                 ;1468
000020  4605              MOV      r5,r0                 ;1469
000022  bf00              NOP                            ;1470
                  |L13.36|
000024  b2e1              UXTB     r1,r4                 ;1473
000026  2099              MOVS     r0,#0x99              ;1473
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1221              ASRS     r1,r4,#8              ;1474
00002e  209a              MOVS     r0,#0x9a              ;1474
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2e9              UXTB     r1,r5                 ;1475
000036  209b              MOVS     r0,#0x9b              ;1475
000038  f7fffffe          BL       RA8875_WriteReg
00003c  1229              ASRS     r1,r5,#8              ;1476
00003e  209c              MOVS     r0,#0x9c              ;1476
000040  f7fffffe          BL       RA8875_WriteReg
000044  b2f1              UXTB     r1,r6                 ;1478
000046  209d              MOVS     r0,#0x9d              ;1478
000048  f7fffffe          BL       RA8875_WriteReg
00004c  4638              MOV      r0,r7                 ;1480
00004e  f7fffffe          BL       RA8875_SetFrontColor
000052  2001              MOVS     r0,#1                 ;1482
000054  4908              LDR      r1,|L13.120|
000056  7008              STRB     r0,[r1,#0]            ;1482
000058  2090              MOVS     r0,#0x90              ;1484
00005a  f7fffffe          BL       RA8875_WriteCmd
00005e  2040              MOVS     r0,#0x40              ;1485
000060  f7fffffe          BL       RA8875_WriteData
000064  f7fffffe          BL       RA8875_WaitBusy
000068  2000              MOVS     r0,#0                 ;1488
00006a  4903              LDR      r1,|L13.120|
00006c  7008              STRB     r0,[r1,#0]            ;1488
00006e  bf00              NOP      
000070  e7ce              B        |L13.16|
;;;1490   
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      g_LcdDirection
                  |L13.120|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawHColorLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawHColorLine PROC
;;;2051   */
;;;2052   void RA8875_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2053   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;2054   	uint16_t i;
;;;2055   
;;;2056   	RA8875_SetCursor(_usX1, _usY1);
00000c  4641              MOV      r1,r8
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       RA8875_SetCursor
;;;2057   
;;;2058   s_ucRA8875BusyNow = 1;
000014  2001              MOVS     r0,#1
000016  490a              LDR      r1,|L14.64|
000018  7008              STRB     r0,[r1,#0]
;;;2059   	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       RA8875_WriteCmd
;;;2060   
;;;2061   	for (i = 0; i < _usWidth; i++)
000020  2600              MOVS     r6,#0
000022  e005              B        |L14.48|
                  |L14.36|
;;;2062   	{
;;;2063   		RA8875_WriteData16(*_pColor++);
000024  f8340b02          LDRH     r0,[r4],#2
000028  f7fffffe          BL       RA8875_WriteData16
00002c  1c70              ADDS     r0,r6,#1              ;2061
00002e  b286              UXTH     r6,r0                 ;2061
                  |L14.48|
000030  42ae              CMP      r6,r5                 ;2061
000032  dbf7              BLT      |L14.36|
;;;2064   	}
;;;2065   	s_ucRA8875BusyNow = 0;
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L14.64|
000038  7008              STRB     r0,[r1,#0]
;;;2066   
;;;2067   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;2068   
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawHLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawHLine PROC
;;;2026   */
;;;2027   void RA8875_DrawHLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2028   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;2029   	uint16_t i;
;;;2030   s_ucRA8875BusyNow = 1;
00000c  2001              MOVS     r0,#1
00000e  490c              LDR      r1,|L15.64|
000010  7008              STRB     r0,[r1,#0]
;;;2031   	RA8875_SetCursor(_usX1, _usY1);
000012  4641              MOV      r1,r8
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RA8875_SetCursor
;;;2032   
;;;2033   	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       RA8875_WriteCmd
;;;2034   	for (i = 0; i < _usX2 - _usX1 + 1; i++)
000020  2700              MOVS     r7,#0
000022  e004              B        |L15.46|
                  |L15.36|
;;;2035   	{
;;;2036   		RA8875_WriteData16(_usColor);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       RA8875_WriteData16
00002a  1c78              ADDS     r0,r7,#1              ;2034
00002c  b287              UXTH     r7,r0                 ;2034
                  |L15.46|
00002e  1b28              SUBS     r0,r5,r4              ;2034
000030  1c40              ADDS     r0,r0,#1              ;2034
000032  42b8              CMP      r0,r7                 ;2034
000034  dcf6              BGT      |L15.36|
;;;2037   	}
;;;2038   s_ucRA8875BusyNow = 0;
000036  2000              MOVS     r0,#0
000038  4901              LDR      r1,|L15.64|
00003a  7008              STRB     r0,[r1,#0]
;;;2039   }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;2040   
                          ENDP

                  |L15.64|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawLine PROC
;;;1250   */
;;;1251   void RA8875_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1252   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1253   	/* pdf 第131页
;;;1254   		RA8875 支持直线绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画直线。先设
;;;1255   		定直线的起始点REG[91h~94h] 与结束点REG[95h~98h]，直线的颜色REG[63h~65h]，然后启
;;;1256   		动绘图设定REG[90h] Bit4 = 0, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将直线的图形写入
;;;1257   		DDRAM，相对的在TFT 模块上就可以显示所画的直线。
;;;1258   	*/
;;;1259   
;;;1260   	if ((_usX1 == _usX2) && (_usY1 == _usY2))
000010  42b4              CMP      r4,r6
000012  d108              BNE      |L16.38|
000014  42bd              CMP      r5,r7
000016  d106              BNE      |L16.38|
;;;1261   	{
;;;1262   		RA8875_PutPixel(_usX1, _usY1, _usColor);
000018  4642              MOV      r2,r8
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       RA8875_PutPixel
                  |L16.34|
;;;1263   		return;
;;;1264   	}
;;;1265   
;;;1266   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1267   	{
;;;1268   		uint16_t temp;
;;;1269   		
;;;1270   		temp = _usX1;
;;;1271   		_usX1 = _usY1;
;;;1272   		_usY1 = temp;
;;;1273   
;;;1274   		temp = _usX2;
;;;1275   		_usX2 = _usY2;
;;;1276   		_usY2 = temp;		
;;;1277   	}
;;;1278   	
;;;1279   	/* 设置起点坐标 */
;;;1280   	RA8875_WriteReg(0x91, _usX1);
;;;1281   	RA8875_WriteReg(0x92, _usX1 >> 8);
;;;1282   	RA8875_WriteReg(0x93, _usY1);
;;;1283   	RA8875_WriteReg(0x94, _usY1 >> 8);
;;;1284   
;;;1285   	/* 设置终点坐标 */
;;;1286   	RA8875_WriteReg(0x95, _usX2);
;;;1287   	RA8875_WriteReg(0x96, _usX2 >> 8);
;;;1288   	RA8875_WriteReg(0x97, _usY2);
;;;1289   	RA8875_WriteReg(0x98, _usY2 >> 8);
;;;1290   
;;;1291   	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */
;;;1292   
;;;1293   	s_ucRA8875BusyNow = 1;
;;;1294   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 4) | (0 << 0));/* 开始画直线 */
;;;1295   	RA8875_WriteCmd(0x90);
;;;1296   	RA8875_WriteData((1 << 7) | (0 << 4) | (0 << 0));
;;;1297   //	while (RA8875_ReadReg(0x90) & (1 << 7));				/* 等待结束 */
;;;1298   	RA8875_WaitBusy();
;;;1299   	s_ucRA8875BusyNow = 0;
;;;1300   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L16.38|
000026  481f              LDR      r0,|L16.164|
000028  7800              LDRB     r0,[r0,#0]            ;1266  ; g_LcdDirection
00002a  2801              CMP      r0,#1                 ;1266
00002c  dd06              BLE      |L16.60|
00002e  4620              MOV      r0,r4                 ;1270
000030  462c              MOV      r4,r5                 ;1271
000032  4605              MOV      r5,r0                 ;1272
000034  4630              MOV      r0,r6                 ;1274
000036  463e              MOV      r6,r7                 ;1275
000038  4607              MOV      r7,r0                 ;1276
00003a  bf00              NOP                            ;1277
                  |L16.60|
00003c  b2e1              UXTB     r1,r4                 ;1280
00003e  2091              MOVS     r0,#0x91              ;1280
000040  f7fffffe          BL       RA8875_WriteReg
000044  1221              ASRS     r1,r4,#8              ;1281
000046  2092              MOVS     r0,#0x92              ;1281
000048  f7fffffe          BL       RA8875_WriteReg
00004c  b2e9              UXTB     r1,r5                 ;1282
00004e  2093              MOVS     r0,#0x93              ;1282
000050  f7fffffe          BL       RA8875_WriteReg
000054  1229              ASRS     r1,r5,#8              ;1283
000056  2094              MOVS     r0,#0x94              ;1283
000058  f7fffffe          BL       RA8875_WriteReg
00005c  b2f1              UXTB     r1,r6                 ;1286
00005e  2095              MOVS     r0,#0x95              ;1286
000060  f7fffffe          BL       RA8875_WriteReg
000064  1231              ASRS     r1,r6,#8              ;1287
000066  2096              MOVS     r0,#0x96              ;1287
000068  f7fffffe          BL       RA8875_WriteReg
00006c  b2f9              UXTB     r1,r7                 ;1288
00006e  2097              MOVS     r0,#0x97              ;1288
000070  f7fffffe          BL       RA8875_WriteReg
000074  1239              ASRS     r1,r7,#8              ;1289
000076  2098              MOVS     r0,#0x98              ;1289
000078  f7fffffe          BL       RA8875_WriteReg
00007c  4640              MOV      r0,r8                 ;1291
00007e  f7fffffe          BL       RA8875_SetFrontColor
000082  2001              MOVS     r0,#1                 ;1293
000084  4908              LDR      r1,|L16.168|
000086  7008              STRB     r0,[r1,#0]            ;1293
000088  2090              MOVS     r0,#0x90              ;1295
00008a  f7fffffe          BL       RA8875_WriteCmd
00008e  2080              MOVS     r0,#0x80              ;1296
000090  f7fffffe          BL       RA8875_WriteData
000094  f7fffffe          BL       RA8875_WaitBusy
000098  2000              MOVS     r0,#0                 ;1299
00009a  4903              LDR      r1,|L16.168|
00009c  7008              STRB     r0,[r1,#0]            ;1299
00009e  bf00              NOP      
0000a0  e7bf              B        |L16.34|
;;;1301   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L16.164|
                          DCD      g_LcdDirection
                  |L16.168|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawRect||, CODE, READONLY, ALIGN=2

                  RA8875_DrawRect PROC
;;;1313   */
;;;1314   void RA8875_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1315   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1316   	/*
;;;1317   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1318   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1319   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1320   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1321   	实心方形 (Fill)
;;;1322   
;;;1323   	 ---------------->---
;;;1324   	|(_usX，_usY)        |
;;;1325   	V                    V  _usHeight
;;;1326   	|                    |
;;;1327   	 ---------------->---
;;;1328   		  _usWidth
;;;1329   	*/
;;;1330   
;;;1331   	if (g_LcdDirection > 1)	/* 竖屏  */
000010  4823              LDR      r0,|L17.160|
000012  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000014  2801              CMP      r0,#1
000016  dd06              BLE      |L17.38|
;;;1332   	{
;;;1333   		uint16_t temp;
;;;1334   		
;;;1335   		temp = _usX;
000018  4620              MOV      r0,r4
;;;1336   		_usX = _usY;
00001a  462c              MOV      r4,r5
;;;1337   		_usY = temp;
00001c  4605              MOV      r5,r0
;;;1338   
;;;1339   		temp = _usHeight;
00001e  4630              MOV      r0,r6
;;;1340   		_usHeight = _usWidth;
000020  463e              MOV      r6,r7
;;;1341   		_usWidth = temp;		
000022  4607              MOV      r7,r0
;;;1342   	}
000024  bf00              NOP      
                  |L17.38|
;;;1343   
;;;1344   	/* 设置起点坐标 */
;;;1345   	RA8875_WriteReg(0x91, _usX);
000026  b2e1              UXTB     r1,r4
000028  2091              MOVS     r0,#0x91
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1346   	RA8875_WriteReg(0x92, _usX >> 8);
00002e  1221              ASRS     r1,r4,#8
000030  2092              MOVS     r0,#0x92
000032  f7fffffe          BL       RA8875_WriteReg
;;;1347   	RA8875_WriteReg(0x93, _usY);
000036  b2e9              UXTB     r1,r5
000038  2093              MOVS     r0,#0x93
00003a  f7fffffe          BL       RA8875_WriteReg
;;;1348   	RA8875_WriteReg(0x94, _usY >> 8);
00003e  1229              ASRS     r1,r5,#8
000040  2094              MOVS     r0,#0x94
000042  f7fffffe          BL       RA8875_WriteReg
;;;1349   
;;;1350   	/* 设置终点坐标 */
;;;1351   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000046  19e0              ADDS     r0,r4,r7
000048  1e40              SUBS     r0,r0,#1
00004a  b2c1              UXTB     r1,r0
00004c  2095              MOVS     r0,#0x95
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1352   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
000052  19e0              ADDS     r0,r4,r7
000054  1e40              SUBS     r0,r0,#1
000056  f3c02107          UBFX     r1,r0,#8,#8
00005a  2096              MOVS     r0,#0x96
00005c  f7fffffe          BL       RA8875_WriteReg
;;;1353   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
000060  19a8              ADDS     r0,r5,r6
000062  1e40              SUBS     r0,r0,#1
000064  b2c1              UXTB     r1,r0
000066  2097              MOVS     r0,#0x97
000068  f7fffffe          BL       RA8875_WriteReg
;;;1354   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
00006c  19a8              ADDS     r0,r5,r6
00006e  1e40              SUBS     r0,r0,#1
000070  f3c02107          UBFX     r1,r0,#8,#8
000074  2098              MOVS     r0,#0x98
000076  f7fffffe          BL       RA8875_WriteReg
;;;1355   
;;;1356   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       RA8875_SetFrontColor
;;;1357   
;;;1358   	s_ucRA8875BusyNow = 1;
000080  2001              MOVS     r0,#1
000082  4908              LDR      r1,|L17.164|
000084  7008              STRB     r0,[r1,#0]
;;;1359   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));	/* 开始画矩形  */
;;;1360   	RA8875_WriteCmd(0x90);
000086  2090              MOVS     r0,#0x90
000088  f7fffffe          BL       RA8875_WriteCmd
;;;1361   	RA8875_WriteData((1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));
00008c  2090              MOVS     r0,#0x90
00008e  f7fffffe          BL       RA8875_WriteData
;;;1362   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1363   	RA8875_WaitBusy();
000092  f7fffffe          BL       RA8875_WaitBusy
;;;1364   	s_ucRA8875BusyNow = 0;
000096  2000              MOVS     r0,#0
000098  4902              LDR      r1,|L17.164|
00009a  7008              STRB     r0,[r1,#0]
;;;1365   }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;1366   
                          ENDP

                  |L17.160|
                          DCD      g_LcdDirection
                  |L17.164|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_DrawVLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawVLine PROC
;;;2079   */
;;;2080   void RA8875_DrawVLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2081   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2082   	uint16_t i;
;;;2083   
;;;2084   	RA8875_SetCursor(_usX1, _usY1);
00000c  4621              MOV      r1,r4
00000e  4640              MOV      r0,r8
000010  f7fffffe          BL       RA8875_SetCursor
;;;2085   
;;;2086   	for (i = 1; i <= _usY2 - _usY1 + 1; i++)
000014  2501              MOVS     r5,#1
000016  e00f              B        |L18.56|
                  |L18.24|
;;;2087   	{
;;;2088   		s_ucRA8875BusyNow = 1;
000018  2001              MOVS     r0,#1
00001a  490a              LDR      r1,|L18.68|
00001c  7008              STRB     r0,[r1,#0]
;;;2089   
;;;2090   		RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RA8875_WriteCmd
;;;2091   		RA8875_WriteData16(_usColor);
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       RA8875_WriteData16
;;;2092   
;;;2093   		RA8875_SetCursor(_usX1, _usY1 + i);
00002a  1960              ADDS     r0,r4,r5
00002c  b281              UXTH     r1,r0
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       RA8875_SetCursor
000034  1c68              ADDS     r0,r5,#1              ;2086
000036  b285              UXTH     r5,r0                 ;2086
                  |L18.56|
000038  1b30              SUBS     r0,r6,r4              ;2086
00003a  1c40              ADDS     r0,r0,#1              ;2086
00003c  42a8              CMP      r0,r5                 ;2086
00003e  daeb              BGE      |L18.24|
;;;2094   	}
;;;2095   
;;;2096   }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;2097   
                          ENDP

                  |L18.68|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_FillCircle||, CODE, READONLY, ALIGN=2

                  RA8875_FillCircle PROC
;;;1501   */
;;;1502   void RA8875_FillCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1503   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1504   	/*
;;;1505   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1506   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1507   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1508   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1509   		画出空心圆 (Not Fill
;;;1510   	*/
;;;1511   	/* 设置圆的半径 */
;;;1512   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L19.20|
                  |L19.16|
;;;1513   	{
;;;1514   		return;
;;;1515   	}
;;;1516   
;;;1517   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1518   	{
;;;1519   		uint16_t temp;
;;;1520   		
;;;1521   		temp = _usX;
;;;1522   		_usX = _usY;
;;;1523   		_usY = temp;
;;;1524   	}
;;;1525   	
;;;1526   	/* 设置圆心坐标 */
;;;1527   	RA8875_WriteReg(0x99, _usX);
;;;1528   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1529   	RA8875_WriteReg(0x9B, _usY);
;;;1530   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1531   
;;;1532   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1533   
;;;1534   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1535   
;;;1536   	s_ucRA8875BusyNow = 1;
;;;1537   //	RA8875_WriteReg(0x90, (1 << 6) | (1 << 5));				/* 开始画圆, 填充  */
;;;1538   	RA8875_WriteCmd(0x90);
;;;1539   	RA8875_WriteData((1 << 6) | (1 << 5));
;;;1540   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1541   	RA8875_WaitBusy();
;;;1542   	s_ucRA8875BusyNow = 0;
;;;1543   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L19.20|
000014  4817              LDR      r0,|L19.116|
000016  7800              LDRB     r0,[r0,#0]            ;1517  ; g_LcdDirection
000018  2801              CMP      r0,#1                 ;1517
00001a  dd03              BLE      |L19.36|
00001c  4620              MOV      r0,r4                 ;1521
00001e  462c              MOV      r4,r5                 ;1522
000020  4605              MOV      r5,r0                 ;1523
000022  bf00              NOP                            ;1524
                  |L19.36|
000024  b2e1              UXTB     r1,r4                 ;1527
000026  2099              MOVS     r0,#0x99              ;1527
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1221              ASRS     r1,r4,#8              ;1528
00002e  209a              MOVS     r0,#0x9a              ;1528
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2e9              UXTB     r1,r5                 ;1529
000036  209b              MOVS     r0,#0x9b              ;1529
000038  f7fffffe          BL       RA8875_WriteReg
00003c  1229              ASRS     r1,r5,#8              ;1530
00003e  209c              MOVS     r0,#0x9c              ;1530
000040  f7fffffe          BL       RA8875_WriteReg
000044  b2f1              UXTB     r1,r6                 ;1532
000046  209d              MOVS     r0,#0x9d              ;1532
000048  f7fffffe          BL       RA8875_WriteReg
00004c  4638              MOV      r0,r7                 ;1534
00004e  f7fffffe          BL       RA8875_SetFrontColor
000052  2001              MOVS     r0,#1                 ;1536
000054  4908              LDR      r1,|L19.120|
000056  7008              STRB     r0,[r1,#0]            ;1536
000058  2090              MOVS     r0,#0x90              ;1538
00005a  f7fffffe          BL       RA8875_WriteCmd
00005e  2060              MOVS     r0,#0x60              ;1539
000060  f7fffffe          BL       RA8875_WriteData
000064  f7fffffe          BL       RA8875_WaitBusy
000068  2000              MOVS     r0,#0                 ;1542
00006a  4903              LDR      r1,|L19.120|
00006c  7008              STRB     r0,[r1,#0]            ;1542
00006e  bf00              NOP      
000070  e7ce              B        |L19.16|
;;;1544   
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      g_LcdDirection
                  |L19.120|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_FillRect||, CODE, READONLY, ALIGN=2

                  RA8875_FillRect PROC
;;;1378   */
;;;1379   void RA8875_FillRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1380   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1381   	/*
;;;1382   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1383   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1384   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1385   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1386   	实心方形 (Fill)
;;;1387   
;;;1388   	 ---------------->---
;;;1389   	|(_usX，_usY)        |
;;;1390   	V                    V  _usHeight
;;;1391   	|                    |
;;;1392   	 ---------------->---
;;;1393   		  _usWidth
;;;1394   	*/
;;;1395   
;;;1396   	if (_usWidth == 0 || _usHeight == 0)
000010  b107              CBZ      r7,|L20.20|
000012  b90e              CBNZ     r6,|L20.24|
                  |L20.20|
;;;1397   	{
;;;1398   		return;
;;;1399   	}
;;;1400   
;;;1401   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1402   	{
;;;1403   		uint16_t temp;
;;;1404   		
;;;1405   		temp = _usX;
;;;1406   		_usX = _usY;
;;;1407   		_usY = temp;
;;;1408   		
;;;1409   		temp = _usHeight;
;;;1410   		_usHeight = _usWidth;
;;;1411   		_usWidth = temp;
;;;1412   	}
;;;1413   	
;;;1414   	/* 设置起点坐标 */
;;;1415   	RA8875_WriteReg(0x91, _usX);
;;;1416   	RA8875_WriteReg(0x92, _usX >> 8);
;;;1417   	RA8875_WriteReg(0x93, _usY);
;;;1418   	RA8875_WriteReg(0x94, _usY >> 8);
;;;1419   
;;;1420   	/* 设置终点坐标 */
;;;1421   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
;;;1422   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
;;;1423   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
;;;1424   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
;;;1425   
;;;1426   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1427   
;;;1428   	s_ucRA8875BusyNow = 1;
;;;1429   //	RA8875_WriteReg(0x90, (1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));	/* 开始填充矩形  */
;;;1430   	RA8875_WriteCmd(0x90);
;;;1431   	RA8875_WriteData((1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));
;;;1432   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1433   	RA8875_WaitBusy();
;;;1434   	s_ucRA8875BusyNow = 0;
;;;1435   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L20.24|
000018  4823              LDR      r0,|L20.168|
00001a  7800              LDRB     r0,[r0,#0]            ;1401  ; g_LcdDirection
00001c  2801              CMP      r0,#1                 ;1401
00001e  dd06              BLE      |L20.46|
000020  4620              MOV      r0,r4                 ;1405
000022  462c              MOV      r4,r5                 ;1406
000024  4605              MOV      r5,r0                 ;1407
000026  4630              MOV      r0,r6                 ;1409
000028  463e              MOV      r6,r7                 ;1410
00002a  4607              MOV      r7,r0                 ;1411
00002c  bf00              NOP                            ;1412
                  |L20.46|
00002e  b2e1              UXTB     r1,r4                 ;1415
000030  2091              MOVS     r0,#0x91              ;1415
000032  f7fffffe          BL       RA8875_WriteReg
000036  1221              ASRS     r1,r4,#8              ;1416
000038  2092              MOVS     r0,#0x92              ;1416
00003a  f7fffffe          BL       RA8875_WriteReg
00003e  b2e9              UXTB     r1,r5                 ;1417
000040  2093              MOVS     r0,#0x93              ;1417
000042  f7fffffe          BL       RA8875_WriteReg
000046  1229              ASRS     r1,r5,#8              ;1418
000048  2094              MOVS     r0,#0x94              ;1418
00004a  f7fffffe          BL       RA8875_WriteReg
00004e  19e0              ADDS     r0,r4,r7              ;1421
000050  1e40              SUBS     r0,r0,#1              ;1421
000052  b2c1              UXTB     r1,r0                 ;1421
000054  2095              MOVS     r0,#0x95              ;1421
000056  f7fffffe          BL       RA8875_WriteReg
00005a  19e0              ADDS     r0,r4,r7              ;1422
00005c  1e40              SUBS     r0,r0,#1              ;1422
00005e  f3c02107          UBFX     r1,r0,#8,#8           ;1422
000062  2096              MOVS     r0,#0x96              ;1422
000064  f7fffffe          BL       RA8875_WriteReg
000068  19a8              ADDS     r0,r5,r6              ;1423
00006a  1e40              SUBS     r0,r0,#1              ;1423
00006c  b2c1              UXTB     r1,r0                 ;1423
00006e  2097              MOVS     r0,#0x97              ;1423
000070  f7fffffe          BL       RA8875_WriteReg
000074  19a8              ADDS     r0,r5,r6              ;1424
000076  1e40              SUBS     r0,r0,#1              ;1424
000078  f3c02107          UBFX     r1,r0,#8,#8           ;1424
00007c  2098              MOVS     r0,#0x98              ;1424
00007e  f7fffffe          BL       RA8875_WriteReg
000082  4640              MOV      r0,r8                 ;1426
000084  f7fffffe          BL       RA8875_SetFrontColor
000088  2001              MOVS     r0,#1                 ;1428
00008a  4908              LDR      r1,|L20.172|
00008c  7008              STRB     r0,[r1,#0]            ;1428
00008e  2090              MOVS     r0,#0x90              ;1430
000090  f7fffffe          BL       RA8875_WriteCmd
000094  20b0              MOVS     r0,#0xb0              ;1431
000096  f7fffffe          BL       RA8875_WriteData
00009a  f7fffffe          BL       RA8875_WaitBusy
00009e  2000              MOVS     r0,#0                 ;1434
0000a0  4902              LDR      r1,|L20.172|
0000a2  7008              STRB     r0,[r1,#0]            ;1434
0000a4  bf00              NOP      
0000a6  e7b5              B        |L20.20|
;;;1436   
                          ENDP

                  |L20.168|
                          DCD      g_LcdDirection
                  |L20.172|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_GetPixel||, CODE, READONLY, ALIGN=2

                  RA8875_GetPixel PROC
;;;982    */
;;;983    uint16_t RA8875_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;984    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;985    	uint16_t usRGB;
;;;986    
;;;987    //	RA8875_WriteReg(0x40, (1 << 0));	/* 设置为绘图模式，读取光标不自动加1 */
;;;988    
;;;989    	RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       RA8875_SetReadCursor
;;;990    
;;;991    	s_ucRA8875BusyNow = 1;
00000e  2001              MOVS     r0,#1
000010  4909              LDR      r1,|L21.56|
000012  7008              STRB     r0,[r1,#0]
;;;992    
;;;993    	RA8875_WriteCmd(0x02);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RA8875_WriteCmd
;;;994    	usRGB = RA8875_ReadData16();	/* 第1次读取数据丢弃 */
00001a  f7fffffe          BL       RA8875_ReadData16
00001e  4606              MOV      r6,r0
;;;995    	usRGB = RA8875_ReadData16();
000020  f7fffffe          BL       RA8875_ReadData16
000024  4606              MOV      r6,r0
;;;996    	usRGB = RA8875_ReadData16();
000026  f7fffffe          BL       RA8875_ReadData16
00002a  4606              MOV      r6,r0
;;;997    
;;;998    	s_ucRA8875BusyNow = 0;
00002c  2000              MOVS     r0,#0
00002e  4902              LDR      r1,|L21.56|
000030  7008              STRB     r0,[r1,#0]
;;;999    
;;;1000   	return usRGB;
000032  4630              MOV      r0,r6
;;;1001   }
000034  bd70              POP      {r4-r6,pc}
;;;1002   
                          ENDP

000036  0000              DCW      0x0000
                  |L21.56|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_InitHard||, CODE, READONLY, ALIGN=2

                  RA8875_InitHard PROC
;;;150    */
;;;151    void RA8875_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153    	uint8_t ucGPIX;
;;;154    	
;;;155    	RA8875_ConfigGPIO();	/* 配置GPIO FSMC等 */
000002  f7fffffe          BL       RA8875_ConfigGPIO
;;;156    
;;;157    	/* 读取 RA8875 芯片额GPIX引脚的电平状态；1表示4.3寸屏；0表示7寸屏
;;;158    	【备注】这是安富莱电子为了便于统一测试例程，在LCD模块上做的硬件标识。在做产品时，不必自动识别。
;;;159    	*/
;;;160    	ucGPIX = RA8875_ReadReg(0xC7);
000006  20c7              MOVS     r0,#0xc7
000008  f7fffffe          BL       RA8875_ReadReg
00000c  4604              MOV      r4,r0
;;;161    
;;;162    	if (ucGPIX == 1)	/* 	GPIX = 1 表示 4.3 寸屏 480x272 */
00000e  2c01              CMP      r4,#1
000010  d161              BNE      |L22.214|
;;;163    	{
;;;164    		/* 初始化PLL.  晶振频率为25M */
;;;165    		RA8875_WriteCmd(0x88);
000012  2088              MOVS     r0,#0x88
000014  f7fffffe          BL       RA8875_WriteCmd
;;;166    		RA8875_Delaly1us();		/* 延迟1us */
000018  f7fffffe          BL       RA8875_Delaly1us
;;;167    		RA8875_WriteData(10);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       RA8875_WriteData
;;;168    
;;;169    	    RA8875_Delaly1ms();
000022  f7fffffe          BL       RA8875_Delaly1ms
;;;170    
;;;171    		RA8875_WriteCmd(0x89);
000026  2089              MOVS     r0,#0x89
000028  f7fffffe          BL       RA8875_WriteCmd
;;;172    		RA8875_Delaly1us();		/* 延迟1us */
00002c  f7fffffe          BL       RA8875_Delaly1us
;;;173    		RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       RA8875_WriteData
;;;174    
;;;175    		/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;176    		  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;177    		          = 25M * (10 + 1) / ((0 + 1) * (2 ^ 2))
;;;178    				  = 68.75MHz
;;;179    		*/
;;;180    
;;;181    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;182    	    RA8875_Delaly1ms();
000036  f7fffffe          BL       RA8875_Delaly1ms
;;;183    		RA8875_Delaly1ms();
00003a  f7fffffe          BL       RA8875_Delaly1ms
;;;184    
;;;185    		/*
;;;186    			配置系统控制寄存器。 中文pdf 第18页:
;;;187    
;;;188    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;189    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;190    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;191    
;;;192    			bit1:0 MCUIF 选择
;;;193    				00b : 8-位MCU 接口。
;;;194    				1xb : 16-位MCU 接口。 【选这个】
;;;195    		*/
;;;196    		if (g_RA8875_IF == RA_HARD_8080_16)
00003e  4868              LDR      r0,|L22.480|
000040  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000042  2803              CMP      r0,#3
000044  d104              BNE      |L22.80|
;;;197    		{
;;;198    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
000046  210a              MOVS     r1,#0xa
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       RA8875_WriteReg
00004e  e003              B        |L22.88|
                  |L22.80|
;;;199    		}
;;;200    		else
;;;201    		{
;;;202    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
000050  2108              MOVS     r1,#8
000052  2010              MOVS     r0,#0x10
000054  f7fffffe          BL       RA8875_WriteReg
                  |L22.88|
;;;203    		}
;;;204    
;;;205    		/* REG[04h] Pixel Clock Setting Register   PCSR
;;;206    			bit7  PCLK Inversion
;;;207    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;208    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;209    			bit1:0 PCLK 频率周期设定
;;;210    				Pixel Clock  PCLK 频率周期设定。
;;;211    				00b: PCLK 频率周期= 系统频率周期。
;;;212    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;213    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;214    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;215    		*/
;;;216    	    RA8875_WriteReg(0x04, 0x82);    /* 设置PCLK反相 */
000058  2182              MOVS     r1,#0x82
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       RA8875_WriteReg
;;;217    	    RA8875_Delaly1ms();
000060  f7fffffe          BL       RA8875_Delaly1ms
;;;218    
;;;219    	    //Horizontal set
;;;220    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;221    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;222    	    RA8875_WriteReg(0x14, 0x3B);
000064  213b              MOVS     r1,#0x3b
000066  2014              MOVS     r0,#0x14
000068  f7fffffe          BL       RA8875_WriteReg
;;;223    	    RA8875_WriteReg(0x15, 0x00);
00006c  2100              MOVS     r1,#0
00006e  2015              MOVS     r0,#0x15
000070  f7fffffe          BL       RA8875_WriteReg
;;;224    
;;;225    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;226    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;227    		RA8875_WriteReg(0x16, 0x01);
000074  2101              MOVS     r1,#1
000076  2016              MOVS     r0,#0x16
000078  f7fffffe          BL       RA8875_WriteReg
;;;228    
;;;229    	    //HSTR//HSYNC Start Position[4:0]
;;;230    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;231    		RA8875_WriteReg(0x17, 0x00);
00007c  2100              MOVS     r1,#0
00007e  2017              MOVS     r0,#0x17
000080  f7fffffe          BL       RA8875_WriteReg
;;;232    
;;;233    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;234    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;235    		RA8875_WriteReg(0x18, 0x05);
000084  2105              MOVS     r1,#5
000086  2018              MOVS     r0,#0x18
000088  f7fffffe          BL       RA8875_WriteReg
;;;236    
;;;237    	    //Vertical set
;;;238    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;239    	    //Vertical pixels = VDHR + 1
;;;240    		RA8875_WriteReg(0x19, 0x0F);
00008c  210f              MOVS     r1,#0xf
00008e  2019              MOVS     r0,#0x19
000090  f7fffffe          BL       RA8875_WriteReg
;;;241    
;;;242    	    //VDHR1 //Vertical Display Height Bit [8]
;;;243    	    //Vertical pixels = VDHR + 1
;;;244    		RA8875_WriteReg(0x1A, 0x01);
000094  2101              MOVS     r1,#1
000096  201a              MOVS     r0,#0x1a
000098  f7fffffe          BL       RA8875_WriteReg
;;;245    
;;;246    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;247    	    //Vertical Non-Display area = (VNDR + 1)
;;;248    		RA8875_WriteReg(0x1B, 0x02);
00009c  2102              MOVS     r1,#2
00009e  201b              MOVS     r0,#0x1b
0000a0  f7fffffe          BL       RA8875_WriteReg
;;;249    
;;;250    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;251    	    //Vertical Non-Display area = (VNDR + 1)
;;;252    		RA8875_WriteReg(0x1C, 0x00);
0000a4  2100              MOVS     r1,#0
0000a6  201c              MOVS     r0,#0x1c
0000a8  f7fffffe          BL       RA8875_WriteReg
;;;253    
;;;254    	    //VSTR0 //VSYNC Start Position[7:0]
;;;255    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;256    		RA8875_WriteReg(0x1D, 0x07);
0000ac  2107              MOVS     r1,#7
0000ae  201d              MOVS     r0,#0x1d
0000b0  f7fffffe          BL       RA8875_WriteReg
;;;257    
;;;258    	    //VSTR1 //VSYNC Start Position[8]
;;;259    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;260    		RA8875_WriteReg(0x1E, 0x00);
0000b4  2100              MOVS     r1,#0
0000b6  201e              MOVS     r0,#0x1e
0000b8  f7fffffe          BL       RA8875_WriteReg
;;;261    
;;;262    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;263    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;264    	    RA8875_WriteReg(0x1F, 0x09);
0000bc  2109              MOVS     r1,#9
0000be  201f              MOVS     r0,#0x1f
0000c0  f7fffffe          BL       RA8875_WriteReg
;;;265    
;;;266    
;;;267    	    g_LcdHeight = LCD_43_HEIGHT;
0000c4  f44f7088          MOV      r0,#0x110
0000c8  4946              LDR      r1,|L22.484|
0000ca  8008              STRH     r0,[r1,#0]
;;;268    		g_LcdWidth = LCD_43_WIDTH;
0000cc  f44f70f0          MOV      r0,#0x1e0
0000d0  4945              LDR      r1,|L22.488|
0000d2  8008              STRH     r0,[r1,#0]
0000d4  e05e              B        |L22.404|
                  |L22.214|
;;;269    	}
;;;270    	else	/* GPIX = 0 表示7寸屏(800x480) */
;;;271    	{
;;;272    	    g_LcdHeight = LCD_70_HEIGHT;
0000d6  f44f70f0          MOV      r0,#0x1e0
0000da  4942              LDR      r1,|L22.484|
0000dc  8008              STRH     r0,[r1,#0]
;;;273    		g_LcdWidth = LCD_70_WIDTH;
0000de  f44f7048          MOV      r0,#0x320
0000e2  4941              LDR      r1,|L22.488|
0000e4  8008              STRH     r0,[r1,#0]
;;;274    
;;;275    		#if 0	/* 75MHz */
;;;276    			RA8875_WriteCmd(0x88);
;;;277    			RA8875_Delaly1us();		/* 延迟1us */
;;;278    			RA8875_WriteData(11);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 11 */
;;;279    
;;;280    			RA8875_Delaly1ms();
;;;281    
;;;282    			RA8875_WriteCmd(0x89);
;;;283    			RA8875_Delaly1us();		/* 延迟1us */
;;;284    			RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
;;;285    		#else	/* 81.25M */
;;;286    			/* 初始化PLL.  晶振频率为25M */
;;;287    			RA8875_WriteCmd(0x88);
0000e6  2088              MOVS     r0,#0x88
0000e8  f7fffffe          BL       RA8875_WriteCmd
;;;288    			RA8875_Delaly1us();		/* 延迟1us */
0000ec  f7fffffe          BL       RA8875_Delaly1us
;;;289    			RA8875_WriteData(12);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 12 */
0000f0  200c              MOVS     r0,#0xc
0000f2  f7fffffe          BL       RA8875_WriteData
;;;290    
;;;291    			RA8875_Delaly1ms();
0000f6  f7fffffe          BL       RA8875_Delaly1ms
;;;292    
;;;293    			RA8875_WriteCmd(0x89);
0000fa  2089              MOVS     r0,#0x89
0000fc  f7fffffe          BL       RA8875_WriteCmd
;;;294    			RA8875_Delaly1us();		/* 延迟1us */
000100  f7fffffe          BL       RA8875_Delaly1us
;;;295    			RA8875_WriteData(2);	/* PLLDIVK[2:0] = 2, 除以4 */
000104  2002              MOVS     r0,#2
000106  f7fffffe          BL       RA8875_WriteData
;;;296    
;;;297    			/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;298    			  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;299    					  = 25M * (12 + 1) / ((0 + 1) * (2 ^ 2))
;;;300    					  = 81.25MHz
;;;301    			*/
;;;302    		#endif
;;;303    		
;;;304    
;;;305    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;306    	    RA8875_Delaly1ms();
00010a  f7fffffe          BL       RA8875_Delaly1ms
;;;307    
;;;308    		/*
;;;309    			配置系统控制寄存器。 中文pdf 第18页:
;;;310    
;;;311    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;312    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;313    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;314    
;;;315    			bit1:0 MCUIF 选择
;;;316    				00b : 8-位MCU 接口。
;;;317    				1xb : 16-位MCU 接口。 【选这个】
;;;318    		*/
;;;319    		if (g_RA8875_IF == RA_HARD_8080_16)
00010e  4834              LDR      r0,|L22.480|
000110  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000112  2803              CMP      r0,#3
000114  d104              BNE      |L22.288|
;;;320    		{
;;;321    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
000116  210a              MOVS     r1,#0xa
000118  2010              MOVS     r0,#0x10
00011a  f7fffffe          BL       RA8875_WriteReg
00011e  e003              B        |L22.296|
                  |L22.288|
;;;322    		}
;;;323    		else
;;;324    		{
;;;325    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
000120  2108              MOVS     r1,#8
000122  2010              MOVS     r0,#0x10
000124  f7fffffe          BL       RA8875_WriteReg
                  |L22.296|
;;;326    		}
;;;327    
;;;328    		/* REG[04h] Pixel Clock Setting Register (PCSR)
;;;329    			bit7  PCLK Inversion
;;;330    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;331    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;332    			bit1:0 PCLK 频率周期设定
;;;333    				Pixel Clock ,PCLK 频率周期设定。
;;;334    				00b: PCLK 频率周期= 系统频率周期。
;;;335    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;336    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;337    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;338    		*/
;;;339    	    RA8875_WriteReg(0x04, 0x81);
000128  2181              MOVS     r1,#0x81
00012a  2004              MOVS     r0,#4
00012c  f7fffffe          BL       RA8875_WriteReg
;;;340    	    RA8875_Delaly1ms();
000130  f7fffffe          BL       RA8875_Delaly1ms
;;;341    
;;;342    	#if 1
;;;343    		/* OTD9960 & OTA7001 设置 */
;;;344    		RA8875_WriteReg(0x14, 0x63);
000134  2163              MOVS     r1,#0x63
000136  2014              MOVS     r0,#0x14
000138  f7fffffe          BL       RA8875_WriteReg
;;;345    		RA8875_WriteReg(0x15, 0x00);
00013c  2100              MOVS     r1,#0
00013e  2015              MOVS     r0,#0x15
000140  f7fffffe          BL       RA8875_WriteReg
;;;346    		RA8875_WriteReg(0x16, 0x03);
000144  2103              MOVS     r1,#3
000146  2016              MOVS     r0,#0x16
000148  f7fffffe          BL       RA8875_WriteReg
;;;347    		RA8875_WriteReg(0x17, 0x03);
00014c  2103              MOVS     r1,#3
00014e  2017              MOVS     r0,#0x17
000150  f7fffffe          BL       RA8875_WriteReg
;;;348    		RA8875_WriteReg(0x18, 0x0B);
000154  210b              MOVS     r1,#0xb
000156  2018              MOVS     r0,#0x18
000158  f7fffffe          BL       RA8875_WriteReg
;;;349    		RA8875_WriteReg(0x19, 0xDF);
00015c  21df              MOVS     r1,#0xdf
00015e  2019              MOVS     r0,#0x19
000160  f7fffffe          BL       RA8875_WriteReg
;;;350    		RA8875_WriteReg(0x1A, 0x01);
000164  2101              MOVS     r1,#1
000166  201a              MOVS     r0,#0x1a
000168  f7fffffe          BL       RA8875_WriteReg
;;;351    		RA8875_WriteReg(0x1B, 0x1F);
00016c  211f              MOVS     r1,#0x1f
00016e  201b              MOVS     r0,#0x1b
000170  f7fffffe          BL       RA8875_WriteReg
;;;352    		RA8875_WriteReg(0x1C, 0x00);
000174  2100              MOVS     r1,#0
000176  201c              MOVS     r0,#0x1c
000178  f7fffffe          BL       RA8875_WriteReg
;;;353    		RA8875_WriteReg(0x1D, 0x16);
00017c  2116              MOVS     r1,#0x16
00017e  201d              MOVS     r0,#0x1d
000180  f7fffffe          BL       RA8875_WriteReg
;;;354    		RA8875_WriteReg(0x1E, 0x00);
000184  2100              MOVS     r1,#0
000186  201e              MOVS     r0,#0x1e
000188  f7fffffe          BL       RA8875_WriteReg
;;;355    		RA8875_WriteReg(0x1F, 0x01);
00018c  2101              MOVS     r1,#1
00018e  201f              MOVS     r0,#0x1f
000190  f7fffffe          BL       RA8875_WriteReg
                  |L22.404|
;;;356    
;;;357    	#else	/* AT070TN92  setting */
;;;358    	    //Horizontal set
;;;359    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;360    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;361    	    RA8875_WriteReg(0x14, 0x4F);
;;;362    	    RA8875_WriteReg(0x15, 0x05);
;;;363    
;;;364    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;365    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;366    		RA8875_WriteReg(0x16, 0x0F);
;;;367    
;;;368    	    //HSTR//HSYNC Start Position[4:0]
;;;369    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;370    		RA8875_WriteReg(0x17, 0x01);
;;;371    
;;;372    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;373    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;374    		RA8875_WriteReg(0x18, 0x00);
;;;375    
;;;376    	    //Vertical set
;;;377    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;378    	    //Vertical pixels = VDHR + 1
;;;379    		RA8875_WriteReg(0x19, 0xDF);
;;;380    
;;;381    	    //VDHR1 //Vertical Display Height Bit [8]
;;;382    	    //Vertical pixels = VDHR + 1
;;;383    		RA8875_WriteReg(0x1A, 0x01);
;;;384    
;;;385    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;386    	    //Vertical Non-Display area = (VNDR + 1)
;;;387    		RA8875_WriteReg(0x1B, 0x0A);
;;;388    
;;;389    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;390    	    //Vertical Non-Display area = (VNDR + 1)
;;;391    		RA8875_WriteReg(0x1C, 0x00);
;;;392    
;;;393    	    //VSTR0 //VSYNC Start Position[7:0]
;;;394    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;395    		RA8875_WriteReg(0x1D, 0x0E);
;;;396    
;;;397    	    //VSTR1 //VSYNC Start Position[8]
;;;398    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;399    		RA8875_WriteReg(0x1E, 0x00);
;;;400    
;;;401    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;402    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;403    	    RA8875_WriteReg(0x1F, 0x01);
;;;404    	#endif
;;;405    	}
;;;406    
;;;407    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;408    	RA8875_WriteReg(0xC7, 0x01);	/* DISP = 1 */
000194  2101              MOVS     r1,#1
000196  20c7              MOVS     r0,#0xc7
000198  f7fffffe          BL       RA8875_WriteReg
;;;409    
;;;410    	/* LCD 显示/关闭讯号 (LCD Display on) */
;;;411    	RA8875_WriteReg(0x01, 0x80);
00019c  2180              MOVS     r1,#0x80
00019e  2001              MOVS     r0,#1
0001a0  f7fffffe          BL       RA8875_WriteReg
;;;412    
;;;413    	/* 	REG[40h] Memory Write Control Register 0 (MWCR0)
;;;414    
;;;415    		Bit 7	显示模式设定
;;;416    			0 : 绘图模式。
;;;417    			1 : 文字模式。
;;;418    
;;;419    		Bit 6	文字写入光标/内存写入光标设定
;;;420    			0 : 设定文字/内存写入光标为不显示。
;;;421    			1 : 设定文字/内存写入光标为显示。
;;;422    
;;;423    		Bit 5	文字写入光标/内存写入光标闪烁设定
;;;424    			0 : 游标不闪烁。
;;;425    			1 : 游标闪烁。
;;;426    
;;;427    		Bit 4   NA
;;;428    
;;;429    		Bit 3-2  绘图模式时的内存写入方向
;;;430    			00b : 左 -> 右，然后上 -> 下。
;;;431    			01b : 右 -> 左，然后上 -> 下。
;;;432    			10b : 上 -> 下，然后左 -> 右。
;;;433    			11b : 下 -> 上，然后左 -> 右。
;;;434    
;;;435    		Bit 1 	内存写入光标自动增加功能设定
;;;436    			0 : 当内存写入时光标位置自动加一。
;;;437    			1 : 当内存写入时光标位置不会自动加一。
;;;438    
;;;439    		Bit 0 内存读取光标自动增加功能设定
;;;440    			0 : 当内存读取时光标位置自动加一。
;;;441    			1 : 当内存读取时光标位置不会自动加一。
;;;442    	*/
;;;443    	//RA8875_WriteReg(0x40, 0x00);	/* 选择绘图模式 */	
;;;444    	RA8875_SetDirection(0);
0001a4  2000              MOVS     r0,#0
0001a6  f7fffffe          BL       RA8875_SetDirection
;;;445    
;;;446    	/* 	REG[41h] Memory Write Control Register1 (MWCR1)
;;;447    		写入目的位置，选择图层1
;;;448    	*/
;;;449    	RA8875_WriteReg(0x41, 0x00);	/* 选择绘图模式, 目的为CGRAM */
0001aa  2100              MOVS     r1,#0
0001ac  2041              MOVS     r0,#0x41
0001ae  f7fffffe          BL       RA8875_WriteReg
;;;450    
;;;451    	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
0001b2  480d              LDR      r0,|L22.488|
0001b4  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
0001b6  480b              LDR      r0,|L22.484|
0001b8  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
0001ba  2100              MOVS     r1,#0
0001bc  4608              MOV      r0,r1
0001be  f7fffffe          BL       RA8875_SetDispWin
;;;452    
;;;453    	if ((g_RA8875_IF == RA_HARD_SPI) || (g_RA8875_IF == RA_SOFT_SPI))
0001c2  4807              LDR      r0,|L22.480|
0001c4  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
0001c6  2802              CMP      r0,#2
0001c8  d003              BEQ      |L22.466|
0001ca  4805              LDR      r0,|L22.480|
0001cc  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
0001ce  2801              CMP      r0,#1
0001d0  d102              BNE      |L22.472|
                  |L22.466|
;;;454    	{
;;;455    		RA8875_HighSpeedSPI();		/* 配置完毕后，切换SPI到高速模式 */
0001d2  f7fffffe          BL       RA8875_HighSpeedSPI
0001d6  e001              B        |L22.476|
                  |L22.472|
;;;456    	}
;;;457    	else
;;;458    	{
;;;459    		#ifdef WRTIE_SF_EN		/* 使能了字库图片芯片写功能，配置CPU的SPI接口和PWM-GPIO */
;;;460    			bsp_InitRA8875Flash();		
0001d8  f7fffffe          BL       bsp_InitRA8875Flash
                  |L22.476|
;;;461    		#endif	
;;;462    	}
;;;463    }
0001dc  bd10              POP      {r4,pc}
;;;464    
                          ENDP

0001de  0000              DCW      0x0000
                  |L22.480|
                          DCD      g_RA8875_IF
                  |L22.484|
                          DCD      g_LcdHeight
                  |L22.488|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_IsBusy||, CODE, READONLY, ALIGN=2

                  RA8875_IsBusy PROC
;;;661    */
;;;662    uint8_t RA8875_IsBusy(void)
000000  4803              LDR      r0,|L23.16|
;;;663    {
;;;664    	if (s_ucRA8875BusyNow == 0)
000002  7800              LDRB     r0,[r0,#0]  ; s_ucRA8875BusyNow
000004  b908              CBNZ     r0,|L23.10|
;;;665    	{
;;;666    		return 0;
000006  2000              MOVS     r0,#0
                  |L23.8|
;;;667    	}
;;;668    	return 1;
;;;669    }
000008  4770              BX       lr
                  |L23.10|
00000a  2001              MOVS     r0,#1                 ;668
00000c  e7fc              B        |L23.8|
;;;670    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_Layer1Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer1Visable PROC
;;;691    */
;;;692    void RA8875_Layer1Visable(void)
000000  b510              PUSH     {r4,lr}
;;;693    {
;;;694    	/* 0x52 寄存器的 Bit2:0
;;;695    		图层显示模式
;;;696    		000b : 只有图层1 显示。
;;;697    		001b : 只有图层2 显示。
;;;698    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;699    		011b : 显示图层1 与图层2 的通透模式。
;;;700    		100b : Boolean OR。
;;;701    		101b : Boolean AND。
;;;702    		110b : 浮动窗口模式 (Floating window mode)。
;;;703    		111b :保留。
;;;704    	*/
;;;705    	RA8875_WriteReg(0x52, RA8875_ReadReg(0x52) & 0xF8);	/* 只有图层1 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00004f8          AND      r4,r0,#0xf8
00000c  4621              MOV      r1,r4
00000e  2052              MOVS     r0,#0x52
000010  f7fffffe          BL       RA8875_WriteReg
;;;706    }
000014  bd10              POP      {r4,pc}
;;;707    
                          ENDP


                          AREA ||i.RA8875_Layer2Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer2Visable PROC
;;;715    */
;;;716    void RA8875_Layer2Visable(void)
000000  b510              PUSH     {r4,lr}
;;;717    {
;;;718    	/* 0x52 寄存器的 Bit2:0
;;;719    		图层显示模式
;;;720    		000b : 只有图层1 显示。
;;;721    		001b : 只有图层2 显示。
;;;722    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;723    		011b : 显示图层1 与图层2 的通透模式。
;;;724    		100b : Boolean OR。
;;;725    		101b : Boolean AND。
;;;726    		110b : 浮动窗口模式 (Floating window mode)。
;;;727    		111b :保留。
;;;728    	*/
;;;729    	RA8875_WriteReg(0x52, (RA8875_ReadReg(0x52) & 0xF8) | 0x01);	/* 只有图层2 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00000f8          AND      r0,r0,#0xf8
00000c  1c44              ADDS     r4,r0,#1
00000e  4621              MOV      r1,r4
000010  2052              MOVS     r0,#0x52
000012  f7fffffe          BL       RA8875_WriteReg
;;;730    }
000016  bd10              POP      {r4,pc}
;;;731    
                          ENDP


                          AREA ||i.RA8875_PutPixel||, CODE, READONLY, ALIGN=2

                  RA8875_PutPixel PROC
;;;929    */
;;;930    void RA8875_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {	
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;932    	if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000008  482b              LDR      r0,|L26.184|
00000a  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
00000c  2803              CMP      r0,#3
00000e  d141              BNE      |L26.148|
;;;933    	{
;;;934    		// 优化 RA8875_SetCursor(_usX, _usY);
;;;935    		s_ucRA8875BusyNow = 1;
000010  2001              MOVS     r0,#1
000012  492a              LDR      r1,|L26.188|
000014  7008              STRB     r0,[r1,#0]
;;;936    		{	
;;;937    			if (g_LcdDirection > 1)	/* 竖屏  */
000016  482a              LDR      r0,|L26.192|
000018  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00001a  2801              CMP      r0,#1
00001c  dd18              BLE      |L26.80|
;;;938    			{
;;;939    				RA8875_REG = 0x46; RA8875_RAM = _usY;
00001e  2046              MOVS     r0,#0x46
000020  4928              LDR      r1,|L26.196|
000022  8008              STRH     r0,[r1,#0]
000024  f04f40d8          MOV      r0,#0x6c000000
000028  8005              STRH     r5,[r0,#0]
;;;940    				RA8875_REG = 0x47; RA8875_RAM = _usY >> 8;
00002a  2047              MOVS     r0,#0x47
00002c  8008              STRH     r0,[r1,#0]
00002e  1228              ASRS     r0,r5,#8
000030  f04f41d8          MOV      r1,#0x6c000000
000034  8008              STRH     r0,[r1,#0]
;;;941    				RA8875_REG = 0x48; RA8875_RAM = _usX;
000036  2048              MOVS     r0,#0x48
000038  4922              LDR      r1,|L26.196|
00003a  8008              STRH     r0,[r1,#0]
00003c  f04f40d8          MOV      r0,#0x6c000000
000040  8004              STRH     r4,[r0,#0]
;;;942    				RA8875_REG = 0x49; RA8875_RAM = _usX >> 8;
000042  2049              MOVS     r0,#0x49
000044  8008              STRH     r0,[r1,#0]
000046  1220              ASRS     r0,r4,#8
000048  f04f41d8          MOV      r1,#0x6c000000
00004c  8008              STRH     r0,[r1,#0]
00004e  e017              B        |L26.128|
                  |L26.80|
;;;943    			}
;;;944    			else	/* 横屏 */
;;;945    			{
;;;946    				RA8875_REG = 0x46; RA8875_RAM = _usX;
000050  2046              MOVS     r0,#0x46
000052  491c              LDR      r1,|L26.196|
000054  8008              STRH     r0,[r1,#0]
000056  f04f40d8          MOV      r0,#0x6c000000
00005a  8004              STRH     r4,[r0,#0]
;;;947    				RA8875_REG = 0x47; RA8875_RAM = _usX >> 8;
00005c  2047              MOVS     r0,#0x47
00005e  8008              STRH     r0,[r1,#0]
000060  1220              ASRS     r0,r4,#8
000062  f04f41d8          MOV      r1,#0x6c000000
000066  8008              STRH     r0,[r1,#0]
;;;948    				RA8875_REG = 0x48; RA8875_RAM = _usY;
000068  2048              MOVS     r0,#0x48
00006a  4916              LDR      r1,|L26.196|
00006c  8008              STRH     r0,[r1,#0]
00006e  f04f40d8          MOV      r0,#0x6c000000
000072  8005              STRH     r5,[r0,#0]
;;;949    				RA8875_REG = 0x49; RA8875_RAM = _usY >> 8;	
000074  2049              MOVS     r0,#0x49
000076  8008              STRH     r0,[r1,#0]
000078  1228              ASRS     r0,r5,#8
00007a  f04f41d8          MOV      r1,#0x6c000000
00007e  8008              STRH     r0,[r1,#0]
                  |L26.128|
;;;950    			}
;;;951    		}
;;;952    		
;;;953    		// 优化 RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
;;;954    		// 优化 RA8875_WriteData16(_usColor);
;;;955    		
;;;956    		RA8875_REG = 0x02;
000080  2002              MOVS     r0,#2
000082  4910              LDR      r1,|L26.196|
000084  8008              STRH     r0,[r1,#0]
;;;957    		RA8875_RAM = _usColor;
000086  f04f40d8          MOV      r0,#0x6c000000
00008a  8006              STRH     r6,[r0,#0]
;;;958    
;;;959    		s_ucRA8875BusyNow = 0;
00008c  2000              MOVS     r0,#0
00008e  490b              LDR      r1,|L26.188|
000090  7008              STRB     r0,[r1,#0]
000092  e00f              B        |L26.180|
                  |L26.148|
;;;960    	}
;;;961    	else	/* SPI接口分支 */
;;;962    	{
;;;963    		RA8875_SetCursor(_usX, _usY);
000094  4629              MOV      r1,r5
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       RA8875_SetCursor
;;;964    		s_ucRA8875BusyNow = 1;
00009c  2001              MOVS     r0,#1
00009e  4907              LDR      r1,|L26.188|
0000a0  7008              STRB     r0,[r1,#0]
;;;965    
;;;966    		RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       RA8875_WriteCmd
;;;967    		RA8875_WriteData16(_usColor);
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       RA8875_WriteData16
;;;968    
;;;969    		s_ucRA8875BusyNow = 0;
0000ae  2000              MOVS     r0,#0
0000b0  4902              LDR      r1,|L26.188|
0000b2  7008              STRB     r0,[r1,#0]
                  |L26.180|
;;;970    	}
;;;971    }
0000b4  bd70              POP      {r4-r6,pc}
;;;972    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L26.184|
                          DCD      g_RA8875_IF
                  |L26.188|
                          DCD      s_ucRA8875BusyNow
                  |L26.192|
                          DCD      g_LcdDirection
                  |L26.196|
                          DCD      0x6c080000

                          AREA ||i.RA8875_QuitDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_QuitDirectDraw PROC
;;;1231   */
;;;1232   void RA8875_QuitDirectDraw(void)
000000  b510              PUSH     {r4,lr}
;;;1233   {
;;;1234   	s_ucRA8875BusyNow = 0;
000002  2000              MOVS     r0,#0
000004  4902              LDR      r1,|L27.16|
000006  7008              STRB     r0,[r1,#0]
;;;1235   
;;;1236   	/* 退出窗口绘图模式 */
;;;1237   	RA8875_QuitWinMode();
000008  f7fffffe          BL       RA8875_QuitWinMode
;;;1238   }
00000c  bd10              POP      {r4,pc}
;;;1239   
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_QuitWinMode||, CODE, READONLY, ALIGN=2

                  RA8875_QuitWinMode PROC
;;;1922   */
;;;1923   void RA8875_QuitWinMode(void)
000000  b510              PUSH     {r4,lr}
;;;1924   {
;;;1925   	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
000002  4804              LDR      r0,|L28.20|
000004  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
000006  4804              LDR      r0,|L28.24|
000008  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RA8875_SetDispWin
;;;1926   }
000012  bd10              POP      {r4,pc}
;;;1927   
                          ENDP

                  |L28.20|
                          DCD      g_LcdWidth
                  |L28.24|
                          DCD      g_LcdHeight

                          AREA ||i.RA8875_ReadID||, CODE, READONLY, ALIGN=1

                  RA8875_ReadID PROC
;;;80     */
;;;81     uint16_t RA8875_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	RA8875_ConfigGPIO();
000002  f7fffffe          BL       RA8875_ConfigGPIO
;;;84     	
;;;85     	return RA8875_ReadReg(0x00);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       RA8875_ReadReg
;;;86     }
00000c  bd10              POP      {r4,pc}
;;;87     
                          ENDP


                          AREA ||i.RA8875_ReadReg||, CODE, READONLY, ALIGN=2

                  RA8875_ReadReg PROC
;;;113    */
;;;114    uint8_t RA8875_ReadReg(uint8_t _ucRegAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4604              MOV      r4,r0
;;;116    	uint8_t value;
;;;117    	
;;;118    	s_ucRA8875BusyNow = 1;
000004  2001              MOVS     r0,#1
000006  4906              LDR      r1,|L30.32|
000008  7008              STRB     r0,[r1,#0]
;;;119    	
;;;120    	RA8875_WriteCmd(_ucRegAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RA8875_WriteCmd
;;;121    	value = RA8875_ReadData();
000010  f7fffffe          BL       RA8875_ReadData
000014  4605              MOV      r5,r0
;;;122    	
;;;123    	s_ucRA8875BusyNow = 0;
000016  2000              MOVS     r0,#0
000018  4901              LDR      r1,|L30.32|
00001a  7008              STRB     r0,[r1,#0]
;;;124    	return value;	
00001c  4628              MOV      r0,r5
;;;125    }
00001e  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP

                  |L30.32|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_ReadReg_Int||, CODE, READONLY, ALIGN=2

                  RA8875_ReadReg_Int PROC
;;;134    */
;;;135    uint8_t RA8875_ReadReg_Int(uint8_t _ucRegAddr)
000000  b510              PUSH     {r4,lr}
;;;136    {
000002  4604              MOV      r4,r0
;;;137    	s_ucRA8875BusyNow = 1;
000004  2001              MOVS     r0,#1
000006  4905              LDR      r1,|L31.28|
000008  7008              STRB     r0,[r1,#0]
;;;138    	RA8875_WriteCmd(_ucRegAddr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RA8875_WriteCmd
;;;139    	s_ucRA8875BusyNow = 0;
000010  2000              MOVS     r0,#0
000012  4902              LDR      r1,|L31.28|
000014  7008              STRB     r0,[r1,#0]
;;;140    	return RA8875_ReadData();
000016  f7fffffe          BL       RA8875_ReadData
;;;141    }
00001a  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L31.28|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_SetBackColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackColor PROC
;;;615    */
;;;616    void RA8875_SetBackColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618    	RA8875_WriteReg(0x60, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ae1              LSRS     r1,r4,#11
000006  2060              MOVS     r0,#0x60
000008  f7fffffe          BL       RA8875_WriteReg
;;;619    	RA8875_WriteReg(0x61, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2061              MOVS     r0,#0x61
000012  f7fffffe          BL       RA8875_WriteReg
;;;620    	RA8875_WriteReg(0x62, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  2062              MOVS     r0,#0x62
00001c  f7fffffe          BL       RA8875_WriteReg
;;;621    }
000020  bd10              POP      {r4,pc}
;;;622    
                          ENDP


                          AREA ||i.RA8875_SetBackLight||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackLight PROC
;;;1950   */
;;;1951   void RA8875_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1952   {
000002  4604              MOV      r4,r0
;;;1953   	if (_bright == 0)
000004  b924              CBNZ     r4,|L33.16|
;;;1954   	{
;;;1955   		/* 关闭PWM, PWM1引脚缺省输出LOW  */
;;;1956   		RA8875_WriteReg(0x8A, 0 << 6);
000006  2100              MOVS     r1,#0
000008  208a              MOVS     r0,#0x8a
00000a  f7fffffe          BL       RA8875_WriteReg
00000e  e00e              B        |L33.46|
                  |L33.16|
;;;1957   	}
;;;1958   	else if (_bright == BRIGHT_MAX)	/* 最大亮度 */
000010  2cff              CMP      r4,#0xff
000012  d104              BNE      |L33.30|
;;;1959   	{
;;;1960   		/* 关闭PWM, PWM1引脚缺省输出HIGH */
;;;1961   		RA8875_WriteReg(0x8A, 1 << 6);
000014  2140              MOVS     r1,#0x40
000016  208a              MOVS     r0,#0x8a
000018  f7fffffe          BL       RA8875_WriteReg
00001c  e007              B        |L33.46|
                  |L33.30|
;;;1962   	}
;;;1963   	else
;;;1964   	{
;;;1965   		/* 使能PWM1, 进行占空比调节 */
;;;1966   
;;;1967   		/* 	REG[8Ah] PWM1 Control Register (P1CR)
;;;1968   
;;;1969   			Bit7 脉波宽度调变 (PWM1) 设定
;;;1970   				0 : 关闭，此状态下，PWM1 输出准位依照此缓存器Bit6 决定。
;;;1971   				1 : 开启。
;;;1972   
;;;1973   			Bit6 PWM1 关闭时的准位
;;;1974   				0 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”Low” 状态。
;;;1975   				1 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”High” 状态。
;;;1976   
;;;1977   			Bit5 保留
;;;1978   
;;;1979   			Bit4 PWM1 功能选择
;;;1980   				0 : PWM1 功能。
;;;1981   				1 : PWM1 固定输出一频率为外部晶体振荡器Clock (Fin) 频率 1 /16 的Clock
;;;1982   
;;;1983   			Bit3-0  PWM1 电路的频率来源选择PWM_CLK	【不是PWM输出频率】
;;;1984   				0000b : SYS_CLK / 1   , 1000b : SYS_CLK / 256
;;;1985   				0001b : SYS_CLK / 2   , 1001b : SYS_CLK / 512
;;;1986   				0010b : SYS_CLK / 4   , 1010b : SYS_CLK / 1024
;;;1987   				0011b : SYS_CLK / 8   , 1011b : SYS_CLK / 2048
;;;1988   				0100b : SYS_CLK / 16  , 1100b : SYS_CLK / 4096
;;;1989   				0101b : SYS_CLK / 32  , 1101b : SYS_CLK / 8192
;;;1990   				0110b : SYS_CLK / 64  , 1110b : SYS_CLK / 16384
;;;1991   				0111b : SYS_CLK / 128 , 1111b : SYS_CLK / 32768
;;;1992   
;;;1993   				“SYS_CLK” 代表系统频率， 例如SYS_CLK 为20MHz， 当Bit[3:0] =0001b 时，PWM1 频率来源为10MHz。
;;;1994   				实际输出的PWM频率还需要除以 256，支持8位的分辨率。
;;;1995   
;;;1996   				安富莱的4.3寸(480*272)模块，SYS_CLK =  68.75MHz
;;;1997   				安富莱的7.0寸(800*480)模块，SYS_CLK =  81.25MHz
;;;1998   
;;;1999   				为了避免音频噪声，PWM频率可以选择
;;;2000   				（1） 低频100Hz
;;;2001   				（2） 高于 20KHz
;;;2002   
;;;2003   				比如，Bit3-0为0011b时 SYS_CLK / 8，
;;;2004   					4.3寸 输出的PWM频率为 (68.75MHz / 8) / 256 = 33.56KHz
;;;2005   					7寸 输出的PWM频率为 (75 MHz / 8) / 256 = 36.62KHz
;;;2006   		*/
;;;2007   
;;;2008   		// 5寸和7寸新屏可以用 3 ，高频PWM, 4.3寸不行
;;;2009   		RA8875_WriteReg(0x8A, (1 << 7) | 3);   
00001e  2183              MOVS     r1,#0x83
000020  208a              MOVS     r0,#0x8a
000022  f7fffffe          BL       RA8875_WriteReg
;;;2010   		// RA8875_WriteReg(0x8A, (1 << 7) | 12);
;;;2011   
;;;2012   		/* REG[8Bh] PWM1 Duty Cycle Register (P1DCR) */
;;;2013   		RA8875_WriteReg(0x8B, _bright);
000026  4621              MOV      r1,r4
000028  208b              MOVS     r0,#0x8b
00002a  f7fffffe          BL       RA8875_WriteReg
                  |L33.46|
;;;2014   	}
;;;2015   }
00002e  bd10              POP      {r4,pc}
;;;2016   /*
                          ENDP


                          AREA ||i.RA8875_SetCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetCursor PROC
;;;1844   */
;;;1845   static void RA8875_SetCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1846   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1847   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  4813              LDR      r0,|L34.84|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd10              BLE      |L34.48|
;;;1848   	{
;;;1849   		RA8875_WriteReg(0x46, _usY);
00000e  b2e9              UXTB     r1,r5
000010  2046              MOVS     r0,#0x46
000012  f7fffffe          BL       RA8875_WriteReg
;;;1850   		RA8875_WriteReg(0x47, _usY >> 8);
000016  1229              ASRS     r1,r5,#8
000018  2047              MOVS     r0,#0x47
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1851   		RA8875_WriteReg(0x48, _usX);
00001e  b2e1              UXTB     r1,r4
000020  2048              MOVS     r0,#0x48
000022  f7fffffe          BL       RA8875_WriteReg
;;;1852   		RA8875_WriteReg(0x49, _usX >> 8);
000026  1221              ASRS     r1,r4,#8
000028  2049              MOVS     r0,#0x49
00002a  f7fffffe          BL       RA8875_WriteReg
00002e  e00f              B        |L34.80|
                  |L34.48|
;;;1853   	}
;;;1854   	else	/* 横屏 */
;;;1855   	{
;;;1856   		RA8875_WriteReg(0x46, _usX);
000030  b2e1              UXTB     r1,r4
000032  2046              MOVS     r0,#0x46
000034  f7fffffe          BL       RA8875_WriteReg
;;;1857   		RA8875_WriteReg(0x47, _usX >> 8);
000038  1221              ASRS     r1,r4,#8
00003a  2047              MOVS     r0,#0x47
00003c  f7fffffe          BL       RA8875_WriteReg
;;;1858   		RA8875_WriteReg(0x48, _usY);
000040  b2e9              UXTB     r1,r5
000042  2048              MOVS     r0,#0x48
000044  f7fffffe          BL       RA8875_WriteReg
;;;1859   		RA8875_WriteReg(0x49, _usY >> 8);
000048  1229              ASRS     r1,r5,#8
00004a  2049              MOVS     r0,#0x49
00004c  f7fffffe          BL       RA8875_WriteReg
                  |L34.80|
;;;1860   	}
;;;1861   }
000050  bd70              POP      {r4-r6,pc}
;;;1862   
                          ENDP

000052  0000              DCW      0x0000
                  |L34.84|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetDirection||, CODE, READONLY, ALIGN=2

                  RA8875_SetDirection PROC
;;;472    */
;;;473    void RA8875_SetDirection(uint8_t _ucDir)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4604              MOV      r4,r0
;;;475    	uint8_t reg20H = 0;
000004  2500              MOVS     r5,#0
;;;476    	
;;;477    	s_reg_40H = 0x01;
000006  2001              MOVS     r0,#1
000008  4921              LDR      r1,|L35.144|
00000a  7008              STRB     r0,[r1,#0]
;;;478    	
;;;479    	if (_ucDir == 0)
00000c  b90c              CBNZ     r4,|L35.18|
;;;480    	{
;;;481    		s_reg_40H = 0x01;
00000e  7008              STRB     r0,[r1,#0]
;;;482    		reg20H = (0 << 3) | (0 << 2);
000010  e013              B        |L35.58|
                  |L35.18|
;;;483    	}
;;;484    	else if (_ucDir == 1)
000012  2c01              CMP      r4,#1
000014  d104              BNE      |L35.32|
;;;485    	{
;;;486    		s_reg_40H = 0x05;
000016  2005              MOVS     r0,#5
000018  491d              LDR      r1,|L35.144|
00001a  7008              STRB     r0,[r1,#0]
;;;487    		reg20H = (1 << 3) | (1 << 2);
00001c  250c              MOVS     r5,#0xc
00001e  e00c              B        |L35.58|
                  |L35.32|
;;;488    	}
;;;489    	else if (_ucDir == 2)
000020  2c02              CMP      r4,#2
000022  d104              BNE      |L35.46|
;;;490    	{
;;;491    		s_reg_40H = 0x09;
000024  2009              MOVS     r0,#9
000026  491a              LDR      r1,|L35.144|
000028  7008              STRB     r0,[r1,#0]
;;;492    		reg20H = (0 << 3) | (1 << 2);
00002a  2504              MOVS     r5,#4
00002c  e005              B        |L35.58|
                  |L35.46|
;;;493    	}
;;;494    	else if (_ucDir == 3)
00002e  2c03              CMP      r4,#3
000030  d103              BNE      |L35.58|
;;;495    	{
;;;496    		s_reg_40H = 0x09;
000032  2009              MOVS     r0,#9
000034  4916              LDR      r1,|L35.144|
000036  7008              STRB     r0,[r1,#0]
;;;497    		reg20H = (1 << 3) | (0 << 2);
000038  2508              MOVS     r5,#8
                  |L35.58|
;;;498    	}
;;;499    	RA8875_WriteReg(0x40, s_reg_40H);	
00003a  4815              LDR      r0,|L35.144|
00003c  7801              LDRB     r1,[r0,#0]  ; s_reg_40H
00003e  2040              MOVS     r0,#0x40
000040  f7fffffe          BL       RA8875_WriteReg
;;;500    
;;;501    	/* 
;;;502    		REG[20h] Display Configuration Register (DPCR) 
;;;503    		Bit  说  明  初始值  Access
;;;504    		Bit7 
;;;505    			图层设定(Layer Control) 
;;;506    			0 : 单图层。
;;;507    			1 : 双图层。
;;;508    		Bit3  HDIR 水平扫描方向设定(n = SEG number) 
;;;509    			0 : 由SEG0 到SEG(n-1)。
;;;510    			1 : 由SEG(n-1) 到SEG0。
;;;511    		Bit2 VDIR 垂直扫描方向设定(n = COM number) 
;;;512    			0 : 由COM0 到COM(n-1)。
;;;513    			1 : 由COM(n-1) 到COM0。
;;;514    	*/
;;;515    	RA8875_WriteReg(0x20, reg20H);	
000044  4629              MOV      r1,r5
000046  2020              MOVS     r0,#0x20
000048  f7fffffe          BL       RA8875_WriteReg
;;;516    
;;;517    	if (_ucDir > 1)	/* 竖屏  */
00004c  2c01              CMP      r4,#1
00004e  dd0e              BLE      |L35.110|
;;;518    	{
;;;519    		uint16_t temp;
;;;520    		
;;;521    		if (g_LcdHeight < g_LcdWidth)
000050  4910              LDR      r1,|L35.148|
000052  8809              LDRH     r1,[r1,#0]  ; g_LcdHeight
000054  4a10              LDR      r2,|L35.152|
000056  8812              LDRH     r2,[r2,#0]  ; g_LcdWidth
000058  4291              CMP      r1,r2
00005a  da07              BGE      |L35.108|
;;;522    		{
;;;523    			temp = g_LcdHeight;
00005c  490d              LDR      r1,|L35.148|
00005e  8808              LDRH     r0,[r1,#0]  ; g_LcdHeight
;;;524    			g_LcdHeight = g_LcdWidth;
000060  490d              LDR      r1,|L35.152|
000062  8809              LDRH     r1,[r1,#0]  ; g_LcdWidth
000064  4a0b              LDR      r2,|L35.148|
000066  8011              STRH     r1,[r2,#0]
;;;525    			g_LcdWidth = temp;
000068  490b              LDR      r1,|L35.152|
00006a  8008              STRH     r0,[r1,#0]
                  |L35.108|
;;;526    		}
;;;527    	}		
00006c  e00e              B        |L35.140|
                  |L35.110|
;;;528    	else	/* 横屏 */
;;;529    	{
;;;530    		uint16_t temp;
;;;531    		
;;;532    		if (g_LcdHeight > g_LcdWidth)
00006e  4909              LDR      r1,|L35.148|
000070  8809              LDRH     r1,[r1,#0]  ; g_LcdHeight
000072  4a09              LDR      r2,|L35.152|
000074  8812              LDRH     r2,[r2,#0]  ; g_LcdWidth
000076  4291              CMP      r1,r2
000078  dd07              BLE      |L35.138|
;;;533    		{
;;;534    			temp = g_LcdHeight;
00007a  4906              LDR      r1,|L35.148|
00007c  8808              LDRH     r0,[r1,#0]  ; g_LcdHeight
;;;535    			g_LcdHeight = g_LcdWidth;
00007e  4906              LDR      r1,|L35.152|
000080  8809              LDRH     r1,[r1,#0]  ; g_LcdWidth
000082  4a04              LDR      r2,|L35.148|
000084  8011              STRH     r1,[r2,#0]
;;;536    			g_LcdWidth = temp;
000086  4904              LDR      r1,|L35.152|
000088  8008              STRH     r0,[r1,#0]
                  |L35.138|
;;;537    		}
;;;538    	}
00008a  bf00              NOP      
                  |L35.140|
;;;539    }
00008c  bd70              POP      {r4-r6,pc}
;;;540    
                          ENDP

00008e  0000              DCW      0x0000
                  |L35.144|
                          DCD      s_reg_40H
                  |L35.148|
                          DCD      g_LcdHeight
                  |L35.152|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_SetDispWin||, CODE, READONLY, ALIGN=2

                  RA8875_SetDispWin PROC
;;;1791   */
;;;1792   void RA8875_SetDispWin(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1793   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1794   
;;;1795   	uint16_t usTemp;
;;;1796   
;;;1797   	/* 坐标系统示意图: （横屏）
;;;1798   			 -----------------------------
;;;1799   			|(0,0)                        |
;;;1800   			|     --------->              |
;;;1801   			|         |                   |
;;;1802   			|         |                   |
;;;1803   			|         |                   |
;;;1804   			|         V                   |
;;;1805   			|     --------->              |
;;;1806   			|                    (479,271)|
;;;1807   			 -----------------------------
;;;1808   
;;;1809   		左上角是坐标零点, 扫描方向，先从左到右，再从上到下。
;;;1810   
;;;1811   		如果需要做竖屏方式，你需要进行物理坐标和逻辑坐标的转换
;;;1812   	*/
;;;1813   	RA8875_WriteReg(0x30, _usX);
00000c  b2e1              UXTB     r1,r4
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       RA8875_WriteReg
;;;1814       RA8875_WriteReg(0x31, _usX >> 8);
000014  1221              ASRS     r1,r4,#8
000016  2031              MOVS     r0,#0x31
000018  f7fffffe          BL       RA8875_WriteReg
;;;1815   
;;;1816   	RA8875_WriteReg(0x32, _usY);
00001c  b2e9              UXTB     r1,r5
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       RA8875_WriteReg
;;;1817       RA8875_WriteReg(0x33, _usY >> 8);
000024  1229              ASRS     r1,r5,#8
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       RA8875_WriteReg
;;;1818   
;;;1819   	usTemp = _usWidth + _usX - 1;
00002c  eb080004          ADD      r0,r8,r4
000030  1e40              SUBS     r0,r0,#1
000032  b286              UXTH     r6,r0
;;;1820   	RA8875_WriteReg(0x34, usTemp);
000034  b2f1              UXTB     r1,r6
000036  2034              MOVS     r0,#0x34
000038  f7fffffe          BL       RA8875_WriteReg
;;;1821       RA8875_WriteReg(0x35, usTemp >> 8);
00003c  1231              ASRS     r1,r6,#8
00003e  2035              MOVS     r0,#0x35
000040  f7fffffe          BL       RA8875_WriteReg
;;;1822   
;;;1823   	usTemp = _usHeight + _usY - 1;
000044  1978              ADDS     r0,r7,r5
000046  1e40              SUBS     r0,r0,#1
000048  b286              UXTH     r6,r0
;;;1824   	RA8875_WriteReg(0x36, usTemp);
00004a  b2f1              UXTB     r1,r6
00004c  2036              MOVS     r0,#0x36
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1825       RA8875_WriteReg(0x37, usTemp >> 8);
000052  1231              ASRS     r1,r6,#8
000054  2037              MOVS     r0,#0x37
000056  f7fffffe          BL       RA8875_WriteReg
;;;1826   
;;;1827   	RA8875_SetCursor(_usX, _usY);
00005a  4629              MOV      r1,r5
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       RA8875_SetCursor
;;;1828   
;;;1829   	/* 保存当前窗口信息，提高以后单色填充操作的效率.
;;;1830   	另外一种做法是通过读取0x30-0x37寄存器获得当前窗口，不过效率较低 */
;;;1831   	s_WinX = _usX;
000062  4805              LDR      r0,|L36.120|
000064  8004              STRH     r4,[r0,#0]
;;;1832   	s_WinY = _usY;
000066  4805              LDR      r0,|L36.124|
000068  8005              STRH     r5,[r0,#0]
;;;1833   	s_WinHeight = _usHeight;
00006a  4805              LDR      r0,|L36.128|
00006c  8007              STRH     r7,[r0,#0]
;;;1834   	s_WinWidth = _usWidth;
00006e  4805              LDR      r0,|L36.132|
000070  f8a08000          STRH     r8,[r0,#0]
;;;1835   }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;1836   
                          ENDP

                  |L36.120|
                          DCD      s_WinX
                  |L36.124|
                          DCD      s_WinY
                  |L36.128|
                          DCD      s_WinHeight
                  |L36.132|
                          DCD      s_WinWidth

                          AREA ||i.RA8875_SetFont||, CODE, READONLY, ALIGN=1

                  RA8875_SetFont PROC
;;;1556   */
;;;1557   void RA8875_SetFont(uint8_t _ucFontType, uint8_t _ucLineSpace, uint8_t _ucCharSpace)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1559   	/*
;;;1560   		[29H]在文字模式下，用来设定文字间的行距 (单位: 像素) 。
;;;1561   		只有低5个bit有效，0-31
;;;1562   	*/
;;;1563   	if (_ucLineSpace >31)
000008  2e1f              CMP      r6,#0x1f
00000a  dd00              BLE      |L37.14|
;;;1564   	{
;;;1565   		_ucLineSpace = 31;
00000c  261f              MOVS     r6,#0x1f
                  |L37.14|
;;;1566   	}
;;;1567   	RA8875_WriteReg(0x29, _ucLineSpace);
00000e  4631              MOV      r1,r6
000010  2029              MOVS     r0,#0x29
000012  f7fffffe          BL       RA8875_WriteReg
;;;1568   
;;;1569   	/*
;;;1570   		[2EH] 设置字符间距（像素单位，0-63），和字体（16*16，24*24，32*32）
;;;1571   	*/
;;;1572   	if (_ucCharSpace > 63)
000016  2d3f              CMP      r5,#0x3f
000018  dd00              BLE      |L37.28|
;;;1573   	{
;;;1574   		_ucCharSpace = 63;
00001a  253f              MOVS     r5,#0x3f
                  |L37.28|
;;;1575   	}
;;;1576   	if (_ucFontType > RA_FONT_32)
00001c  2c02              CMP      r4,#2
00001e  dd00              BLE      |L37.34|
;;;1577   	{
;;;1578   		_ucFontType = RA_FONT_16;
000020  2400              MOVS     r4,#0
                  |L37.34|
;;;1579   	}
;;;1580   	RA8875_WriteReg(0x2E, (_ucCharSpace & 0x3F) | (_ucFontType << 6));
000022  4628              MOV      r0,r5
000024  f364109f          BFI      r0,r4,#6,#26
000028  b2c1              UXTB     r1,r0
00002a  f04f002e          MOV      r0,#0x2e
00002e  f7fffffe          BL       RA8875_WriteReg
;;;1581   }
000032  bd70              POP      {r4-r6,pc}
;;;1582   
                          ENDP


                          AREA ||i.RA8875_SetFrontColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetFrontColor PROC
;;;600    */
;;;601    void RA8875_SetFrontColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;602    {
000002  4604              MOV      r4,r0
;;;603    	RA8875_WriteReg(0x63, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ae1              LSRS     r1,r4,#11
000006  2063              MOVS     r0,#0x63
000008  f7fffffe          BL       RA8875_WriteReg
;;;604    	RA8875_WriteReg(0x64, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2064              MOVS     r0,#0x64
000012  f7fffffe          BL       RA8875_WriteReg
;;;605    	RA8875_WriteReg(0x65, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  2065              MOVS     r0,#0x65
00001c  f7fffffe          BL       RA8875_WriteReg
;;;606    }
000020  bd10              POP      {r4,pc}
;;;607    
                          ENDP


                          AREA ||i.RA8875_SetReadCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetReadCursor PROC
;;;1870   */
;;;1871   static void RA8875_SetReadCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1872   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1873   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480c              LDR      r0,|L39.56|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd03              BLE      |L39.22|
;;;1874   	{
;;;1875   		uint16_t temp;
;;;1876   		
;;;1877   		temp = _usX;
00000e  4620              MOV      r0,r4
;;;1878   		_usX = _usY;
000010  462c              MOV      r4,r5
;;;1879   		_usY = temp;
000012  4605              MOV      r5,r0
;;;1880   	}
000014  bf00              NOP      
                  |L39.22|
;;;1881   		
;;;1882   	/* 设置内存读光标的坐标 */
;;;1883   	RA8875_WriteReg(0x4A, _usX);
000016  b2e1              UXTB     r1,r4
000018  204a              MOVS     r0,#0x4a
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1884   	RA8875_WriteReg(0x4B, _usX >> 8);
00001e  1221              ASRS     r1,r4,#8
000020  204b              MOVS     r0,#0x4b
000022  f7fffffe          BL       RA8875_WriteReg
;;;1885   	RA8875_WriteReg(0x4C, _usY);
000026  b2e9              UXTB     r1,r5
000028  204c              MOVS     r0,#0x4c
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1886   	RA8875_WriteReg(0x4D, _usY >> 8);
00002e  1229              ASRS     r1,r5,#8
000030  204d              MOVS     r0,#0x4d
000032  f7fffffe          BL       RA8875_WriteReg
;;;1887   }
000036  bd70              POP      {r4-r6,pc}
;;;1888   
                          ENDP

                  |L39.56|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetTextCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextCursor PROC
;;;1896   */
;;;1897   static void RA8875_SetTextCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1898   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1899   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480c              LDR      r0,|L40.56|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd03              BLE      |L40.22|
;;;1900   	{
;;;1901   		uint16_t temp;
;;;1902   		
;;;1903   		temp = _usX;
00000e  4620              MOV      r0,r4
;;;1904   		_usX = _usY;
000010  462c              MOV      r4,r5
;;;1905   		_usY = temp;
000012  4605              MOV      r5,r0
;;;1906   	}
000014  bf00              NOP      
                  |L40.22|
;;;1907   			
;;;1908   	/* 设置内存读光标的坐标 */
;;;1909   	RA8875_WriteReg(0x2A, _usX);
000016  b2e1              UXTB     r1,r4
000018  202a              MOVS     r0,#0x2a
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1910   	RA8875_WriteReg(0x2B, _usX >> 8);
00001e  1221              ASRS     r1,r4,#8
000020  202b              MOVS     r0,#0x2b
000022  f7fffffe          BL       RA8875_WriteReg
;;;1911   	RA8875_WriteReg(0x2C, _usY);
000026  b2e9              UXTB     r1,r5
000028  202c              MOVS     r0,#0x2c
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1912   	RA8875_WriteReg(0x2D, _usY >> 8);
00002e  1229              ASRS     r1,r5,#8
000030  202d              MOVS     r0,#0x2d
000032  f7fffffe          BL       RA8875_WriteReg
;;;1913   }
000036  bd70              POP      {r4-r6,pc}
;;;1914   
                          ENDP

                  |L40.56|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetTextZoom||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextZoom PROC
;;;1593   */
;;;1594   void RA8875_SetTextZoom(uint8_t _ucHSize, uint8_t _ucVSize)
000000  b570              PUSH     {r4-r6,lr}
;;;1595   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1596   	/*
;;;1597   		pdf 第22页		[22H]
;;;1598   		bit7 用于对齐，一般不用，缺省设0
;;;1599   		bit6 用于通透，一般不用，缺省设0
;;;1600   		bit4 用于旋转90读，一般不用，缺省设0
;;;1601   		bit3-2 水平放大倍数
;;;1602   		bit1-0 垂直放大倍数
;;;1603   	*/
;;;1604   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  480f              LDR      r0,|L41.68|
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  dd0c              BLE      |L41.40|
;;;1605   	{
;;;1606   		RA8875_WriteReg(0x22, (1 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
00000e  f0040003          AND      r0,r4,#3
000012  2210              MOVS     r2,#0x10
000014  ea420080          ORR      r0,r2,r0,LSL #2
000018  f0050203          AND      r2,r5,#3
00001c  ea400102          ORR      r1,r0,r2
000020  2022              MOVS     r0,#0x22
000022  f7fffffe          BL       RA8875_WriteReg
000026  e00b              B        |L41.64|
                  |L41.40|
;;;1607   	}
;;;1608   	else	/* 横屏 */
;;;1609   	{
;;;1610   		RA8875_WriteReg(0x22, (0 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
000028  f0040003          AND      r0,r4,#3
00002c  2200              MOVS     r2,#0
00002e  ea420080          ORR      r0,r2,r0,LSL #2
000032  f0050203          AND      r2,r5,#3
000036  ea400102          ORR      r1,r0,r2
00003a  2022              MOVS     r0,#0x22
00003c  f7fffffe          BL       RA8875_WriteReg
                  |L41.64|
;;;1611   	}
;;;1612   }
000040  bd70              POP      {r4-r6,pc}
;;;1613   
                          ENDP

000042  0000              DCW      0x0000
                  |L41.68|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_Sleep||, CODE, READONLY, ALIGN=1

                  RA8875_Sleep PROC
;;;906    */
;;;907    void RA8875_Sleep(void)
000000  b510              PUSH     {r4,lr}
;;;908    {
;;;909    	RA8875_SetBackLight(0);		/* 关闭背光 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RA8875_SetBackLight
;;;910    
;;;911    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;912    	RA8875_WriteReg(0xC7, 0x00);	/* DISP = 0  */
000008  2100              MOVS     r1,#0
00000a  20c7              MOVS     r0,#0xc7
00000c  f7fffffe          BL       RA8875_WriteReg
;;;913    
;;;914    	RA8875_WriteReg(0x01, 0x01);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RA8875_WriteReg
;;;915    	RA8875_WriteReg(0x01, 0x00);
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RA8875_WriteReg
;;;916    
;;;917    	RA8875_WriteReg(0x01, 0x02);	/* RA8875 Sleep */
000020  2102              MOVS     r1,#2
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       RA8875_WriteReg
;;;918    }
000028  bd10              POP      {r4,pc}
;;;919    
                          ENDP


                          AREA ||i.RA8875_StartDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_StartDirectDraw PROC
;;;1208   */
;;;1209   void RA8875_StartDirectDraw(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1210   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1211   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1212   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RA8875_SetDispWin
;;;1213   
;;;1214   	s_ucRA8875BusyNow = 1;
000018  2001              MOVS     r0,#1
00001a  4903              LDR      r1,|L43.40|
00001c  7008              STRB     r0,[r1,#0]
;;;1215   
;;;1216   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RA8875_WriteCmd
;;;1217   
;;;1218   	/* 之后，应用程序可以直接绘图 */
;;;1219   }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;1220   
                          ENDP

                  |L43.40|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_TouchInit||, CODE, READONLY, ALIGN=1

                  RA8875_TouchInit PROC
;;;739    */
;;;740    void RA8875_TouchInit(void)
000000  b510              PUSH     {r4,lr}
;;;741    {
;;;742    	RA8875_WriteReg(0xF0, (1 << 2));	/* 开启触控面板中断位 */
000002  2104              MOVS     r1,#4
000004  20f0              MOVS     r0,#0xf0
000006  f7fffffe          BL       RA8875_WriteReg
;;;743    
;;;744    	/*
;;;745    		REG[71h] Touch Panel Control Register 1 (TPCR1)
;;;746    
;;;747    		Bit7 N/A
;;;748    		Bit6 触控面板模式设定
;;;749    			0 : 自动模式。
;;;750    			1 : 手动模式。
;;;751    		Bit5 触控面板控制器ADC 参考电压(Vref)来源设定
;;;752    			0 : 内部产生参考电压。
;;;753    			1 : 外部输入参考电压，ADC 参考电压准位= 1/2 VDD。
;;;754    		Bit4-3 N/A
;;;755    		Bit2 触控中断讯号的消除弹跳电路选择
;;;756    			0: 关闭消除弹跳电路。
;;;757    			1: 开启消除弹跳电路。
;;;758    		Bit1-0 触控面板手动模式之选择位
;;;759    			00b : 闲置模式。触控控制单元进入闲置模式。
;;;760    			01b : 侦测触摸事件发生。在此模式控制器会侦测触摸事件的发
;;;761    				生，事件发生可以引发中断或是由缓存器得知(REG[F1h]
;;;762    				Bit2)。
;;;763    			10b : X 轴数据撷取模式。在此模式触摸位置的X 轴数据会被储
;;;764    				存至 REG[72h] 和REG[74h]。
;;;765    			11b : Y 轴数据撷取模式。在此模式触摸位置的Y 轴数据会被储
;;;766    				存至REG[73h] and REG[74h]。
;;;767    	*/
;;;768    	RA8875_WriteReg(0x71, (0 << 6) | (0 << 5) | (1 << 2));	/* 选择自动模式 */
00000a  2104              MOVS     r1,#4
00000c  2071              MOVS     r0,#0x71
00000e  f7fffffe          BL       RA8875_WriteReg
;;;769    
;;;770    	/*
;;;771    		REG[70h] Touch Panel Control Register 0 (TPCR0)
;;;772    
;;;773    		Bit7 触控面板功能设定
;;;774    			0 : 关闭。
;;;775    			1 : 开启。
;;;776    		Bit6-4 触控面板控制器取样时间设定
;;;777    			000b : ADC 取样时间为512 个系统频率周期。
;;;778    			001b : ADC 取样时间为 1024 个系统频率周期。
;;;779    			010b : ADC 取样时间为 2048 个系统频率周期。
;;;780    			011b : ADC 取样时间为 4096 个系统频率周期。
;;;781    			100b : ADC 取样时间为 8192 个系统频率周期。
;;;782    			101b : ADC 取样时间为 16384 个系统频率周期。
;;;783    			110b : ADC 取样时间为 32768 个系统频率周期。
;;;784    			111b : ADC 取样时间为65536 个系统频率周期。
;;;785    		Bit3 触控面板唤醒模式
;;;786    			0 : 关闭触控事件唤醒模式。
;;;787    			1 : 触控事件可唤醒睡眠模式。
;;;788    		Bit2-0 触控面板控制器ADC 频率设定
;;;789    			000b : 系统频率。
;;;790    			001b : 系统频率 / 2。
;;;791    			010b : 系统频率 / 4。
;;;792    			011b : 系统频率 / 8。
;;;793    			100b : 系统频率 / 16。
;;;794    			101b : 系统频率 / 32。
;;;795    			110b : 系统频率 / 64。
;;;796    			111b : 系统频率 / 128。
;;;797    
;;;798    		注 : ADC 的输入频率设定不能超过10MHz。
;;;799    	*/
;;;800    	RA8875_WriteReg(0x70, (1 << 7) | (3 << 4) | (0 << 3) | (2 << 0));	/* 开启触摸功能； */
000012  21b2              MOVS     r1,#0xb2
000014  2070              MOVS     r0,#0x70
000016  f7fffffe          BL       RA8875_WriteReg
;;;801    }
00001a  bd10              POP      {r4,pc}
;;;802    
                          ENDP


                          AREA ||i.RA8875_TouchReadX||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadX PROC
;;;810    */
;;;811    uint16_t RA8875_TouchReadX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;812    {
;;;813    	uint16_t usAdc;
;;;814    	uint8_t ucRegValue;
;;;815    	uint8_t ucReg74;
;;;816    
;;;817    	/* 软件读取中断事件标志 */
;;;818    	ucRegValue = RA8875_ReadReg_Int(0xF1);
000002  20f1              MOVS     r0,#0xf1
000004  f7fffffe          BL       RA8875_ReadReg_Int
000008  4606              MOV      r6,r0
;;;819    	if (ucRegValue & (1 << 2))
00000a  f0160f04          TST      r6,#4
00000e  d01e              BEQ      |L45.78|
;;;820    	{
;;;821    		ucReg74 = RA8875_ReadReg_Int(0x74);
000010  2074              MOVS     r0,#0x74
000012  f7fffffe          BL       RA8875_ReadReg_Int
000016  4605              MOV      r5,r0
;;;822    		usAdc = RA8875_ReadReg_Int(0x72);	/* Bit9-2 */
000018  2072              MOVS     r0,#0x72
00001a  f7fffffe          BL       RA8875_ReadReg_Int
00001e  4604              MOV      r4,r0
;;;823    		usAdc <<= 2;
000020  f64f70ff          MOV      r0,#0xffff
000024  ea000484          AND      r4,r0,r4,LSL #2
;;;824    		usAdc += (ucReg74 & 0x03);
000028  f0050003          AND      r0,r5,#3
00002c  4404              ADD      r4,r4,r0
;;;825    
;;;826    		s_usTouchX = usAdc;
00002e  4812              LDR      r0,|L45.120|
000030  8004              STRH     r4,[r0,#0]
;;;827    
;;;828    		usAdc = RA8875_ReadReg_Int(0x73);	/* Bit9-2 */
000032  2073              MOVS     r0,#0x73
000034  f7fffffe          BL       RA8875_ReadReg_Int
000038  4604              MOV      r4,r0
;;;829    		usAdc <<= 2;
00003a  f64f70ff          MOV      r0,#0xffff
00003e  ea000484          AND      r4,r0,r4,LSL #2
;;;830    		usAdc += ((ucReg74 & 0x0C) >> 2);
000042  f3c50081          UBFX     r0,r5,#2,#2
000046  4404              ADD      r4,r4,r0
;;;831    
;;;832    		s_usTouchY = usAdc;
000048  480c              LDR      r0,|L45.124|
00004a  8004              STRH     r4,[r0,#0]
00004c  e004              B        |L45.88|
                  |L45.78|
;;;833    	}
;;;834    	else
;;;835    	{
;;;836    		s_usTouchX = 0;
00004e  2000              MOVS     r0,#0
000050  4909              LDR      r1,|L45.120|
000052  8008              STRH     r0,[r1,#0]
;;;837    		s_usTouchY = 0;
000054  4909              LDR      r1,|L45.124|
000056  8008              STRH     r0,[r1,#0]
                  |L45.88|
;;;838    	}
;;;839    
;;;840    	/*
;;;841    		bit2 写入功能?? 触控面板中断清除位
;;;842    		0 : 未操作。
;;;843    		1 : 清除触控面板中断。
;;;844    		读取功能?? 触控面板中断状态
;;;845    		0 : 未发生触控面板中断。
;;;846    		1 : 发生触控面板中断。
;;;847    	*/
;;;848    
;;;849    	/*
;;;850    		不要调用这个函数写寄存器，因为该函数改写了busy标志
;;;851    		RA8875_WriteReg(0xF1, (1 << 2));	 必须清除， 才会下次采样.
;;;852    	*/
;;;853    	s_ucRA8875BusyNow = 1;
000058  2001              MOVS     r0,#1
00005a  4909              LDR      r1,|L45.128|
00005c  7008              STRB     r0,[r1,#0]
;;;854    	RA8875_WriteCmd(0xF1);
00005e  20f1              MOVS     r0,#0xf1
000060  f7fffffe          BL       RA8875_WriteCmd
;;;855    	RA8875_WriteData(1 << 2);
000064  2004              MOVS     r0,#4
000066  f7fffffe          BL       RA8875_WriteData
;;;856    	s_ucRA8875BusyNow = 0;
00006a  2000              MOVS     r0,#0
00006c  4904              LDR      r1,|L45.128|
00006e  7008              STRB     r0,[r1,#0]
;;;857    	return s_usTouchX;
000070  4801              LDR      r0,|L45.120|
000072  8800              LDRH     r0,[r0,#0]  ; s_usTouchX
;;;858    }
000074  bd70              POP      {r4-r6,pc}
;;;859    
                          ENDP

000076  0000              DCW      0x0000
                  |L45.120|
                          DCD      s_usTouchX
                  |L45.124|
                          DCD      s_usTouchY
                  |L45.128|
                          DCD      s_ucRA8875BusyNow

                          AREA ||i.RA8875_TouchReadY||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadY PROC
;;;867    */
;;;868    uint16_t RA8875_TouchReadY(void)
000000  4801              LDR      r0,|L46.8|
;;;869    {
;;;870    	return s_usTouchY;
000002  8800              LDRH     r0,[r0,#0]  ; s_usTouchY
;;;871    }
000004  4770              BX       lr
;;;872    
                          ENDP

000006  0000              DCW      0x0000
                  |L46.8|
                          DCD      s_usTouchY

                          AREA ||i.RA8875_WaitBusy||, CODE, READONLY, ALIGN=1

                  RA8875_WaitBusy PROC
;;;678    */
;;;679    void RA8875_WaitBusy(void)
000000  b510              PUSH     {r4,lr}
;;;680    {
;;;681    	while ((RA8875_ReadStatus() & 0x80) == 0x80);
000002  bf00              NOP      
                  |L47.4|
000004  f7fffffe          BL       RA8875_ReadStatus
000008  f0000080          AND      r0,r0,#0x80
00000c  2880              CMP      r0,#0x80
00000e  d0f9              BEQ      |L47.4|
;;;682    }
000010  bd10              POP      {r4,pc}
;;;683    
                          ENDP


                          AREA ||i.RA8875_WriteReg||, CODE, READONLY, ALIGN=2

                  RA8875_WriteReg PROC
;;;95     */
;;;96     void RA8875_WriteReg(uint8_t _ucRegAddr, uint8_t _ucRegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;98     	s_ucRA8875BusyNow = 1;				/* 设置忙标志，避免触摸中断中的程序访问冲突 */
000006  2001              MOVS     r0,#1
000008  4905              LDR      r1,|L48.32|
00000a  7008              STRB     r0,[r1,#0]
;;;99     
;;;100    	RA8875_WriteCmd(_ucRegAddr);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       RA8875_WriteCmd
;;;101    	RA8875_WriteData(_ucRegValue);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RA8875_WriteData
;;;102    
;;;103    	s_ucRA8875BusyNow = 0;
000018  2000              MOVS     r0,#0
00001a  4901              LDR      r1,|L48.32|
00001c  7008              STRB     r0,[r1,#0]
;;;104    }
00001e  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP

                  |L48.32|
                          DCD      s_ucRA8875BusyNow

                          AREA ||.data||, DATA, ALIGN=1

                  s_WinX
000000  0000              DCW      0x0000
                  s_WinY
000002  0000              DCW      0x0000
                  s_WinHeight
000004  0110              DCW      0x0110
                  s_WinWidth
000006  01e0              DCW      0x01e0
                  s_usTouchX
000008  0000              DCB      0x00,0x00
                  s_usTouchY
00000a  0000              DCB      0x00,0x00
                  s_reg_40H
00000c  00                DCB      0x00
                  s_reg_22H
00000d  00                DCB      0x00
                  g_ucGPIX
00000e  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\LCD_RA8875.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REV16|
#line 129 "F:\\keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_LCD_RA8875_c_fad3ed70____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REVSH|
#line 144
|__asm___12_LCD_RA8875_c_fad3ed70____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
