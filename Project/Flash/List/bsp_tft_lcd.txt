; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_tft_lcd.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_tft_lcd.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\bsp_tft_lcd.crf ..\User\bsp_stm32f4xx\src\bsp_tft_lcd.c]
                          THUMB

                          AREA ||i.LCD_Blend565||, CODE, READONLY, ALIGN=2

                  LCD_Blend565 PROC
;;;1131   */
;;;1132   uint16_t LCD_Blend565(uint16_t src, uint16_t dst, uint8_t alpha)
000000  b570              PUSH     {r4-r6,lr}
;;;1133   {
000002  4603              MOV      r3,r0
;;;1134   	uint32_t src2;
;;;1135   	uint32_t dst2;
;;;1136   
;;;1137   	src2 = ((src << 16) |src) & 0x07E0F81F;
000004  ea434003          ORR      r0,r3,r3,LSL #16
000008  4e08              LDR      r6,|L1.44|
00000a  ea000406          AND      r4,r0,r6
;;;1138   	dst2 = ((dst << 16) | dst) & 0x07E0F81F;
00000e  ea414001          ORR      r0,r1,r1,LSL #16
000012  ea000506          AND      r5,r0,r6
;;;1139   	dst2 = ((((dst2 - src2) * alpha) >> 5) + src2) & 0x07E0F81F;
000016  1b28              SUBS     r0,r5,r4
000018  4350              MULS     r0,r2,r0
00001a  eb041050          ADD      r0,r4,r0,LSR #5
00001e  ea000506          AND      r5,r0,r6
;;;1140   	return (dst2 >> 16) | dst2;
000022  ea454015          ORR      r0,r5,r5,LSR #16
000026  b280              UXTH     r0,r0
;;;1141   }
000028  bd70              POP      {r4-r6,pc}
;;;1142   
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x07e0f81f

                          AREA ||i.LCD_ButtonTouchDown||, CODE, READONLY, ALIGN=1

                  LCD_ButtonTouchDown PROC
;;;2057   */
;;;2058   uint8_t LCD_ButtonTouchDown(BUTTON_T *_btn, uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;2059   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2060   	if ((_usX > _btn->Left) && (_usX < _btn->Left + _btn->Width)
000008  8860              LDRH     r0,[r4,#2]
00000a  42a8              CMP      r0,r5
00000c  da13              BGE      |L2.54|
00000e  8860              LDRH     r0,[r4,#2]
000010  8921              LDRH     r1,[r4,#8]
000012  4408              ADD      r0,r0,r1
000014  42a8              CMP      r0,r5
000016  dd0e              BLE      |L2.54|
;;;2061   		&& (_usY > _btn->Top) && (_usY < _btn->Top + _btn->Height))
000018  88a0              LDRH     r0,[r4,#4]
00001a  42b0              CMP      r0,r6
00001c  da0b              BGE      |L2.54|
00001e  88a0              LDRH     r0,[r4,#4]
000020  88e1              LDRH     r1,[r4,#6]
000022  4408              ADD      r0,r0,r1
000024  42b0              CMP      r0,r6
000026  dd06              BLE      |L2.54|
;;;2062   	{
;;;2063   		_btn->Focus = 1;
000028  2001              MOVS     r0,#1
00002a  7520              STRB     r0,[r4,#0x14]
;;;2064   		LCD_DrawButton(_btn);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       LCD_DrawButton
;;;2065   		return 1;
000032  2001              MOVS     r0,#1
                  |L2.52|
;;;2066   	}
;;;2067   	else
;;;2068   	{
;;;2069   		return 0;
;;;2070   	}
;;;2071   }
000034  bd70              POP      {r4-r6,pc}
                  |L2.54|
000036  2000              MOVS     r0,#0                 ;2069
000038  e7fc              B        |L2.52|
;;;2072   
                          ENDP


                          AREA ||i.LCD_ButtonTouchRelease||, CODE, READONLY, ALIGN=1

                  LCD_ButtonTouchRelease PROC
;;;2081   */
;;;2082   uint8_t LCD_ButtonTouchRelease(BUTTON_T *_btn, uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;2083   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2084   	_btn->Focus = 0;
000008  2000              MOVS     r0,#0
00000a  7520              STRB     r0,[r4,#0x14]
;;;2085   	LCD_DrawButton(_btn);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       LCD_DrawButton
;;;2086   
;;;2087   	if ((_usX > _btn->Left) && (_usX < _btn->Left + _btn->Width)
000012  8860              LDRH     r0,[r4,#2]
000014  42a8              CMP      r0,r5
000016  da0e              BGE      |L3.54|
000018  8860              LDRH     r0,[r4,#2]
00001a  8921              LDRH     r1,[r4,#8]
00001c  4408              ADD      r0,r0,r1
00001e  42a8              CMP      r0,r5
000020  dd09              BLE      |L3.54|
;;;2088   		&& (_usY > _btn->Top) && (_usY < _btn->Top + _btn->Height))
000022  88a0              LDRH     r0,[r4,#4]
000024  42b0              CMP      r0,r6
000026  da06              BGE      |L3.54|
000028  88a0              LDRH     r0,[r4,#4]
00002a  88e1              LDRH     r1,[r4,#6]
00002c  4408              ADD      r0,r0,r1
00002e  42b0              CMP      r0,r6
000030  dd01              BLE      |L3.54|
;;;2089   	{
;;;2090   		return 1;
000032  2001              MOVS     r0,#1
                  |L3.52|
;;;2091   	}
;;;2092   	else
;;;2093   	{
;;;2094   		return 0;
;;;2095   	}
;;;2096   }
000034  bd70              POP      {r4-r6,pc}
                  |L3.54|
000036  2000              MOVS     r0,#0                 ;2094
000038  e7fc              B        |L3.52|
;;;2097   /*
                          ENDP


                          AREA ||i.LCD_ClrScr||, CODE, READONLY, ALIGN=2

                  LCD_ClrScr PROC
;;;220    */
;;;221    void LCD_ClrScr(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	if (g_ChipID == IC_8875)	/* RA8875 分支 */
000004  480a              LDR      r0,|L4.48|
000006  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000008  2875              CMP      r0,#0x75
00000a  d103              BNE      |L4.20|
;;;224    	{
;;;225    		RA8875_ClrScr(_usColor);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RA8875_ClrScr
000012  e00c              B        |L4.46|
                  |L4.20|
;;;226    	}
;;;227    	else if (g_ChipID == IC_9488)
000014  4806              LDR      r0,|L4.48|
000016  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000018  f2494188          MOV      r1,#0x9488
00001c  4288              CMP      r0,r1
00001e  d103              BNE      |L4.40|
;;;228    	{
;;;229    		ILI9488_ClrScr(_usColor);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ILI9488_ClrScr
000026  e002              B        |L4.46|
                  |L4.40|
;;;230    	}
;;;231    	else	/* 5420，4001，61509 分支 */
;;;232    	{
;;;233    		SPFD5420_ClrScr(_usColor);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_ClrScr
                  |L4.46|
;;;234    	}
;;;235    }
00002e  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L4.48|
                          DCD      g_ChipID

                          AREA ||i.LCD_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  LCD_CtrlLinesConfig PROC
;;;1743   */
;;;1744   static void LCD_CtrlLinesConfig(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;1745   {
;;;1746   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1747   
;;;1748   	/* 使能FSMC时钟 */
;;;1749   	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;1750   
;;;1751   	/* 使能 GPIO时钟 */
;;;1752   	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2058              MOVS     r0,#0x58
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1753   
;;;1754   	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;1755   	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;1756   
;;;1757   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FMC);
000012  220c              MOVS     r2,#0xc
000014  2100              MOVS     r1,#0
000016  4850              LDR      r0,|L5.344|
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;1758   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FMC);
00001c  220c              MOVS     r2,#0xc
00001e  2101              MOVS     r1,#1
000020  484d              LDR      r0,|L5.344|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;1759   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FMC);
000026  220c              MOVS     r2,#0xc
000028  2104              MOVS     r1,#4
00002a  484b              LDR      r0,|L5.344|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;1760   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FMC);
000030  220c              MOVS     r2,#0xc
000032  2105              MOVS     r1,#5
000034  4848              LDR      r0,|L5.344|
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;1761   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FMC);
00003a  220c              MOVS     r2,#0xc
00003c  2108              MOVS     r1,#8
00003e  4846              LDR      r0,|L5.344|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;1762   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FMC);
000044  220c              MOVS     r2,#0xc
000046  2109              MOVS     r1,#9
000048  4843              LDR      r0,|L5.344|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;1763   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FMC);
00004e  220c              MOVS     r2,#0xc
000050  210a              MOVS     r1,#0xa
000052  4841              LDR      r0,|L5.344|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;1764   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FMC);
000058  220c              MOVS     r2,#0xc
00005a  210e              MOVS     r1,#0xe
00005c  483e              LDR      r0,|L5.344|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;1765   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FMC);
000062  220c              MOVS     r2,#0xc
000064  210f              MOVS     r1,#0xf
000066  483c              LDR      r0,|L5.344|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;1766   
;;;1767   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
00006c  f24c7033          MOV      r0,#0xc733
000070  9000              STR      r0,[sp,#0]
;;;1768   	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;1769   	                            GPIO_Pin_15;
;;;1770   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000072  2002              MOVS     r0,#2
000074  f88d0004          STRB     r0,[sp,#4]
;;;1771   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000078  2003              MOVS     r0,#3
00007a  f88d0005          STRB     r0,[sp,#5]
;;;1772   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00007e  2000              MOVS     r0,#0
000080  f88d0006          STRB     r0,[sp,#6]
;;;1773   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000084  f88d0007          STRB     r0,[sp,#7]
;;;1774   	GPIO_Init(GPIOD, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4833              LDR      r0,|L5.344|
00008c  f7fffffe          BL       GPIO_Init
;;;1775   
;;;1776   	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;1777   	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;1778   //	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FMC);
;;;1779   //	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FMC);
;;;1780   	
;;;1781   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FMC);
000090  220c              MOVS     r2,#0xc
000092  2107              MOVS     r1,#7
000094  4831              LDR      r0,|L5.348|
000096  f7fffffe          BL       GPIO_PinAFConfig
;;;1782   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FMC);
00009a  220c              MOVS     r2,#0xc
00009c  2108              MOVS     r1,#8
00009e  482f              LDR      r0,|L5.348|
0000a0  f7fffffe          BL       GPIO_PinAFConfig
;;;1783   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FMC);
0000a4  220c              MOVS     r2,#0xc
0000a6  2109              MOVS     r1,#9
0000a8  482c              LDR      r0,|L5.348|
0000aa  f7fffffe          BL       GPIO_PinAFConfig
;;;1784   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FMC);
0000ae  220c              MOVS     r2,#0xc
0000b0  210a              MOVS     r1,#0xa
0000b2  482a              LDR      r0,|L5.348|
0000b4  f7fffffe          BL       GPIO_PinAFConfig
;;;1785   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FMC);
0000b8  220c              MOVS     r2,#0xc
0000ba  210b              MOVS     r1,#0xb
0000bc  4827              LDR      r0,|L5.348|
0000be  f7fffffe          BL       GPIO_PinAFConfig
;;;1786   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FMC);
0000c2  220c              MOVS     r2,#0xc
0000c4  4611              MOV      r1,r2
0000c6  4825              LDR      r0,|L5.348|
0000c8  f7fffffe          BL       GPIO_PinAFConfig
;;;1787   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FMC);
0000cc  220c              MOVS     r2,#0xc
0000ce  210d              MOVS     r1,#0xd
0000d0  4822              LDR      r0,|L5.348|
0000d2  f7fffffe          BL       GPIO_PinAFConfig
;;;1788   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FMC);
0000d6  220c              MOVS     r2,#0xc
0000d8  210e              MOVS     r1,#0xe
0000da  4820              LDR      r0,|L5.348|
0000dc  f7fffffe          BL       GPIO_PinAFConfig
;;;1789   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FMC);
0000e0  220c              MOVS     r2,#0xc
0000e2  210f              MOVS     r1,#0xf
0000e4  481d              LDR      r0,|L5.348|
0000e6  f7fffffe          BL       GPIO_PinAFConfig
;;;1790   	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0000ea  f64f7080          MOV      r0,#0xff80
0000ee  9000              STR      r0,[sp,#0]
;;;1791   	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;1792   	                            GPIO_Pin_15;
;;;1793   	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000f0  4669              MOV      r1,sp
0000f2  481a              LDR      r0,|L5.348|
0000f4  f7fffffe          BL       GPIO_Init
;;;1794   	/* 设置 PD.13(A18 (RS))  为复用推挽输出 */
;;;1795   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FMC);
0000f8  220c              MOVS     r2,#0xc
0000fa  210d              MOVS     r1,#0xd
0000fc  4816              LDR      r0,|L5.344|
0000fe  f7fffffe          BL       GPIO_PinAFConfig
;;;1796   
;;;1797   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000102  f44f5000          MOV      r0,#0x2000
000106  9000              STR      r0,[sp,#0]
;;;1798   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000108  2002              MOVS     r0,#2
00010a  f88d0004          STRB     r0,[sp,#4]
;;;1799   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00010e  2003              MOVS     r0,#3
000110  f88d0005          STRB     r0,[sp,#5]
;;;1800   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000114  2000              MOVS     r0,#0
000116  f88d0006          STRB     r0,[sp,#6]
;;;1801   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00011a  f88d0007          STRB     r0,[sp,#7]
;;;1802   	GPIO_Init(GPIOD, &GPIO_InitStructure);
00011e  4669              MOV      r1,sp
000120  480d              LDR      r0,|L5.344|
000122  f7fffffe          BL       GPIO_Init
;;;1803   
;;;1804   	/* 设置 PG12 (LCD/CS)) 为复用推挽输出 */
;;;1805   	GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_FMC);
000126  220c              MOVS     r2,#0xc
000128  4611              MOV      r1,r2
00012a  480d              LDR      r0,|L5.352|
00012c  f7fffffe          BL       GPIO_PinAFConfig
;;;1806   
;;;1807   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000130  f44f5080          MOV      r0,#0x1000
000134  9000              STR      r0,[sp,#0]
;;;1808   		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000136  2002              MOVS     r0,#2
000138  f88d0004          STRB     r0,[sp,#4]
;;;1809   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00013c  2003              MOVS     r0,#3
00013e  f88d0005          STRB     r0,[sp,#5]
;;;1810   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000142  2000              MOVS     r0,#0
000144  f88d0006          STRB     r0,[sp,#6]
;;;1811   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000148  f88d0007          STRB     r0,[sp,#7]
;;;1812   	GPIO_Init(GPIOG, &GPIO_InitStructure);
00014c  4669              MOV      r1,sp
00014e  4804              LDR      r0,|L5.352|
000150  f7fffffe          BL       GPIO_Init
;;;1813   }
000154  bd1c              POP      {r2-r4,pc}
;;;1814   
                          ENDP

000156  0000              DCW      0x0000
                  |L5.344|
                          DCD      0x40020c00
                  |L5.348|
                          DCD      0x40021000
                  |L5.352|
                          DCD      0x40021800

                          AREA ||i.LCD_DispControl||, CODE, READONLY, ALIGN=1

                  LCD_DispControl PROC
;;;1658   */
;;;1659   void LCD_DispControl(void *_pControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1660   {
000002  4604              MOV      r4,r0
;;;1661   	uint8_t id;
;;;1662   
;;;1663   	id = *(uint8_t *)_pControl;	/* 读取ID */
000004  7825              LDRB     r5,[r4,#0]
;;;1664   
;;;1665   	switch (id)
000006  2d08              CMP      r5,#8
000008  d21e              BCS      |L6.72|
00000a  e8dff005          TBB      [pc,r5]
00000e  1d04              DCB      0x1d,0x04
000010  05090d11          DCB      0x05,0x09,0x0d,0x11
000014  1519              DCB      0x15,0x19
;;;1666   	{
;;;1667   		case ID_ICON:
;;;1668   			//void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode);
;;;1669   			break;
000016  e017              B        |L6.72|
;;;1670   
;;;1671   		case ID_WIN:
;;;1672   			LCD_DrawWin((WIN_T *)_pControl);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       LCD_DrawWin
;;;1673   			break;
00001e  e013              B        |L6.72|
;;;1674   
;;;1675   		case ID_LABEL:
;;;1676   			LCD_DrawLabel((LABEL_T *)_pControl);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       LCD_DrawLabel
;;;1677   			break;
000026  e00f              B        |L6.72|
;;;1678   
;;;1679   		case ID_BUTTON:
;;;1680   			LCD_DrawButton((BUTTON_T *)_pControl);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       LCD_DrawButton
;;;1681   			break;
00002e  e00b              B        |L6.72|
;;;1682   
;;;1683   		case ID_CHECK:
;;;1684   			LCD_DrawCheckBox((CHECK_T *)_pControl);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       LCD_DrawCheckBox
;;;1685   			break;
000036  e007              B        |L6.72|
;;;1686   
;;;1687   		case ID_EDIT:
;;;1688   			LCD_DrawEdit((EDIT_T *)_pControl);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       LCD_DrawEdit
;;;1689   			break;
00003e  e003              B        |L6.72|
;;;1690   
;;;1691   		case ID_GROUP:
;;;1692   			LCD_DrawGroupBox((GROUP_T *)_pControl);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       LCD_DrawGroupBox
;;;1693   			break;
000046  bf00              NOP      
                  |L6.72|
000048  bf00              NOP                            ;1669
;;;1694   	}
;;;1695   }
00004a  bd70              POP      {r4-r6,pc}
;;;1696   
                          ENDP


                          AREA ||i.LCD_DispOff||, CODE, READONLY, ALIGN=2

                  LCD_DispOff PROC
;;;196    */
;;;197    void LCD_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;198    {
;;;199    	if (g_ChipID == IC_8875)
000002  4809              LDR      r0,|L7.40|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L7.16|
;;;200    	{
;;;201    		RA8875_DispOff();
00000a  f7fffffe          BL       RA8875_DispOff
00000e  e00a              B        |L7.38|
                  |L7.16|
;;;202    	}
;;;203    	else if (g_ChipID == IC_9488)
000010  4805              LDR      r0,|L7.40|
000012  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000014  f2494188          MOV      r1,#0x9488
000018  4288              CMP      r0,r1
00001a  d102              BNE      |L7.34|
;;;204    	{
;;;205    		ILI9488_DispOff();
00001c  f7fffffe          BL       ILI9488_DispOff
000020  e001              B        |L7.38|
                  |L7.34|
;;;206    	}
;;;207    	else	/* 61509, 5420, 4001 */
;;;208    	{
;;;209    		SPFD5420_DispOff();
000022  f7fffffe          BL       SPFD5420_DispOff
                  |L7.38|
;;;210    	}
;;;211    }
000026  bd10              POP      {r4,pc}
;;;212    
                          ENDP

                  |L7.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispOn||, CODE, READONLY, ALIGN=2

                  LCD_DispOn PROC
;;;172    */
;;;173    void LCD_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	if (g_ChipID == IC_8875)
000002  4809              LDR      r0,|L8.40|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L8.16|
;;;176    	{
;;;177    		RA8875_DispOn();
00000a  f7fffffe          BL       RA8875_DispOn
00000e  e00a              B        |L8.38|
                  |L8.16|
;;;178    	}
;;;179    	else if (g_ChipID == IC_9488)
000010  4805              LDR      r0,|L8.40|
000012  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000014  f2494188          MOV      r1,#0x9488
000018  4288              CMP      r0,r1
00001a  d102              BNE      |L8.34|
;;;180    	{
;;;181    		ILI9488_DispOn();
00001c  f7fffffe          BL       ILI9488_DispOn
000020  e001              B        |L8.38|
                  |L8.34|
;;;182    	}
;;;183    	else	/* 61509, 5420, 4001 */
;;;184    	{
;;;185    		SPFD5420_DispOn();
000022  f7fffffe          BL       SPFD5420_DispOn
                  |L8.38|
;;;186    	}
;;;187    }
000026  bd10              POP      {r4,pc}
;;;188    
                          ENDP

                  |L8.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispStr||, CODE, READONLY, ALIGN=2

                  LCD_DispStr PROC
;;;248    */	uint8_t font_width,font_height;uint8_t width;uint16_t font_bytes;
;;;249    void LCD_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;250    {
000004  f2ad4d9c          SUB      sp,sp,#0x49c
000008  4693              MOV      r11,r2
00000a  461d              MOV      r5,r3
;;;251    	uint32_t i;
;;;252    	uint8_t code1,t;
;;;253    	uint8_t code2;
;;;254    	uint32_t address = 0;
00000c  2700              MOVS     r7,#0
;;;255    	uint8_t buf[96 * 96 / 8];	/* 最大支持24点阵汉字 */
;;;256    	
;;;257    	uint16_t m;
;;;258    
;;;259    	uint16_t x, y;
;;;260    	const uint8_t *pAscDot;
;;;261    
;;;262    #ifdef USE_SMALL_FONT
;;;263    	const uint8_t *pHzDot;
;;;264    #else
;;;265    	uint32_t AddrHZK;
;;;266    #endif
;;;267    
;;;268    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;269    	if (_tFont->FontCode == FC_ST_12)
00000e  8828              LDRH     r0,[r5,#0]
000010  2801              CMP      r0,#1
000012  d10c              BNE      |L9.46|
;;;270    	{
;;;271    		font_height = 12;
000014  200c              MOVS     r0,#0xc
000016  49a2              LDR      r1,|L9.672|
000018  7008              STRB     r0,[r1,#0]
;;;272    		font_width = 12;
00001a  49a2              LDR      r1,|L9.676|
00001c  7008              STRB     r0,[r1,#0]
;;;273    		font_bytes = 24;
00001e  2018              MOVS     r0,#0x18
000020  49a1              LDR      r1,|L9.680|
000022  8008              STRH     r0,[r1,#0]
;;;274    		pAscDot = g_Ascii12;
000024  4ea1              LDR      r6,|L9.684|
;;;275    		t=2;
000026  f04f0802          MOV      r8,#2
;;;276    	#ifdef USE_SMALL_FONT
;;;277    		pHzDot = g_Hz12;
00002a  4ca1              LDR      r4,|L9.688|
00002c  e04d              B        |L9.202|
                  |L9.46|
;;;278    	#else
;;;279    		AddrHZK = HZK12_ADDR;
;;;280    	#endif
;;;281    	}
;;;282    	else if(_tFont->FontCode == FC_ST_24)
00002e  8828              LDRH     r0,[r5,#0]
000030  2802              CMP      r0,#2
000032  d10c              BNE      |L9.78|
;;;283    	{
;;;284    		font_height = 24;
000034  2018              MOVS     r0,#0x18
000036  499a              LDR      r1,|L9.672|
000038  7008              STRB     r0,[r1,#0]
;;;285    		font_width = 24;
00003a  499a              LDR      r1,|L9.676|
00003c  7008              STRB     r0,[r1,#0]
;;;286    		font_bytes = 72;
00003e  2048              MOVS     r0,#0x48
000040  4999              LDR      r1,|L9.680|
000042  8008              STRH     r0,[r1,#0]
;;;287    		pAscDot = g_Ascii24;
000044  4e9b              LDR      r6,|L9.692|
;;;288    		t=3;
000046  f04f0803          MOV      r8,#3
;;;289    	#ifdef USE_SMALL_FONT
;;;290    		pHzDot = g_HZK24;
00004a  4c9b              LDR      r4,|L9.696|
00004c  e03d              B        |L9.202|
                  |L9.78|
;;;291    	#else
;;;292    		AddrHZK = HZK12_ADDR;
;;;293    	#endif
;;;294    	}
;;;295    	else if(_tFont->FontCode == FC_ST_48)
00004e  8828              LDRH     r0,[r5,#0]
000050  2803              CMP      r0,#3
000052  d10d              BNE      |L9.112|
;;;296    	{
;;;297    		font_height = 48;
000054  2030              MOVS     r0,#0x30
000056  4992              LDR      r1,|L9.672|
000058  7008              STRB     r0,[r1,#0]
;;;298    		font_width = 48;
00005a  4992              LDR      r1,|L9.676|
00005c  7008              STRB     r0,[r1,#0]
;;;299    		font_bytes = 288;
00005e  f44f7090          MOV      r0,#0x120
000062  4991              LDR      r1,|L9.680|
000064  8008              STRH     r0,[r1,#0]
;;;300    		pAscDot = g_Ascii48;
000066  4e95              LDR      r6,|L9.700|
;;;301    		t=6;
000068  f04f0806          MOV      r8,#6
;;;302    	#ifdef USE_SMALL_FONT
;;;303    		pHzDot = g_Hz48;
00006c  4c94              LDR      r4,|L9.704|
00006e  e02c              B        |L9.202|
                  |L9.112|
;;;304    	#else
;;;305    		AddrHZK = HZK12_ADDR;
;;;306    	#endif
;;;307    	}
;;;308    	else if(_tFont->FontCode == FC_ST_64)
000070  8828              LDRH     r0,[r5,#0]
000072  2804              CMP      r0,#4
000074  d10c              BNE      |L9.144|
;;;309    	{
;;;310    		font_height = 64;
000076  2040              MOVS     r0,#0x40
000078  4989              LDR      r1,|L9.672|
00007a  7008              STRB     r0,[r1,#0]
;;;311    		font_width = 64;
00007c  4989              LDR      r1,|L9.676|
00007e  7008              STRB     r0,[r1,#0]
;;;312    		font_bytes = 512;
000080  00c0              LSLS     r0,r0,#3
000082  4989              LDR      r1,|L9.680|
000084  8008              STRH     r0,[r1,#0]
;;;313    		pAscDot = g_Ascii48;
000086  4e8d              LDR      r6,|L9.700|
;;;314    		t=8;
000088  f04f0808          MOV      r8,#8
;;;315    	#ifdef USE_SMALL_FONT
;;;316    		pHzDot = g_Hz64;
00008c  4c8d              LDR      r4,|L9.708|
00008e  e01c              B        |L9.202|
                  |L9.144|
;;;317    	#else
;;;318    		AddrHZK = HZK12_ADDR;
;;;319    	#endif
;;;320    	}
;;;321    	else if(_tFont->FontCode == FC_ST_96)
000090  8828              LDRH     r0,[r5,#0]
000092  2805              CMP      r0,#5
000094  d10d              BNE      |L9.178|
;;;322    	{
;;;323    		font_height = 96;
000096  2060              MOVS     r0,#0x60
000098  4981              LDR      r1,|L9.672|
00009a  7008              STRB     r0,[r1,#0]
;;;324    		font_width = 96;
00009c  4981              LDR      r1,|L9.676|
00009e  7008              STRB     r0,[r1,#0]
;;;325    		font_bytes = 1152;
0000a0  f44f6090          MOV      r0,#0x480
0000a4  4980              LDR      r1,|L9.680|
0000a6  8008              STRH     r0,[r1,#0]
;;;326    		pAscDot = g_Ascii48;
0000a8  4e84              LDR      r6,|L9.700|
;;;327    		t=12;
0000aa  f04f080c          MOV      r8,#0xc
;;;328    	#ifdef USE_SMALL_FONT
;;;329    		pHzDot = g_Hz96;
0000ae  4c86              LDR      r4,|L9.712|
0000b0  e00b              B        |L9.202|
                  |L9.178|
;;;330    	#else
;;;331    		AddrHZK = HZK12_ADDR;
;;;332    	#endif
;;;333    	}
;;;334    	else
;;;335    	{
;;;336    		/* 缺省是16点阵 */
;;;337    		font_height = 16;
0000b2  2010              MOVS     r0,#0x10
0000b4  497a              LDR      r1,|L9.672|
0000b6  7008              STRB     r0,[r1,#0]
;;;338    		font_width = 16;
0000b8  497a              LDR      r1,|L9.676|
0000ba  7008              STRB     r0,[r1,#0]
;;;339    		font_bytes = 32;
0000bc  2020              MOVS     r0,#0x20
0000be  497a              LDR      r1,|L9.680|
0000c0  8008              STRH     r0,[r1,#0]
;;;340    		pAscDot = g_Ascii16;
0000c2  4e82              LDR      r6,|L9.716|
;;;341    		t=2;
0000c4  f04f0802          MOV      r8,#2
;;;342    	#ifdef USE_SMALL_FONT
;;;343    		pHzDot = g_Hz16;
0000c8  4c81              LDR      r4,|L9.720|
                  |L9.202|
;;;344    	#else
;;;345    		AddrHZK = HZK16_ADDR;
;;;346    	#endif
;;;347    	}
;;;348    
;;;349    	/* 开始循环处理字符 */
;;;350    	while (*_ptr != 0)
0000ca  e0de              B        |L9.650|
                  |L9.204|
;;;351    	{
;;;352    		code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
0000cc  f89b9000          LDRB     r9,[r11,#0]
;;;353    		if (code1 < 0x80)
0000d0  f1b90f80          CMP      r9,#0x80
0000d4  da42              BGE      |L9.348|
;;;354    		{
;;;355    			/* 将ascii字符点阵复制到buf */
;;;356    			if(font_bytes == 72)
0000d6  4874              LDR      r0,|L9.680|
0000d8  8800              LDRH     r0,[r0,#0]  ; font_bytes
0000da  2848              CMP      r0,#0x48
0000dc  d10d              BNE      |L9.250|
;;;357    			{
;;;358    				memcpy(buf, &pAscDot[(code1-0x20) * 48], 48);
0000de  f1a90020          SUB      r0,r9,#0x20
0000e2  eb000040          ADD      r0,r0,r0,LSL #1
0000e6  eb061100          ADD      r1,r6,r0,LSL #4
0000ea  2230              MOVS     r2,#0x30
0000ec  a805              ADD      r0,sp,#0x14
0000ee  f7fffffe          BL       __aeabi_memcpy
;;;359    				width = 16;
0000f2  2010              MOVS     r0,#0x10
0000f4  4977              LDR      r1,|L9.724|
0000f6  7008              STRB     r0,[r1,#0]
0000f8  e06b              B        |L9.466|
                  |L9.250|
;;;360    			}
;;;361    			else if(font_bytes == 512)
0000fa  486b              LDR      r0,|L9.680|
0000fc  8800              LDRH     r0,[r0,#0]  ; font_bytes
0000fe  f5b07f00          CMP      r0,#0x200
000102  d10f              BNE      |L9.292|
;;;362    			{
;;;363    				memcpy(buf, &pAscDot[(code1-0x20) * 144], 144);
000104  f1a90020          SUB      r0,r9,#0x20
000108  eb0000c0          ADD      r0,r0,r0,LSL #3
00010c  eb061100          ADD      r1,r6,r0,LSL #4
000110  2290              MOVS     r2,#0x90
000112  a805              ADD      r0,sp,#0x14
000114  f7fffffe          BL       __aeabi_memcpy
;;;364    				width = 24;
000118  2018              MOVS     r0,#0x18
00011a  496e              LDR      r1,|L9.724|
00011c  7008              STRB     r0,[r1,#0]
;;;365    				t=6;
00011e  f04f0806          MOV      r8,#6
000122  e056              B        |L9.466|
                  |L9.292|
;;;366    			}
;;;367    			else 
;;;368    			{
;;;369    				memcpy(buf, &pAscDot[(code1-0x20) * (font_bytes / 2)], (font_bytes / 2));
000124  4860              LDR      r0,|L9.680|
000126  8800              LDRH     r0,[r0,#0]  ; font_bytes
000128  9002              STR      r0,[sp,#8]
00012a  485f              LDR      r0,|L9.680|
00012c  8800              LDRH     r0,[r0,#0]  ; font_bytes
00012e  9001              STR      r0,[sp,#4]
000130  eb0070d0          ADD      r0,r0,r0,LSR #31
000134  1043              ASRS     r3,r0,#1
000136  f1a90020          SUB      r0,r9,#0x20
00013a  fb006103          MLA      r1,r0,r3,r6
00013e  9802              LDR      r0,[sp,#8]
000140  eb0070d0          ADD      r0,r0,r0,LSR #31
000144  1042              ASRS     r2,r0,#1
000146  a805              ADD      r0,sp,#0x14
000148  f7fffffe          BL       __aeabi_memcpy
;;;370    				width = font_width / 2;
00014c  4955              LDR      r1,|L9.676|
00014e  7808              LDRB     r0,[r1,#0]  ; font_width
000150  eb0071d0          ADD      r1,r0,r0,LSR #31
000154  1049              ASRS     r1,r1,#1
000156  4a5f              LDR      r2,|L9.724|
000158  7011              STRB     r1,[r2,#0]
00015a  e03a              B        |L9.466|
                  |L9.348|
;;;371    			}
;;;372    		}
;;;373    		else
;;;374    		{
;;;375    			code2 = *++_ptr;
00015c  f10b0001          ADD      r0,r11,#1
000160  4683              MOV      r11,r0
000162  7800              LDRB     r0,[r0,#0]
000164  f8cd0494          STR      r0,[sp,#0x494]
;;;376    			if (code2 == 0)
000168  f8dd0494          LDR      r0,[sp,#0x494]
00016c  b900              CBNZ     r0,|L9.368|
;;;377    			{
;;;378    				break;
00016e  e091              B        |L9.660|
                  |L9.368|
;;;379    			}
;;;380    
;;;381    			/* 计算16点阵汉字点阵地址
;;;382    				ADDRESS = [(code1-0xa1) * 94 + (code2-0xa1)] * 32
;;;383    				;
;;;384    			*/
;;;385    			#ifdef USE_SMALL_FONT
;;;386    				m = 0;
000170  f04f0a00          MOV      r10,#0
;;;387    				while(1)
000174  e027              B        |L9.454|
                  |L9.374|
;;;388    				{
;;;389    					address = m * (font_bytes + 2);
000176  484c              LDR      r0,|L9.680|
000178  8800              LDRH     r0,[r0,#0]  ; font_bytes
00017a  1c80              ADDS     r0,r0,#2
00017c  fb0af700          MUL      r7,r10,r0
;;;390    					m++;
000180  f10a0001          ADD      r0,r10,#1
000184  fa1ffa80          UXTH     r10,r0
;;;391    					if ((code1 == pHzDot[address + 0]) && (code2 == pHzDot[address + 1]))
000188  5de0              LDRB     r0,[r4,r7]
00018a  4548              CMP      r0,r9
00018c  d10d              BNE      |L9.426|
00018e  1c78              ADDS     r0,r7,#1
000190  5c21              LDRB     r1,[r4,r0]
000192  f8dd0494          LDR      r0,[sp,#0x494]
000196  4281              CMP      r1,r0
000198  d107              BNE      |L9.426|
;;;392    					{
;;;393    						address += 2;
00019a  1cbf              ADDS     r7,r7,#2
;;;394    						memcpy(buf, &pHzDot[address], font_bytes);
00019c  19e1              ADDS     r1,r4,r7
00019e  4842              LDR      r0,|L9.680|
0001a0  8802              LDRH     r2,[r0,#0]  ; font_bytes
0001a2  a805              ADD      r0,sp,#0x14
0001a4  f7fffffe          BL       __aeabi_memcpy
;;;395    						break;
0001a8  e00e              B        |L9.456|
                  |L9.426|
;;;396    					}
;;;397    					else if ((pHzDot[address + 0] == 0xFF) && (pHzDot[address + 1] == 0xFF))
0001aa  5de0              LDRB     r0,[r4,r7]
0001ac  28ff              CMP      r0,#0xff
0001ae  d10a              BNE      |L9.454|
0001b0  1c78              ADDS     r0,r7,#1
0001b2  5c20              LDRB     r0,[r4,r0]
0001b4  28ff              CMP      r0,#0xff
0001b6  d106              BNE      |L9.454|
;;;398    					{
;;;399    						/* 字库搜索完毕，未找到，则填充全FF */
;;;400    						memset(buf, 0xFF, font_bytes);
0001b8  22ff              MOVS     r2,#0xff
0001ba  483b              LDR      r0,|L9.680|
0001bc  8801              LDRH     r1,[r0,#0]  ; font_bytes
0001be  a805              ADD      r0,sp,#0x14
0001c0  f7fffffe          BL       __aeabi_memset
;;;401    						break;
0001c4  e000              B        |L9.456|
                  |L9.454|
0001c6  e7d6              B        |L9.374|
                  |L9.456|
0001c8  bf00              NOP                            ;395
;;;402    					}
;;;403    				}
;;;404    			#else	/* 用全字库 */
;;;405    				/* 此处需要根据字库文件存放位置进行修改 */
;;;406    				if (code1 >=0xA1 && code1 <= 0xA9 && code2 >=0xA1)
;;;407    				{
;;;408    					address = ((code1 - 0xA1) * 94 + (code2 - 0xA1)) * font_bytes + AddrHZK;
;;;409    				}
;;;410    				else if (code1 >=0xB0 && code1 <= 0xF7 && code2 >=0xA1)
;;;411    				{
;;;412    					address = ((code1 - 0xB0) * 94 + (code2 - 0xA1) + 846) * font_bytes + AddrHZK;
;;;413    				}
;;;414    				memcpy(buf, (const uint8_t *)address, font_bytes);
;;;415    			#endif
;;;416    
;;;417    				width = font_width;
0001ca  4836              LDR      r0,|L9.676|
0001cc  7800              LDRB     r0,[r0,#0]  ; font_width
0001ce  4941              LDR      r1,|L9.724|
0001d0  7008              STRB     r0,[r1,#0]
                  |L9.466|
;;;418    		}
;;;419    
;;;420    		y = _usY;
0001d2  f8dd04a0          LDR      r0,[sp,#0x4a0]
0001d6  9003              STR      r0,[sp,#0xc]
;;;421    		/* 开始刷LCD */
;;;422    		for (m = 0; m < font_height; m++)	/* 字符高度 */
0001d8  f04f0a00          MOV      r10,#0
0001dc  e045              B        |L9.618|
                  |L9.478|
;;;423    		{
;;;424    			x = _usX;
0001de  f8dd049c          LDR      r0,[sp,#0x49c]
0001e2  9004              STR      r0,[sp,#0x10]
;;;425    			for (i = 0; i < width; i++)	/* 字符宽度 */
0001e4  2000              MOVS     r0,#0
0001e6  f8cd0498          STR      r0,[sp,#0x498]
0001ea  e030              B        |L9.590|
                  |L9.492|
;;;426    			{
;;;427    				if ((buf[m * ((t * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
0001ec  4839              LDR      r0,|L9.724|
0001ee  7800              LDRB     r0,[r0,#0]  ; width
0001f0  fb08f000          MUL      r0,r8,r0
0001f4  492b              LDR      r1,|L9.676|
0001f6  7809              LDRB     r1,[r1,#0]  ; font_width
0001f8  fb90f0f1          SDIV     r0,r0,r1
0001fc  fb00f00a          MUL      r0,r0,r10
000200  f8dd1498          LDR      r1,[sp,#0x498]
000204  eb0000d1          ADD      r0,r0,r1,LSR #3
000208  a905              ADD      r1,sp,#0x14
00020a  5c08              LDRB     r0,[r1,r0]
00020c  f8dd1498          LDR      r1,[sp,#0x498]
000210  f0010207          AND      r2,r1,#7
000214  2180              MOVS     r1,#0x80
000216  4111              ASRS     r1,r1,r2
000218  4008              ANDS     r0,r0,r1
00021a  b128              CBZ      r0,|L9.552|
;;;428    				{
;;;429    					LCD_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
00021c  886a              LDRH     r2,[r5,#2]
00021e  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000222  f7fffffe          BL       LCD_PutPixel
000226  e009              B        |L9.572|
                  |L9.552|
;;;430    				}
;;;431    				else
;;;432    				{
;;;433    					if (_tFont->BackColor != CL_MASK)	/* 透明色 */
000228  88a8              LDRH     r0,[r5,#4]
00022a  f6491199          MOV      r1,#0x9999
00022e  4288              CMP      r0,r1
000230  d004              BEQ      |L9.572|
;;;434    					{
;;;435    						LCD_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
000232  88aa              LDRH     r2,[r5,#4]
000234  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000238  f7fffffe          BL       LCD_PutPixel
                  |L9.572|
;;;436    					}
;;;437    				}
;;;438    
;;;439    				x++;
00023c  9804              LDR      r0,[sp,#0x10]
00023e  1c40              ADDS     r0,r0,#1
000240  b280              UXTH     r0,r0
000242  9004              STR      r0,[sp,#0x10]
000244  f8dd0498          LDR      r0,[sp,#0x498]        ;425
000248  1c40              ADDS     r0,r0,#1              ;425
00024a  f8cd0498          STR      r0,[sp,#0x498]        ;425
                  |L9.590|
00024e  4921              LDR      r1,|L9.724|
000250  7809              LDRB     r1,[r1,#0]            ;425  ; width
000252  f8dd0498          LDR      r0,[sp,#0x498]        ;425
000256  4288              CMP      r0,r1                 ;425
000258  d3c8              BCC      |L9.492|
;;;440    			}
;;;441    			y++;
00025a  9803              LDR      r0,[sp,#0xc]
00025c  1c40              ADDS     r0,r0,#1
00025e  b280              UXTH     r0,r0
000260  9003              STR      r0,[sp,#0xc]
000262  f10a0001          ADD      r0,r10,#1             ;422
000266  fa1ffa80          UXTH     r10,r0                ;422
                  |L9.618|
00026a  480d              LDR      r0,|L9.672|
00026c  7800              LDRB     r0,[r0,#0]            ;422  ; font_height
00026e  4582              CMP      r10,r0                ;422
000270  dbb5              BLT      |L9.478|
;;;442    		}
;;;443    
;;;444    		if (_tFont->Space > 0)
;;;445    		{
;;;446    			/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;447    		}
;;;448    		_usX += width + _tFont->Space;	/* 列地址递增 */
000272  88e8              LDRH     r0,[r5,#6]
000274  4917              LDR      r1,|L9.724|
000276  7809              LDRB     r1,[r1,#0]  ; width
000278  4401              ADD      r1,r1,r0
00027a  f8dd049c          LDR      r0,[sp,#0x49c]
00027e  4408              ADD      r0,r0,r1
000280  b280              UXTH     r0,r0
000282  f8cd049c          STR      r0,[sp,#0x49c]
;;;449    		_ptr++;			/* 指向下一个字符 */
000286  f10b0b01          ADD      r11,r11,#1
                  |L9.650|
00028a  f89b0000          LDRB     r0,[r11,#0]           ;350
00028e  2800              CMP      r0,#0                 ;350
000290  f47faf1c          BNE      |L9.204|
                  |L9.660|
000294  bf00              NOP                            ;378
;;;450    	}
;;;451    }
000296  f20d4dac          ADD      sp,sp,#0x4ac
00029a  e8bd8ff0          POP      {r4-r11,pc}
;;;452    
                          ENDP

00029e  0000              DCW      0x0000
                  |L9.672|
                          DCD      font_height
                  |L9.676|
                          DCD      font_width
                  |L9.680|
                          DCD      font_bytes
                  |L9.684|
                          DCD      g_Ascii12
                  |L9.688|
                          DCD      g_Hz12
                  |L9.692|
                          DCD      g_Ascii24
                  |L9.696|
                          DCD      g_HZK24
                  |L9.700|
                          DCD      g_Ascii48
                  |L9.704|
                          DCD      g_Hz48
                  |L9.708|
                          DCD      g_Hz64
                  |L9.712|
                          DCD      g_Hz96
                  |L9.716|
                          DCD      g_Ascii16
                  |L9.720|
                          DCD      g_Hz16
                  |L9.724|
                          DCD      width

                          AREA ||i.LCD_DispStrEx||, CODE, READONLY, ALIGN=2

                  LCD_DispStrEx PROC
;;;562    */
;;;563    void LCD_DispStrEx(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont, uint16_t _Width,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;564    	uint8_t _Align)
;;;565    {
000004  b09f              SUB      sp,sp,#0x7c
000006  4683              MOV      r11,r0
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;566    	uint32_t i;
;;;567    	uint8_t code1;
;;;568    	uint8_t code2;
;;;569    	uint32_t address = 0;
00000c  2600              MOVS     r6,#0
;;;570    	uint8_t buf[24 * 24 / 8];	/* 最大支持24点阵汉字 */
;;;571    	uint8_t width;
;;;572    	uint16_t m;
;;;573    	uint8_t font_width,font_height, font_bytes;
;;;574    	uint16_t x, y;
;;;575    	const uint8_t *pAscDot;
;;;576    	uint16_t offset;
;;;577    	uint16_t str_width;	/* 字符串实际宽度  */
;;;578    
;;;579    #ifdef USE_SMALL_FONT
;;;580    	const uint8_t *pHzDot;
;;;581    #else
;;;582    	uint32_t AddrHZK;
;;;583    #endif
;;;584    
;;;585    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;586    	if (_tFont->FontCode == FC_ST_12)
00000e  8820              LDRH     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d108              BNE      |L10.38|
;;;587    	{
;;;588    		font_height = 12;
000014  200c              MOVS     r0,#0xc
000016  9007              STR      r0,[sp,#0x1c]
;;;589    		font_width = 12;
000018  4682              MOV      r10,r0
;;;590    		font_bytes = 24;
00001a  2518              MOVS     r5,#0x18
;;;591    		pAscDot = g_Ascii12;
00001c  487d              LDR      r0,|L10.532|
00001e  9004              STR      r0,[sp,#0x10]
;;;592    
;;;593    	#ifdef USE_SMALL_FONT
;;;594    		pHzDot = g_Hz12;
000020  f8df81f4          LDR      r8,|L10.536|
000024  e007              B        |L10.54|
                  |L10.38|
;;;595    	#else
;;;596    		AddrHZK = HZK12_ADDR;
;;;597    	#endif
;;;598    	}
;;;599    	else
;;;600    	{
;;;601    		/* 缺省是16点阵 */
;;;602    		font_height = 16;
000026  2010              MOVS     r0,#0x10
000028  9007              STR      r0,[sp,#0x1c]
;;;603    		font_width = 16;
00002a  4682              MOV      r10,r0
;;;604    		font_bytes = 32;
00002c  2520              MOVS     r5,#0x20
;;;605    		pAscDot = g_Ascii16;
00002e  487b              LDR      r0,|L10.540|
000030  9004              STR      r0,[sp,#0x10]
;;;606    
;;;607    	#ifdef USE_SMALL_FONT
;;;608    		pHzDot = g_Hz16;
000032  f8df81ec          LDR      r8,|L10.544|
                  |L10.54|
;;;609    	#else
;;;610    		AddrHZK = HZK16_ADDR;
;;;611    	#endif
;;;612    	}
;;;613    
;;;614    	str_width = LCD_GetStrWidth(_ptr, _tFont);	/* 计算字符串实际宽度 */
000036  4621              MOV      r1,r4
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       LCD_GetStrWidth
00003e  4607              MOV      r7,r0
;;;615    	offset = 0;
000040  2000              MOVS     r0,#0
000042  9003              STR      r0,[sp,#0xc]
;;;616    	if (_Width > str_width)
000044  992c              LDR      r1,[sp,#0xb0]
000046  42b9              CMP      r1,r7
000048  dd11              BLE      |L10.110|
;;;617    	{
;;;618    		if (_Align == ALIGN_RIGHT)	/* 右对齐 */
00004a  982d              LDR      r0,[sp,#0xb4]
00004c  2802              CMP      r0,#2
00004e  d104              BNE      |L10.90|
;;;619    		{
;;;620    			offset = _Width - str_width;
000050  982c              LDR      r0,[sp,#0xb0]
000052  1bc0              SUBS     r0,r0,r7
000054  b280              UXTH     r0,r0
000056  9003              STR      r0,[sp,#0xc]
000058  e009              B        |L10.110|
                  |L10.90|
;;;621    		}
;;;622    		else if (_Align == ALIGN_CENTER)	/* 左对齐 */
00005a  982d              LDR      r0,[sp,#0xb4]
00005c  2801              CMP      r0,#1
00005e  d106              BNE      |L10.110|
;;;623    		{
;;;624    			offset = (_Width - str_width) / 2;
000060  992c              LDR      r1,[sp,#0xb0]
000062  1bc8              SUBS     r0,r1,r7
000064  eb0071d0          ADD      r1,r0,r0,LSR #31
000068  f3c1014f          UBFX     r1,r1,#1,#16
00006c  9103              STR      r1,[sp,#0xc]
                  |L10.110|
;;;625    		}
;;;626    		else	/* 左对齐 ALIGN_LEFT */
;;;627    		{
;;;628    			;
;;;629    		}
;;;630    	}
;;;631    
;;;632    	/* 左侧填背景色, 中间对齐和右边对齐  */
;;;633    	if (offset > 0)
00006e  9803              LDR      r0,[sp,#0xc]
000070  2800              CMP      r0,#0
000072  dd0f              BLE      |L10.148|
;;;634    	{
;;;635    		LCD_Fill_Rect(_usX, _usY, LCD_GetFontHeight(_tFont), offset,  _tFont->BackColor);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       LCD_GetFontHeight
00007a  9002              STR      r0,[sp,#8]
00007c  88a0              LDRH     r0,[r4,#4]
00007e  9000              STR      r0,[sp,#0]
000080  4658              MOV      r0,r11
000082  e9dd2302          LDRD     r2,r3,[sp,#8]
000086  9920              LDR      r1,[sp,#0x80]
000088  f7fffffe          BL       LCD_Fill_Rect
;;;636    		_usX += offset;
00008c  9803              LDR      r0,[sp,#0xc]
00008e  4458              ADD      r0,r0,r11
000090  fa1ffb80          UXTH     r11,r0
                  |L10.148|
;;;637    	}
;;;638    	/* 右侧填背景色 */
;;;639    	if (_Width > str_width)
000094  982c              LDR      r0,[sp,#0xb0]
000096  42b8              CMP      r0,r7
000098  dd11              BLE      |L10.190|
;;;640    	{
;;;641    		LCD_Fill_Rect(_usX + str_width, _usY, LCD_GetFontHeight(_tFont), _Width - str_width - offset,  _tFont->BackColor);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       LCD_GetFontHeight
0000a0  9002              STR      r0,[sp,#8]
0000a2  88a0              LDRH     r0,[r4,#4]
0000a4  9000              STR      r0,[sp,#0]
0000a6  992c              LDR      r1,[sp,#0xb0]
0000a8  1bca              SUBS     r2,r1,r7
0000aa  9903              LDR      r1,[sp,#0xc]
0000ac  1a51              SUBS     r1,r2,r1
0000ae  b28b              UXTH     r3,r1
0000b0  eb0b0107          ADD      r1,r11,r7
0000b4  b288              UXTH     r0,r1
0000b6  9a02              LDR      r2,[sp,#8]
0000b8  9920              LDR      r1,[sp,#0x80]
0000ba  f7fffffe          BL       LCD_Fill_Rect
                  |L10.190|
;;;642    	}
;;;643    
;;;644    	/* 开始循环处理字符 */
;;;645    	while (*_ptr != 0)
0000be  e0a0              B        |L10.514|
                  |L10.192|
;;;646    	{
;;;647    		code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
0000c0  f8990000          LDRB     r0,[r9,#0]
0000c4  901d              STR      r0,[sp,#0x74]
;;;648    		if (code1 < 0x80)
0000c6  981d              LDR      r0,[sp,#0x74]
0000c8  2880              CMP      r0,#0x80
0000ca  da16              BGE      |L10.250|
;;;649    		{
;;;650    			/* 将ascii字符点阵复制到buf */
;;;651    			memcpy(buf, &pAscDot[code1 * (font_bytes / 2)], (font_bytes / 2));
0000cc  9502              STR      r5,[sp,#8]
0000ce  eb0570d5          ADD      r0,r5,r5,LSR #31
0000d2  ea4f0c60          ASR      r12,r0,#1
0000d6  9501              STR      r5,[sp,#4]
0000d8  9b1d              LDR      r3,[sp,#0x74]
0000da  9804              LDR      r0,[sp,#0x10]
0000dc  fb03010c          MLA      r1,r3,r12,r0
0000e0  eb0570d5          ADD      r0,r5,r5,LSR #31
0000e4  1042              ASRS     r2,r0,#1
0000e6  a80a              ADD      r0,sp,#0x28
0000e8  f7fffffe          BL       __aeabi_memcpy
;;;652    			width = font_width / 2;
0000ec  4650              MOV      r0,r10
0000ee  eb0a71d0          ADD      r1,r10,r0,LSR #31
0000f2  f3c10147          UBFX     r1,r1,#1,#8
0000f6  9109              STR      r1,[sp,#0x24]
0000f8  e038              B        |L10.364|
                  |L10.250|
;;;653    		}
;;;654    		else
;;;655    		{
;;;656    			code2 = *++_ptr;
0000fa  f1090001          ADD      r0,r9,#1
0000fe  4681              MOV      r9,r0
000100  7800              LDRB     r0,[r0,#0]
000102  901c              STR      r0,[sp,#0x70]
;;;657    			if (code2 == 0)
000104  981c              LDR      r0,[sp,#0x70]
000106  b900              CBNZ     r0,|L10.266|
;;;658    			{
;;;659    				break;
000108  e080              B        |L10.524|
                  |L10.266|
;;;660    			}
;;;661    
;;;662    			/* 计算16点阵汉字点阵地址
;;;663    				ADDRESS = [(code1-0xa1) * 94 + (code2-0xa1)] * 32
;;;664    				;
;;;665    			*/
;;;666    			#ifdef USE_SMALL_FONT
;;;667    				m = 0;
00010a  2000              MOVS     r0,#0
00010c  9008              STR      r0,[sp,#0x20]
;;;668    				while(1)
00010e  e029              B        |L10.356|
                  |L10.272|
;;;669    				{
;;;670    					address = m * (font_bytes + 2);
000110  1ca9              ADDS     r1,r5,#2
000112  9808              LDR      r0,[sp,#0x20]
000114  fb00f601          MUL      r6,r0,r1
;;;671    					m++;
000118  9808              LDR      r0,[sp,#0x20]
00011a  1c40              ADDS     r0,r0,#1
00011c  b280              UXTH     r0,r0
00011e  9008              STR      r0,[sp,#0x20]
;;;672    					if ((code1 == pHzDot[address + 0]) && (code2 == pHzDot[address + 1]))
000120  f8181006          LDRB     r1,[r8,r6]
000124  981d              LDR      r0,[sp,#0x74]
000126  4281              CMP      r1,r0
000128  d10d              BNE      |L10.326|
00012a  1c70              ADDS     r0,r6,#1
00012c  f8181000          LDRB     r1,[r8,r0]
000130  981c              LDR      r0,[sp,#0x70]
000132  4281              CMP      r1,r0
000134  d107              BNE      |L10.326|
;;;673    					{
;;;674    						address += 2;
000136  1cb6              ADDS     r6,r6,#2
;;;675    						memcpy(buf, &pHzDot[address], font_bytes);
000138  eb080106          ADD      r1,r8,r6
00013c  462a              MOV      r2,r5
00013e  a80a              ADD      r0,sp,#0x28
000140  f7fffffe          BL       __aeabi_memcpy
;;;676    						break;
000144  e00f              B        |L10.358|
                  |L10.326|
;;;677    					}
;;;678    					else if ((pHzDot[address + 0] == 0xFF) && (pHzDot[address + 1] == 0xFF))
000146  f8180006          LDRB     r0,[r8,r6]
00014a  28ff              CMP      r0,#0xff
00014c  d10a              BNE      |L10.356|
00014e  1c70              ADDS     r0,r6,#1
000150  f8180000          LDRB     r0,[r8,r0]
000154  28ff              CMP      r0,#0xff
000156  d105              BNE      |L10.356|
;;;679    					{
;;;680    						/* 字库搜索完毕，未找到，则填充全FF */
;;;681    						memset(buf, 0xFF, font_bytes);
000158  22ff              MOVS     r2,#0xff
00015a  4629              MOV      r1,r5
00015c  a80a              ADD      r0,sp,#0x28
00015e  f7fffffe          BL       __aeabi_memset
;;;682    						break;
000162  e000              B        |L10.358|
                  |L10.356|
000164  e7d4              B        |L10.272|
                  |L10.358|
000166  bf00              NOP                            ;676
;;;683    					}
;;;684    				}
;;;685    			#else	/* 用全字库 */
;;;686    				/* 此处需要根据字库文件存放位置进行修改 */
;;;687    				if (code1 >=0xA1 && code1 <= 0xA9 && code2 >=0xA1)
;;;688    				{
;;;689    					address = ((code1 - 0xA1) * 94 + (code2 - 0xA1)) * font_bytes + AddrHZK;
;;;690    				}
;;;691    				else if (code1 >=0xB0 && code1 <= 0xF7 && code2 >=0xA1)
;;;692    				{
;;;693    					address = ((code1 - 0xB0) * 94 + (code2 - 0xA1) + 846) * font_bytes + AddrHZK;
;;;694    				}
;;;695    				memcpy(buf, (const uint8_t *)address, font_bytes);
;;;696    			#endif
;;;697    
;;;698    				width = font_width;
000168  f8cda024          STR      r10,[sp,#0x24]
                  |L10.364|
;;;699    		}
;;;700    
;;;701    		y = _usY;
00016c  9820              LDR      r0,[sp,#0x80]
00016e  9005              STR      r0,[sp,#0x14]
;;;702    		/* 开始刷LCD */
;;;703    		for (m = 0; m < font_height; m++)	/* 字符高度 */
000170  2000              MOVS     r0,#0
000172  9008              STR      r0,[sp,#0x20]
000174  e039              B        |L10.490|
                  |L10.374|
;;;704    		{
;;;705    			x = _usX;
000176  f8cdb018          STR      r11,[sp,#0x18]
;;;706    			for (i = 0; i < width; i++)	/* 字符宽度 */
00017a  2000              MOVS     r0,#0
00017c  901e              STR      r0,[sp,#0x78]
00017e  e028              B        |L10.466|
                  |L10.384|
;;;707    			{
;;;708    				if ((buf[m * ((2 * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
000180  9809              LDR      r0,[sp,#0x24]
000182  0040              LSLS     r0,r0,#1
000184  fb90f0fa          SDIV     r0,r0,r10
000188  9908              LDR      r1,[sp,#0x20]
00018a  4348              MULS     r0,r1,r0
00018c  991e              LDR      r1,[sp,#0x78]
00018e  eb0000d1          ADD      r0,r0,r1,LSR #3
000192  a90a              ADD      r1,sp,#0x28
000194  5c08              LDRB     r0,[r1,r0]
000196  991e              LDR      r1,[sp,#0x78]
000198  f0010207          AND      r2,r1,#7
00019c  2180              MOVS     r1,#0x80
00019e  4111              ASRS     r1,r1,r2
0001a0  4008              ANDS     r0,r0,r1
0001a2  b128              CBZ      r0,|L10.432|
;;;709    				{
;;;710    					LCD_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
0001a4  8862              LDRH     r2,[r4,#2]
0001a6  e9dd1005          LDRD     r1,r0,[sp,#0x14]
0001aa  f7fffffe          BL       LCD_PutPixel
0001ae  e009              B        |L10.452|
                  |L10.432|
;;;711    				}
;;;712    				else
;;;713    				{
;;;714    					if (_tFont->BackColor != CL_MASK)	/* 透明色 */
0001b0  88a0              LDRH     r0,[r4,#4]
0001b2  f6491199          MOV      r1,#0x9999
0001b6  4288              CMP      r0,r1
0001b8  d004              BEQ      |L10.452|
;;;715    					{
;;;716    						LCD_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
0001ba  88a2              LDRH     r2,[r4,#4]
0001bc  e9dd1005          LDRD     r1,r0,[sp,#0x14]
0001c0  f7fffffe          BL       LCD_PutPixel
                  |L10.452|
;;;717    					}
;;;718    				}
;;;719    
;;;720    				x++;
0001c4  9806              LDR      r0,[sp,#0x18]
0001c6  1c40              ADDS     r0,r0,#1
0001c8  b280              UXTH     r0,r0
0001ca  9006              STR      r0,[sp,#0x18]
0001cc  981e              LDR      r0,[sp,#0x78]         ;706
0001ce  1c40              ADDS     r0,r0,#1              ;706
0001d0  901e              STR      r0,[sp,#0x78]         ;706
                  |L10.466|
0001d2  9909              LDR      r1,[sp,#0x24]         ;706
0001d4  981e              LDR      r0,[sp,#0x78]         ;706
0001d6  4288              CMP      r0,r1                 ;706
0001d8  d3d2              BCC      |L10.384|
;;;721    			}
;;;722    			y++;
0001da  9805              LDR      r0,[sp,#0x14]
0001dc  1c40              ADDS     r0,r0,#1
0001de  b280              UXTH     r0,r0
0001e0  9005              STR      r0,[sp,#0x14]
0001e2  9808              LDR      r0,[sp,#0x20]         ;703
0001e4  1c40              ADDS     r0,r0,#1              ;703
0001e6  b280              UXTH     r0,r0                 ;703
0001e8  9008              STR      r0,[sp,#0x20]         ;703
                  |L10.490|
0001ea  e9dd1007          LDRD     r1,r0,[sp,#0x1c]      ;703
0001ee  4288              CMP      r0,r1                 ;703
0001f0  dbc1              BLT      |L10.374|
;;;723    		}
;;;724    
;;;725    		if (_tFont->Space > 0)
;;;726    		{
;;;727    			/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;728    		}
;;;729    		_usX += width + _tFont->Space;	/* 列地址递增 */
0001f2  88e1              LDRH     r1,[r4,#6]
0001f4  9809              LDR      r0,[sp,#0x24]
0001f6  4408              ADD      r0,r0,r1
0001f8  4458              ADD      r0,r0,r11
0001fa  fa1ffb80          UXTH     r11,r0
;;;730    		_ptr++;			/* 指向下一个字符 */
0001fe  f1090901          ADD      r9,r9,#1
                  |L10.514|
000202  f8990000          LDRB     r0,[r9,#0]            ;645
000206  2800              CMP      r0,#0                 ;645
000208  f47faf5a          BNE      |L10.192|
                  |L10.524|
00020c  bf00              NOP                            ;659
;;;731    	}
;;;732    }
00020e  b023              ADD      sp,sp,#0x8c
000210  e8bd8ff0          POP      {r4-r11,pc}
;;;733    
                          ENDP

                  |L10.532|
                          DCD      g_Ascii12
                  |L10.536|
                          DCD      g_Hz12
                  |L10.540|
                          DCD      g_Ascii16
                  |L10.544|
                          DCD      g_Hz16

                          AREA ||i.LCD_DrawBMP||, CODE, READONLY, ALIGN=2

                  LCD_DrawBMP PROC
;;;932    */
;;;933    void LCD_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;934    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;935    	if (g_ChipID == IC_8875)
00000e  4811              LDR      r0,|L11.84|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L11.38|
;;;936    	{
;;;937    		RA8875_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawBMP
000024  e014              B        |L11.80|
                  |L11.38|
;;;938    	}
;;;939    	else if (g_ChipID == IC_9488)
000026  480b              LDR      r0,|L11.84|
000028  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00002a  f2494188          MOV      r1,#0x9488
00002e  4288              CMP      r0,r1
000030  d107              BNE      |L11.66|
;;;940    	{
;;;941    		ILI9488_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000032  4643              MOV      r3,r8
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  9400              STR      r4,[sp,#0]
00003c  f7fffffe          BL       ILI9488_DrawBMP
000040  e006              B        |L11.80|
                  |L11.66|
;;;942    	}
;;;943    	else
;;;944    	{
;;;945    		SPFD5420_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000042  4643              MOV      r3,r8
000044  463a              MOV      r2,r7
000046  4631              MOV      r1,r6
000048  4628              MOV      r0,r5
00004a  9400              STR      r4,[sp,#0]
00004c  f7fffffe          BL       SPFD5420_DrawBMP
                  |L11.80|
;;;946    	}
;;;947    }
000050  e8bd83f8          POP      {r3-r9,pc}
;;;948    
                          ENDP

                  |L11.84|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawBmp32||, CODE, READONLY, ALIGN=1

                  LCD_DrawBmp32 PROC
;;;1248   */
;;;1249   void LCD_DrawBmp32(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t *_pBmp)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1250   {
000004  b087              SUB      sp,sp,#0x1c
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;1251   	const uint8_t *p;
;;;1252   	uint16_t usOldRGB, usNewRGB;
;;;1253   	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1254   	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;1255   	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;1256   
;;;1257   	p = (const uint8_t *)_pBmp;
00000a  9c14              LDR      r4,[sp,#0x50]
;;;1258   	p += 54;		/* 直接指向图像数据区 */
00000c  3436              ADDS     r4,r4,#0x36
;;;1259   
;;;1260   	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;1261   	for (y = _usHeight - 1; y >= 0; y--)
00000e  9809              LDR      r0,[sp,#0x24]
000010  1e40              SUBS     r0,r0,#1
000012  b207              SXTH     r7,r0
000014  e081              B        |L12.282|
                  |L12.22|
;;;1262   	{
;;;1263   		for (x = 0; x < _usWidth; x++)
000016  2600              MOVS     r6,#0
000018  e07a              B        |L12.272|
                  |L12.26|
;;;1264   		{
;;;1265   			B1 = *p++;
00001a  f8140b01          LDRB     r0,[r4],#1
00001e  9004              STR      r0,[sp,#0x10]
;;;1266   			G1 = *p++;
000020  f8140b01          LDRB     r0,[r4],#1
000024  9005              STR      r0,[sp,#0x14]
;;;1267   			R1 = *p++;
000026  f814bb01          LDRB     r11,[r4],#1
;;;1268   			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002a  f8145b01          LDRB     r5,[r4],#1
;;;1269   
;;;1270   			if (A == 0x00)	/* 需要透明,显示背景 */
00002e  2d00              CMP      r5,#0
000030  d06c              BEQ      |L12.268|
;;;1271   			{
;;;1272   				;	/* 不用刷新背景 */
;;;1273   			}
;;;1274   			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000032  2dff              CMP      r5,#0xff
000034  d114              BNE      |L12.96|
;;;1275   			{
;;;1276   				usNewRGB = RGB(R1, G1, B1);
000036  ea4f00eb          ASR      r0,r11,#3
00003a  02c1              LSLS     r1,r0,#11
00003c  9805              LDR      r0,[sp,#0x14]
00003e  1080              ASRS     r0,r0,#2
000040  ea411140          ORR      r1,r1,r0,LSL #5
000044  9804              LDR      r0,[sp,#0x10]
000046  ea4100e0          ORR      r0,r1,r0,ASR #3
00004a  9006              STR      r0,[sp,#0x18]
;;;1277   				//if (_ucFocusMode == 1)
;;;1278   				//{
;;;1279   				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;1280   				//}
;;;1281   				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
00004c  eb070209          ADD      r2,r7,r9
000050  b291              UXTH     r1,r2
000052  eb060208          ADD      r2,r6,r8
000056  b290              UXTH     r0,r2
000058  9a06              LDR      r2,[sp,#0x18]
00005a  f7fffffe          BL       LCD_PutPixel
00005e  e055              B        |L12.268|
                  |L12.96|
;;;1282   			}
;;;1283   			else 	/* 半透明 */
;;;1284   			{
;;;1285   				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;1286   				usOldRGB = LCD_GetPixel(x + _usX, y + _usY);
000060  eb070209          ADD      r2,r7,r9
000064  b291              UXTH     r1,r2
000066  eb060208          ADD      r2,r6,r8
00006a  b290              UXTH     r0,r2
00006c  f7fffffe          BL       LCD_GetPixel
000070  4682              MOV      r10,r0
;;;1287   				R0 = RGB565_R(usOldRGB);
000072  20f8              MOVS     r0,#0xf8
000074  ea00202a          AND      r0,r0,r10,ASR #8
000078  9003              STR      r0,[sp,#0xc]
;;;1288   				G0 = RGB565_G(usOldRGB);
00007a  20fc              MOVS     r0,#0xfc
00007c  ea0000ea          AND      r0,r0,r10,ASR #3
000080  9002              STR      r0,[sp,#8]
;;;1289   				B0 = RGB565_B(usOldRGB);
000082  20f8              MOVS     r0,#0xf8
000084  ea0000ca          AND      r0,r0,r10,LSL #3
000088  9001              STR      r0,[sp,#4]
;;;1290   
;;;1291   				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
00008a  fb0bf005          MUL      r0,r11,r5
00008e  21ff              MOVS     r1,#0xff
000090  fb90f2f1          SDIV     r2,r0,r1
000094  f1c501ff          RSB      r1,r5,#0xff
000098  9803              LDR      r0,[sp,#0xc]
00009a  4341              MULS     r1,r0,r1
00009c  20ff              MOVS     r0,#0xff
00009e  fb91f0f0          SDIV     r0,r1,r0
0000a2  4410              ADD      r0,r0,r2
0000a4  f0000bff          AND      r11,r0,#0xff
;;;1292   				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000a8  9805              LDR      r0,[sp,#0x14]
0000aa  4368              MULS     r0,r5,r0
0000ac  21ff              MOVS     r1,#0xff
0000ae  fb90f2f1          SDIV     r2,r0,r1
0000b2  f1c501ff          RSB      r1,r5,#0xff
0000b6  9802              LDR      r0,[sp,#8]
0000b8  4341              MULS     r1,r0,r1
0000ba  20ff              MOVS     r0,#0xff
0000bc  fb91f0f0          SDIV     r0,r1,r0
0000c0  4410              ADD      r0,r0,r2
0000c2  b2c0              UXTB     r0,r0
0000c4  9005              STR      r0,[sp,#0x14]
;;;1293   				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000c6  9804              LDR      r0,[sp,#0x10]
0000c8  4368              MULS     r0,r5,r0
0000ca  21ff              MOVS     r1,#0xff
0000cc  fb90f2f1          SDIV     r2,r0,r1
0000d0  f1c501ff          RSB      r1,r5,#0xff
0000d4  9801              LDR      r0,[sp,#4]
0000d6  4341              MULS     r1,r0,r1
0000d8  20ff              MOVS     r0,#0xff
0000da  fb91f0f0          SDIV     r0,r1,r0
0000de  4410              ADD      r0,r0,r2
0000e0  b2c0              UXTB     r0,r0
0000e2  9004              STR      r0,[sp,#0x10]
;;;1294   				usNewRGB = RGB(R1, G1, B1);
0000e4  ea4f00eb          ASR      r0,r11,#3
0000e8  02c1              LSLS     r1,r0,#11
0000ea  9805              LDR      r0,[sp,#0x14]
0000ec  1080              ASRS     r0,r0,#2
0000ee  ea411140          ORR      r1,r1,r0,LSL #5
0000f2  9804              LDR      r0,[sp,#0x10]
0000f4  ea4100e0          ORR      r0,r1,r0,ASR #3
0000f8  9006              STR      r0,[sp,#0x18]
;;;1295   				//if (_ucFocusMode == 1)
;;;1296   				//{
;;;1297   				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;1298   				//}
;;;1299   				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
0000fa  eb070209          ADD      r2,r7,r9
0000fe  b291              UXTH     r1,r2
000100  eb060208          ADD      r2,r6,r8
000104  b290              UXTH     r0,r2
000106  9a06              LDR      r2,[sp,#0x18]
000108  f7fffffe          BL       LCD_PutPixel
                  |L12.268|
00010c  1c70              ADDS     r0,r6,#1              ;1263
00010e  b206              SXTH     r6,r0                 ;1263
                  |L12.272|
000110  980a              LDR      r0,[sp,#0x28]         ;1263
000112  4286              CMP      r6,r0                 ;1263
000114  db81              BLT      |L12.26|
000116  1e78              SUBS     r0,r7,#1              ;1261
000118  b207              SXTH     r7,r0                 ;1261
                  |L12.282|
00011a  2f00              CMP      r7,#0                 ;1261
00011c  f6bfaf7b          BGE      |L12.22|
;;;1300   			}
;;;1301   		}
;;;1302   	}
;;;1303   }
000120  b00b              ADD      sp,sp,#0x2c
000122  e8bd8ff0          POP      {r4-r11,pc}
;;;1304   
                          ENDP


                          AREA ||i.LCD_DrawButton||, CODE, READONLY, ALIGN=1

                  LCD_DrawButton PROC
;;;1497   */
;;;1498   void LCD_DrawButton(BUTTON_T *_pBtn)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1499   {
000004  4604              MOV      r4,r0
;;;1500   #if 1
;;;1501   		uint16_t len, fwidth, x, y;
;;;1502   
;;;1503   		if (_pBtn->Focus == 1)
000006  7d20              LDRB     r0,[r4,#0x14]
000008  2801              CMP      r0,#1
00000a  d15f              BNE      |L13.204|
;;;1504   		{
;;;1505   			/* 仿XP风格，平面编辑框 */
;;;1506   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
00000c  2010              MOVS     r0,#0x10
00000e  9000              STR      r0,[sp,#0]
000010  8923              LDRH     r3,[r4,#8]
000012  88e2              LDRH     r2,[r4,#6]
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  f7fffffe          BL       LCD_DrawRect
;;;1507   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
00001c  f64f70ff          MOV      r0,#0xffff
000020  9000              STR      r0,[sp,#0]
000022  f8b4c008          LDRH     r12,[r4,#8]
000026  f1ac0c02          SUB      r12,r12,#2
00002a  fa1ff38c          UXTH     r3,r12
00002e  f8b4c006          LDRH     r12,[r4,#6]
000032  f1ac0c02          SUB      r12,r12,#2
000036  fa1ff28c          UXTH     r2,r12
00003a  f8b4c004          LDRH     r12,[r4,#4]
00003e  f10c0c01          ADD      r12,r12,#1
000042  fa1ff18c          UXTH     r1,r12
000046  f8b4c002          LDRH     r12,[r4,#2]
00004a  f10c0c01          ADD      r12,r12,#1
00004e  fa1ff08c          UXTH     r0,r12
000052  f7fffffe          BL       LCD_DrawRect
;;;1508   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000056  f24940b2          MOV      r0,#0x94b2
00005a  9000              STR      r0,[sp,#0]
00005c  f8b4c008          LDRH     r12,[r4,#8]
000060  f1ac0c04          SUB      r12,r12,#4
000064  fa1ff38c          UXTH     r3,r12
000068  f8b4c006          LDRH     r12,[r4,#6]
00006c  f1ac0c04          SUB      r12,r12,#4
000070  fa1ff28c          UXTH     r2,r12
000074  f8b4c004          LDRH     r12,[r4,#4]
000078  f10c0c02          ADD      r12,r12,#2
00007c  fa1ff18c          UXTH     r1,r12
000080  f8b4c002          LDRH     r12,[r4,#2]
000084  f10c0c02          ADD      r12,r12,#2
000088  fa1ff08c          UXTH     r0,r12
00008c  f7fffffe          BL       LCD_DrawRect
;;;1509   
;;;1510   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);	/* 选中后的底色 */
000090  f64770ff          MOV      r0,#0x7fff
000094  9000              STR      r0,[sp,#0]
000096  f8b4c008          LDRH     r12,[r4,#8]
00009a  f1ac0c06          SUB      r12,r12,#6
00009e  fa1ff38c          UXTH     r3,r12
0000a2  f8b4c006          LDRH     r12,[r4,#6]
0000a6  f1ac0c06          SUB      r12,r12,#6
0000aa  fa1ff28c          UXTH     r2,r12
0000ae  f8b4c004          LDRH     r12,[r4,#4]
0000b2  f10c0c03          ADD      r12,r12,#3
0000b6  fa1ff18c          UXTH     r1,r12
0000ba  f8b4c002          LDRH     r12,[r4,#2]
0000be  f10c0c03          ADD      r12,r12,#3
0000c2  fa1ff08c          UXTH     r0,r12
0000c6  f7fffffe          BL       LCD_Fill_Rect
0000ca  e05e              B        |L13.394|
                  |L13.204|
;;;1511   		}
;;;1512   		else
;;;1513   		{
;;;1514   			/* 仿XP风格，平面编辑框 */
;;;1515   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
0000cc  2010              MOVS     r0,#0x10
0000ce  9000              STR      r0,[sp,#0]
0000d0  8923              LDRH     r3,[r4,#8]
0000d2  88e2              LDRH     r2,[r4,#6]
0000d4  88a1              LDRH     r1,[r4,#4]
0000d6  8860              LDRH     r0,[r4,#2]
0000d8  f7fffffe          BL       LCD_DrawRect
;;;1516   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
0000dc  f64f70ff          MOV      r0,#0xffff
0000e0  9000              STR      r0,[sp,#0]
0000e2  f8b4c008          LDRH     r12,[r4,#8]
0000e6  f1ac0c02          SUB      r12,r12,#2
0000ea  fa1ff38c          UXTH     r3,r12
0000ee  f8b4c006          LDRH     r12,[r4,#6]
0000f2  f1ac0c02          SUB      r12,r12,#2
0000f6  fa1ff28c          UXTH     r2,r12
0000fa  f8b4c004          LDRH     r12,[r4,#4]
0000fe  f10c0c01          ADD      r12,r12,#1
000102  fa1ff18c          UXTH     r1,r12
000106  f8b4c002          LDRH     r12,[r4,#2]
00010a  f10c0c01          ADD      r12,r12,#1
00010e  fa1ff08c          UXTH     r0,r12
000112  f7fffffe          BL       LCD_DrawRect
;;;1517   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000116  f24940b2          MOV      r0,#0x94b2
00011a  9000              STR      r0,[sp,#0]
00011c  f8b4c008          LDRH     r12,[r4,#8]
000120  f1ac0c04          SUB      r12,r12,#4
000124  fa1ff38c          UXTH     r3,r12
000128  f8b4c006          LDRH     r12,[r4,#6]
00012c  f1ac0c04          SUB      r12,r12,#4
000130  fa1ff28c          UXTH     r2,r12
000134  f8b4c004          LDRH     r12,[r4,#4]
000138  f10c0c02          ADD      r12,r12,#2
00013c  fa1ff18c          UXTH     r1,r12
000140  f8b4c002          LDRH     r12,[r4,#2]
000144  f10c0c02          ADD      r12,r12,#2
000148  fa1ff08c          UXTH     r0,r12
00014c  f7fffffe          BL       LCD_DrawRect
;;;1518   
;;;1519   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);		/* 未选中的底色 */
000150  f64c6059          MOV      r0,#0xce59
000154  9000              STR      r0,[sp,#0]
000156  f8b4c008          LDRH     r12,[r4,#8]
00015a  f1ac0c06          SUB      r12,r12,#6
00015e  fa1ff38c          UXTH     r3,r12
000162  f8b4c006          LDRH     r12,[r4,#6]
000166  f1ac0c06          SUB      r12,r12,#6
00016a  fa1ff28c          UXTH     r2,r12
00016e  f8b4c004          LDRH     r12,[r4,#4]
000172  f10c0c03          ADD      r12,r12,#3
000176  fa1ff18c          UXTH     r1,r12
00017a  f8b4c002          LDRH     r12,[r4,#2]
00017e  f10c0c03          ADD      r12,r12,#3
000182  fa1ff08c          UXTH     r0,r12
000186  f7fffffe          BL       LCD_Fill_Rect
                  |L13.394|
;;;1520   		}
;;;1521   
;;;1522   		/* 文字居中 */
;;;1523   		len = strlen(_pBtn->pCaption);
00018a  6920              LDR      r0,[r4,#0x10]
00018c  f7fffffe          BL       strlen
000190  b286              UXTH     r6,r0
;;;1524   
;;;1525   		if (_pBtn->Font->FontCode == FC_ST_16)
000192  68e0              LDR      r0,[r4,#0xc]
000194  8800              LDRH     r0,[r0,#0]
000196  b908              CBNZ     r0,|L13.412|
;;;1526   		{
;;;1527   			fwidth = 8;		/* 字体宽度 */
000198  2508              MOVS     r5,#8
00019a  e012              B        |L13.450|
                  |L13.412|
;;;1528   		}
;;;1529   		else if (_pBtn->Font->FontCode == FC_ST_12)
00019c  68e0              LDR      r0,[r4,#0xc]
00019e  8800              LDRH     r0,[r0,#0]
0001a0  2801              CMP      r0,#1
0001a2  d101              BNE      |L13.424|
;;;1530   		{
;;;1531   			fwidth = 6;		/* 字体宽度 */
0001a4  2506              MOVS     r5,#6
0001a6  e00c              B        |L13.450|
                  |L13.424|
;;;1532   		}
;;;1533   		else if (_pBtn->Font->FontCode == FC_ST_24)
0001a8  68e0              LDR      r0,[r4,#0xc]
0001aa  8800              LDRH     r0,[r0,#0]
0001ac  2802              CMP      r0,#2
0001ae  d101              BNE      |L13.436|
;;;1534   		{
;;;1535   			fwidth = 12;		/* 字体宽度 */
0001b0  250c              MOVS     r5,#0xc
0001b2  e006              B        |L13.450|
                  |L13.436|
;;;1536   		}
;;;1537   		else if (_pBtn->Font->FontCode == FC_ST_48)
0001b4  68e0              LDR      r0,[r4,#0xc]
0001b6  8800              LDRH     r0,[r0,#0]
0001b8  2803              CMP      r0,#3
0001ba  d101              BNE      |L13.448|
;;;1538   		{
;;;1539   			fwidth = 24;		/* 字体宽度 */
0001bc  2518              MOVS     r5,#0x18
0001be  e000              B        |L13.450|
                  |L13.448|
;;;1540   		}
;;;1541   		else
;;;1542   		{
;;;1543   			fwidth = 8;		/* 字体宽度 */
0001c0  2508              MOVS     r5,#8
                  |L13.450|
;;;1544   		}
;;;1545   		x = _pBtn->Left + _pBtn->Width / 2 - (len * fwidth) / 2;
0001c2  8921              LDRH     r1,[r4,#8]
0001c4  eb0172d1          ADD      r2,r1,r1,LSR #31
0001c8  8863              LDRH     r3,[r4,#2]
0001ca  eb030362          ADD      r3,r3,r2,ASR #1
0001ce  fb06f005          MUL      r0,r6,r5
0001d2  eb0072d0          ADD      r2,r0,r0,LSR #31
0001d6  eba30262          SUB      r2,r3,r2,ASR #1
0001da  b297              UXTH     r7,r2
;;;1546   		y = _pBtn->Top + _pBtn->Height / 2 - fwidth;
0001dc  88e0              LDRH     r0,[r4,#6]
0001de  eb0071d0          ADD      r1,r0,r0,LSR #31
0001e2  88a2              LDRH     r2,[r4,#4]
0001e4  eb020161          ADD      r1,r2,r1,ASR #1
0001e8  1b49              SUBS     r1,r1,r5
0001ea  fa1ff881          UXTH     r8,r1
;;;1547   
;;;1548   		LCD_DispStr(x, y, _pBtn->pCaption, _pBtn->Font);
0001ee  4641              MOV      r1,r8
0001f0  4638              MOV      r0,r7
0001f2  e9d43203          LDRD     r3,r2,[r4,#0xc]
0001f6  f7fffffe          BL       LCD_DispStr
;;;1549   #else
;;;1550   	if (g_ChipID == IC_8875)
;;;1551   	{
;;;1552   		uint16_t len, x, y;
;;;1553   
;;;1554   		if (_pBtn->Focus == 1)
;;;1555   		{
;;;1556   			/* 仿XP风格，平面编辑框 */
;;;1557   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1558   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1559   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1560   
;;;1561   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);
;;;1562   
;;;1563   			RA8875_SetBackColor(BUTTON_ACTIVE_COLOR);
;;;1564   		}
;;;1565   		else
;;;1566   		{
;;;1567   			/* 仿XP风格，平面编辑框 */
;;;1568   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1569   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1570   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1571   
;;;1572   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);
;;;1573   
;;;1574   			RA8875_SetBackColor(BUTTON_BACK_COLOR);
;;;1575   		}
;;;1576   
;;;1577   		#if 1	/* 按钮文字字体和颜色固定 */
;;;1578   			if (strcmp(_pBtn->Caption, "←") == 0)	/* 退格键特殊处理 */
;;;1579   			{
;;;1580   				/* 退格键符号是单像素笔画，太细了不协调，因此特殊处理 */
;;;1581   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1582   				RA8875_SetFrontColor(CL_BLACK);
;;;1583   				RA8875_SetTextZoom(RA_SIZE_X2, RA_SIZE_X2);	/* 放大2倍 */
;;;1584   			}
;;;1585   			else
;;;1586   			{
;;;1587   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1588   				RA8875_SetFrontColor(CL_BLACK);
;;;1589   				RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 放大1倍 */
;;;1590   			}
;;;1591   		#else	/* 按钮文字字体和颜色有应用程序指定 */
;;;1592   			RA8875_SetFont(_pBtn->Font.FontCode, 0, 0);
;;;1593   			RA8875_SetFrontColor(_pBtn->Font.FrontColor);
;;;1594   		#endif
;;;1595   
;;;1596   		/* 文字居中 */
;;;1597   		len = strlen(_pBtn->Caption);
;;;1598   
;;;1599   		/* 此处统计不等宽字符有问题。暂时特殊处理下 */
;;;1600   		if (len != 3)
;;;1601   		{
;;;1602   			x = _pBtn->Left + (_pBtn->Width - len * 16) / 2;
;;;1603   		}
;;;1604   		else
;;;1605   		{
;;;1606   			x = _pBtn->Left + (_pBtn->Width - len * 20) / 2;
;;;1607   		}
;;;1608   
;;;1609   		/* 对特殊字符特殊处理 */
;;;1610   		if ((len == 1) && (_pBtn->Caption[0] == '.'))
;;;1611   		{
;;;1612   			y = _pBtn->Top + 3;
;;;1613   			x += 3;
;;;1614   		}
;;;1615   		else
;;;1616   		{
;;;1617   			y = _pBtn->Top + 3;
;;;1618   		}
;;;1619   
;;;1620   		RA8875_DispStr(x, y, _pBtn->Caption);
;;;1621   
;;;1622   		RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 还原放大1倍 */
;;;1623   	}
;;;1624   #endif
;;;1625   }
0001fa  e8bd83f8          POP      {r3-r9,pc}
;;;1626   
                          ENDP


                          AREA ||i.LCD_DrawCheckBox||, CODE, READONLY, ALIGN=2

                  LCD_DrawCheckBox PROC
;;;1364   */
;;;1365   void LCD_DrawCheckBox(CHECK_T *_pCheckBox)
000000  b57c              PUSH     {r2-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367   #if 1
;;;1368   	uint16_t x, y;
;;;1369   
;;;1370   	/* 目前只做了16点阵汉字的大小 */
;;;1371   
;;;1372   	/* 绘制外框 */
;;;1373   	x = _pCheckBox->Left;
000004  8865              LDRH     r5,[r4,#2]
;;;1374   	LCD_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  88a1              LDRH     r1,[r4,#4]
00000c  2318              MOVS     r3,#0x18
00000e  461a              MOV      r2,r3
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       LCD_DrawRect
;;;1375   	LCD_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
000016  2010              MOVS     r0,#0x10
000018  9000              STR      r0,[sp,#0]
00001a  88a2              LDRH     r2,[r4,#4]
00001c  1c52              ADDS     r2,r2,#1
00001e  b291              UXTH     r1,r2
000020  1c6a              ADDS     r2,r5,#1
000022  b290              UXTH     r0,r2
000024  2316              MOVS     r3,#0x16
000026  461a              MOV      r2,r3
000028  f7fffffe          BL       LCD_DrawRect
;;;1376   	LCD_Fill_Rect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
00002c  f64c6059          MOV      r0,#0xce59
000030  9000              STR      r0,[sp,#0]
000032  88a2              LDRH     r2,[r4,#4]
000034  1c92              ADDS     r2,r2,#2
000036  b291              UXTH     r1,r2
000038  1caa              ADDS     r2,r5,#2
00003a  b290              UXTH     r0,r2
00003c  2314              MOVS     r3,#0x14
00003e  461a              MOV      r2,r3
000040  f7fffffe          BL       LCD_Fill_Rect
;;;1377   
;;;1378   	/* 绘制文本标签 */
;;;1379   	x = _pCheckBox->Left + CHECK_BOX_W + 2;
000044  8860              LDRH     r0,[r4,#2]
000046  301a              ADDS     r0,r0,#0x1a
000048  b285              UXTH     r5,r0
;;;1380   	y = _pCheckBox->Top + CHECK_BOX_H / 2 - 8;
00004a  88a0              LDRH     r0,[r4,#4]
00004c  1d00              ADDS     r0,r0,#4
00004e  b286              UXTH     r6,r0
;;;1381   	LCD_DispStr(x, y, _pCheckBox->pCaption, _pCheckBox->Font);
000050  4631              MOV      r1,r6
000052  4628              MOV      r0,r5
000054  e9d43203          LDRD     r3,r2,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
;;;1382   
;;;1383   	if (_pCheckBox->Checked)
00005c  7d20              LDRB     r0,[r4,#0x14]
00005e  b1c0              CBZ      r0,|L14.146|
;;;1384   	{
;;;1385   		FONT_T font;
;;;1386   
;;;1387   	    font.FontCode = FC_ST_16;
000060  2000              MOVS     r0,#0
000062  f8ad0000          STRH     r0,[sp,#0]
;;;1388   		font.BackColor = CL_MASK;
000066  f6491099          MOV      r0,#0x9999
00006a  f8ad0004          STRH     r0,[sp,#4]
;;;1389   		font.FrontColor = CHECK_BOX_CHECKED_COLOR;	/* 钩的颜色 */
00006e  f44f4078          MOV      r0,#0xf800
000072  f8ad0002          STRH     r0,[sp,#2]
;;;1390   		font.Space = 0;
000076  2000              MOVS     r0,#0
000078  f8ad0006          STRH     r0,[sp,#6]
;;;1391   		x = _pCheckBox->Left;
00007c  8865              LDRH     r5,[r4,#2]
;;;1392   		LCD_DispStr(x + 3, _pCheckBox->Top + 3, "√", &font);
00007e  88a2              LDRH     r2,[r4,#4]
000080  1cd2              ADDS     r2,r2,#3
000082  b291              UXTH     r1,r2
000084  1cea              ADDS     r2,r5,#3
000086  b290              UXTH     r0,r2
000088  466b              MOV      r3,sp
00008a  a202              ADR      r2,|L14.148|
00008c  f7fffffe          BL       LCD_DispStr
;;;1393   	}
000090  bf00              NOP      
                  |L14.146|
;;;1394   #else
;;;1395   	if (g_ChipID == IC_8875)
;;;1396   	{
;;;1397   		uint16_t x;
;;;1398   
;;;1399   		RA8875_SetFont(_pCheckBox->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1400   
;;;1401   		/* 绘制标签 */
;;;1402   		//RA8875_SetBackColor(_pCheckBox->Font.BackColor);
;;;1403   		RA8875_SetBackColor(WIN_BODY_COLOR);
;;;1404   		RA8875_SetFrontColor(_pCheckBox->Font.FrontColor);
;;;1405   		RA8875_DispStr(_pCheckBox->Left, _pCheckBox->Top, _pCheckBox->Caption);
;;;1406   
;;;1407   		/* 绘制外框 */
;;;1408   		x = _pCheckBox->Left + _pCheckBox->Width - CHECK_BOX_W;
;;;1409   		RA8875_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
;;;1410   		RA8875_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
;;;1411   		RA8875_FillRect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
;;;1412   
;;;1413   		if (_pCheckBox->Checked)
;;;1414   		{
;;;1415   			RA8875_SetBackColor(CHECK_BOX_BACK_COLOR);
;;;1416   			RA8875_SetFrontColor(CL_RED);
;;;1417   			RA8875_DispStr(x + 3, _pCheckBox->Top + 3, "√");
;;;1418   		}
;;;1419   	}
;;;1420   	else
;;;1421   	{
;;;1422   
;;;1423   	}
;;;1424   #endif
;;;1425   
;;;1426   }
000092  bd7c              POP      {r2-r6,pc}
;;;1427   
                          ENDP

                  |L14.148|
000094  a1cc00            DCB      161,204,0
000097  00                DCB      0

                          AREA ||i.LCD_DrawCircle||, CODE, READONLY, ALIGN=2

                  LCD_DrawCircle PROC
;;;904    */
;;;905    void LCD_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;906    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;907    	if (g_ChipID == IC_8875)
00000c  480f              LDR      r0,|L15.76|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L15.34|
;;;908    	{
;;;909    		RA8875_DrawCircle(_usX, _usY, _usRadius, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawCircle
000020  e012              B        |L15.72|
                  |L15.34|
;;;910    	}
;;;911    	else if (g_ChipID == IC_9488)
000022  480a              LDR      r0,|L15.76|
000024  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000026  f2494188          MOV      r1,#0x9488
00002a  4288              CMP      r0,r1
00002c  d106              BNE      |L15.60|
;;;912    	{
;;;913    		ILI9488_DrawCircle(_usX, _usY, _usRadius, _usColor);
00002e  463b              MOV      r3,r7
000030  4632              MOV      r2,r6
000032  4629              MOV      r1,r5
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       ILI9488_DrawCircle
00003a  e005              B        |L15.72|
                  |L15.60|
;;;914    	}
;;;915    	else
;;;916    	{
;;;917    		SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
00003c  463b              MOV      r3,r7
00003e  4632              MOV      r2,r6
000040  4629              MOV      r1,r5
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       SPFD5420_DrawCircle
                  |L15.72|
;;;918    	}
;;;919    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;920    
                          ENDP

                  |L15.76|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawEdit||, CODE, READONLY, ALIGN=1

                  LCD_DrawEdit PROC
;;;1435   */
;;;1436   void LCD_DrawEdit(EDIT_T *_pEdit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1437   {
000004  4604              MOV      r4,r0
;;;1438   #if 1
;;;1439   	uint16_t len, x, y;
;;;1440   	uint8_t width;
;;;1441   
;;;1442   	/* 仿XP风格，平面编辑框 */
;;;1443   	LCD_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  8923              LDRH     r3,[r4,#8]
00000c  88e2              LDRH     r2,[r4,#6]
00000e  88a1              LDRH     r1,[r4,#4]
000010  8860              LDRH     r0,[r4,#2]
000012  f7fffffe          BL       LCD_DrawRect
;;;1444   	LCD_Fill_Rect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
000016  f64f70ff          MOV      r0,#0xffff
00001a  9000              STR      r0,[sp,#0]
00001c  f8b4c008          LDRH     r12,[r4,#8]
000020  f1ac0c02          SUB      r12,r12,#2
000024  fa1ff38c          UXTH     r3,r12
000028  f8b4c006          LDRH     r12,[r4,#6]
00002c  f1ac0c02          SUB      r12,r12,#2
000030  fa1ff28c          UXTH     r2,r12
000034  f8b4c004          LDRH     r12,[r4,#4]
000038  f10c0c01          ADD      r12,r12,#1
00003c  fa1ff18c          UXTH     r1,r12
000040  f8b4c002          LDRH     r12,[r4,#2]
000044  f10c0c01          ADD      r12,r12,#1
000048  fa1ff08c          UXTH     r0,r12
00004c  f7fffffe          BL       LCD_Fill_Rect
;;;1445   
;;;1446   	/* 文字居中 */
;;;1447   	if (_pEdit->Font->FontCode == FC_ST_12)
000050  68e0              LDR      r0,[r4,#0xc]
000052  8800              LDRH     r0,[r0,#0]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L16.92|
;;;1448   	{
;;;1449   		width = 6;
000058  2506              MOVS     r5,#6
00005a  e000              B        |L16.94|
                  |L16.92|
;;;1450   	}
;;;1451   	else
;;;1452   	{
;;;1453   		width = 8;
00005c  2508              MOVS     r5,#8
                  |L16.94|
;;;1454   	}
;;;1455   	len = strlen(_pEdit->pCaption);
00005e  6920              LDR      r0,[r4,#0x10]
000060  f7fffffe          BL       strlen
000064  b286              UXTH     r6,r0
;;;1456   	x = _pEdit->Left +  (_pEdit->Width - len * width) / 2;
000066  8921              LDRH     r1,[r4,#8]
000068  fb061015          MLS      r0,r6,r5,r1
00006c  eb0071d0          ADD      r1,r0,r0,LSR #31
000070  8862              LDRH     r2,[r4,#2]
000072  eb020161          ADD      r1,r2,r1,ASR #1
000076  b28f              UXTH     r7,r1
;;;1457   	y = _pEdit->Top + _pEdit->Height / 2 - width;
000078  88e0              LDRH     r0,[r4,#6]
00007a  eb0071d0          ADD      r1,r0,r0,LSR #31
00007e  88a2              LDRH     r2,[r4,#4]
000080  eb020161          ADD      r1,r2,r1,ASR #1
000084  1b49              SUBS     r1,r1,r5
000086  fa1ff881          UXTH     r8,r1
;;;1458   
;;;1459   	LCD_DispStr(x, y, _pEdit->pCaption, _pEdit->Font);
00008a  4641              MOV      r1,r8
00008c  4638              MOV      r0,r7
00008e  e9d43203          LDRD     r3,r2,[r4,#0xc]
000092  f7fffffe          BL       LCD_DispStr
;;;1460   #else
;;;1461   	if (g_ChipID == IC_8875)
;;;1462   	{
;;;1463   		uint16_t len, x;
;;;1464   
;;;1465   		/* 仿XP风格，平面编辑框 */
;;;1466   		RA8875_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
;;;1467   		RA8875_FillRect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
;;;1468   
;;;1469   		RA8875_SetFont(_pEdit->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1470   		RA8875_SetFrontColor(_pEdit->Font.FrontColor);
;;;1471   		RA8875_SetBackColor(EDIT_BACK_COLOR);
;;;1472   
;;;1473   		/* 文字居中 */
;;;1474   		len = strlen(_pEdit->Caption);
;;;1475   		x = (_pEdit->Width - len * 16) / 2;
;;;1476   
;;;1477   		RA8875_DispStr(_pEdit->Left + x, _pEdit->Top + 3, _pEdit->Caption);
;;;1478   	}
;;;1479   	else
;;;1480   	{
;;;1481   		//SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;1482   	}
;;;1483   #endif
;;;1484   }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;1485   
                          ENDP


                          AREA ||i.LCD_DrawGroupBox||, CODE, READONLY, ALIGN=1

                  LCD_DrawGroupBox PROC
;;;1634   */
;;;1635   void LCD_DrawGroupBox(GROUP_T *_pBox)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1636   {
000002  4604              MOV      r4,r0
;;;1637   	uint16_t x, y;
;;;1638   
;;;1639   	/* 画阴影线 */
;;;1640   	LCD_DrawRect(_pBox->Left + 1, _pBox->Top + 5, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER2);
000004  f64f70ff          MOV      r0,#0xffff
000008  9000              STR      r0,[sp,#0]
00000a  8927              LDRH     r7,[r4,#8]
00000c  1e7f              SUBS     r7,r7,#1
00000e  b2bb              UXTH     r3,r7
000010  88e2              LDRH     r2,[r4,#6]
000012  88a7              LDRH     r7,[r4,#4]
000014  1d7f              ADDS     r7,r7,#5
000016  b2b9              UXTH     r1,r7
000018  8867              LDRH     r7,[r4,#2]
00001a  1c7f              ADDS     r7,r7,#1
00001c  b2b8              UXTH     r0,r7
00001e  f7fffffe          BL       LCD_DrawRect
;;;1641   
;;;1642   	/* 画主框线 */
;;;1643   	LCD_DrawRect(_pBox->Left, _pBox->Top + 4, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER1);
000022  f64a5053          MOV      r0,#0xad53
000026  9000              STR      r0,[sp,#0]
000028  8927              LDRH     r7,[r4,#8]
00002a  1e7f              SUBS     r7,r7,#1
00002c  b2bb              UXTH     r3,r7
00002e  88e2              LDRH     r2,[r4,#6]
000030  88a7              LDRH     r7,[r4,#4]
000032  1d3f              ADDS     r7,r7,#4
000034  b2b9              UXTH     r1,r7
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       LCD_DrawRect
;;;1644   
;;;1645   	/* 显示分组框标题（文字在左上角） */
;;;1646   	x = _pBox->Left + 9;
00003c  8860              LDRH     r0,[r4,#2]
00003e  3009              ADDS     r0,r0,#9
000040  b285              UXTH     r5,r0
;;;1647   	y = _pBox->Top;
000042  88a6              LDRH     r6,[r4,#4]
;;;1648   	LCD_DispStr(x, y, _pBox->pCaption, _pBox->Font);
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  e9d43203          LDRD     r3,r2,[r4,#0xc]
00004c  f7fffffe          BL       LCD_DispStr
;;;1649   }
000050  bdf8              POP      {r3-r7,pc}
;;;1650   
                          ENDP


                          AREA ||i.LCD_DrawHColorLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawHColorLine PROC
;;;2107   */
;;;2108   void LCD_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2109   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2110   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L18.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L18.34|
;;;2111   	{
;;;2112   		RA8875_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHColorLine
000020  e005              B        |L18.46|
                  |L18.34|
;;;2113   	}
;;;2114   	else
;;;2115   	{
;;;2116   		SPFD5420_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHColorLine
                  |L18.46|
;;;2117   	}
;;;2118   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;2119   
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawIcon||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon PROC
;;;1017   */
;;;1018   void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1019   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1020   	const uint16_t *p;
;;;1021   	uint16_t usNewRGB;
;;;1022   	uint16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1023   
;;;1024   	p = _tIcon->pBmp;
000008  f8d4a00c          LDR      r10,[r4,#0xc]
;;;1025   	for (y = 0; y < _tIcon->Height; y++)
00000c  2600              MOVS     r6,#0
00000e  e0ad              B        |L19.364|
                  |L19.16|
;;;1026   	{
;;;1027   		for (x = 0; x < _tIcon->Width; x++)
000010  2500              MOVS     r5,#0
000012  e0a5              B        |L19.352|
                  |L19.20|
;;;1028   		{
;;;1029   			usNewRGB = *p++;	/* 读取图标的颜色值后指针加1 */
000014  f83a8b02          LDRH     r8,[r10],#2
;;;1030   			/* 将图标的4个直角切割为弧角，弧角外是背景图标 */
;;;1031   			if ((y == 0 && (x < 6 || x > _tIcon->Width - 7)) ||
000018  b92e              CBNZ     r6,|L19.38|
00001a  2d06              CMP      r5,#6
                  |L19.28|
00001c  db77              BLT      |L19.270|
00001e  8920              LDRH     r0,[r4,#8]
000020  1fc0              SUBS     r0,r0,#7
000022  42a8              CMP      r0,r5
000024  dbfa              BLT      |L19.28|
                  |L19.38|
;;;1032   				(y == 1 && (x < 4 || x > _tIcon->Width - 5)) ||
000026  2e01              CMP      r6,#1
000028  d105              BNE      |L19.54|
00002a  2d04              CMP      r5,#4
00002c  dbf6              BLT      |L19.28|
00002e  8920              LDRH     r0,[r4,#8]
000030  1f40              SUBS     r0,r0,#5
000032  42a8              CMP      r0,r5
000034  dbf2              BLT      |L19.28|
                  |L19.54|
;;;1033   				(y == 2 && (x < 3 || x > _tIcon->Width - 4)) ||
000036  2e02              CMP      r6,#2
000038  d105              BNE      |L19.70|
00003a  2d03              CMP      r5,#3
00003c  dbee              BLT      |L19.28|
00003e  8920              LDRH     r0,[r4,#8]
000040  1f00              SUBS     r0,r0,#4
000042  42a8              CMP      r0,r5
000044  dbea              BLT      |L19.28|
                  |L19.70|
;;;1034   				(y == 3 && (x < 2 || x > _tIcon->Width - 3)) ||
000046  2e03              CMP      r6,#3
000048  d105              BNE      |L19.86|
00004a  2d02              CMP      r5,#2
00004c  dbe6              BLT      |L19.28|
00004e  8920              LDRH     r0,[r4,#8]
000050  1ec0              SUBS     r0,r0,#3
000052  42a8              CMP      r0,r5
000054  dbe2              BLT      |L19.28|
                  |L19.86|
;;;1035   				(y == 4 && (x < 1 || x > _tIcon->Width - 2)) ||
000056  2e04              CMP      r6,#4
000058  d105              BNE      |L19.102|
00005a  2d01              CMP      r5,#1
00005c  db7e              BLT      |L19.348|
00005e  8920              LDRH     r0,[r4,#8]
000060  1e80              SUBS     r0,r0,#2
000062  42a8              CMP      r0,r5
000064  db7a              BLT      |L19.348|
                  |L19.102|
;;;1036   				(y == 5 && (x < 1 || x > _tIcon->Width - 2))	||
000066  2e05              CMP      r6,#5
000068  d105              BNE      |L19.118|
00006a  2d01              CMP      r5,#1
00006c  db76              BLT      |L19.348|
00006e  8920              LDRH     r0,[r4,#8]
000070  1e80              SUBS     r0,r0,#2
000072  42a8              CMP      r0,r5
000074  db72              BLT      |L19.348|
                  |L19.118|
;;;1037   
;;;1038   				(y == _tIcon->Height - 1 && (x < 6 || x > _tIcon->Width - 7)) ||
000076  88e0              LDRH     r0,[r4,#6]
000078  1e40              SUBS     r0,r0,#1
00007a  42b0              CMP      r0,r6
00007c  d105              BNE      |L19.138|
00007e  2d06              CMP      r5,#6
000080  db6c              BLT      |L19.348|
000082  8920              LDRH     r0,[r4,#8]
000084  1fc0              SUBS     r0,r0,#7
000086  42a8              CMP      r0,r5
000088  db68              BLT      |L19.348|
                  |L19.138|
;;;1039   				(y == _tIcon->Height - 2 && (x < 4 || x > _tIcon->Width - 5)) ||
00008a  88e0              LDRH     r0,[r4,#6]
00008c  1e80              SUBS     r0,r0,#2
00008e  42b0              CMP      r0,r6
000090  d105              BNE      |L19.158|
000092  2d04              CMP      r5,#4
000094  db62              BLT      |L19.348|
000096  8920              LDRH     r0,[r4,#8]
000098  1f40              SUBS     r0,r0,#5
00009a  42a8              CMP      r0,r5
00009c  db5e              BLT      |L19.348|
                  |L19.158|
;;;1040   				(y == _tIcon->Height - 3 && (x < 3 || x > _tIcon->Width - 4)) ||
00009e  88e0              LDRH     r0,[r4,#6]
0000a0  1ec0              SUBS     r0,r0,#3
0000a2  42b0              CMP      r0,r6
0000a4  d105              BNE      |L19.178|
0000a6  2d03              CMP      r5,#3
0000a8  db58              BLT      |L19.348|
0000aa  8920              LDRH     r0,[r4,#8]
0000ac  1f00              SUBS     r0,r0,#4
0000ae  42a8              CMP      r0,r5
0000b0  db54              BLT      |L19.348|
                  |L19.178|
;;;1041   				(y == _tIcon->Height - 4 && (x < 2 || x > _tIcon->Width - 3)) ||
0000b2  88e0              LDRH     r0,[r4,#6]
0000b4  1f00              SUBS     r0,r0,#4
0000b6  42b0              CMP      r0,r6
0000b8  d105              BNE      |L19.198|
0000ba  2d02              CMP      r5,#2
0000bc  db4e              BLT      |L19.348|
0000be  8920              LDRH     r0,[r4,#8]
0000c0  1ec0              SUBS     r0,r0,#3
0000c2  42a8              CMP      r0,r5
0000c4  db4a              BLT      |L19.348|
                  |L19.198|
;;;1042   				(y == _tIcon->Height - 5 && (x < 1 || x > _tIcon->Width - 2)) ||
0000c6  88e0              LDRH     r0,[r4,#6]
0000c8  1f40              SUBS     r0,r0,#5
0000ca  42b0              CMP      r0,r6
0000cc  d105              BNE      |L19.218|
0000ce  2d01              CMP      r5,#1
0000d0  db44              BLT      |L19.348|
0000d2  8920              LDRH     r0,[r4,#8]
0000d4  1e80              SUBS     r0,r0,#2
0000d6  42a8              CMP      r0,r5
0000d8  db40              BLT      |L19.348|
                  |L19.218|
;;;1043   				(y == _tIcon->Height - 6 && (x < 1 || x > _tIcon->Width - 2))
0000da  88e0              LDRH     r0,[r4,#6]
0000dc  1f80              SUBS     r0,r0,#6
0000de  42b0              CMP      r0,r6
0000e0  d105              BNE      |L19.238|
0000e2  2d01              CMP      r5,#1
0000e4  db3a              BLT      |L19.348|
0000e6  8920              LDRH     r0,[r4,#8]
0000e8  1e80              SUBS     r0,r0,#2
0000ea  42a8              CMP      r0,r5
0000ec  db36              BLT      |L19.348|
                  |L19.238|
;;;1044   				)
;;;1045   			{
;;;1046   				;
;;;1047   			}
;;;1048   			else
;;;1049   			{
;;;1050   				if (_ucFocusMode != 0)	/* 1表示选中的图标 */
0000ee  9802              LDR      r0,[sp,#8]
0000f0  b358              CBZ      r0,|L19.330|
;;;1051   				{
;;;1052   					/* 降低原始像素的亮度，实现图标被激活选中的效果 */
;;;1053   					uint16_t R,G,B;
;;;1054   					uint16_t bright = 15;
0000f2  200f              MOVS     r0,#0xf
;;;1055   
;;;1056   					/* rrrr rggg gggb bbbb */
;;;1057   					R = (usNewRGB & 0xF800) >> 11;
0000f4  ea4f21d8          LSR      r1,r8,#11
;;;1058   					G = (usNewRGB & 0x07E0) >> 5;
0000f8  f3c81245          UBFX     r2,r8,#5,#6
;;;1059   					B =  usNewRGB & 0x001F;
0000fc  f008031f          AND      r3,r8,#0x1f
;;;1060   					if (R > bright)
000100  4281              CMP      r1,r0
000102  dd05              BLE      |L19.272|
;;;1061   					{
;;;1062   						R -= bright;
000104  eba10c00          SUB      r12,r1,r0
000108  fa1ff18c          UXTH     r1,r12
00010c  e001              B        |L19.274|
                  |L19.270|
00010e  e025              B        |L19.348|
                  |L19.272|
;;;1063   					}
;;;1064   					else
;;;1065   					{
;;;1066   						R = 0;
000110  2100              MOVS     r1,#0
                  |L19.274|
;;;1067   					}
;;;1068   					if (G > 2 * bright)
000112  ea4f0c40          LSL      r12,r0,#1
000116  4594              CMP      r12,r2
000118  da06              BGE      |L19.296|
;;;1069   					{
;;;1070   						G -= 2 * bright;
00011a  f04f0c02          MOV      r12,#2
00011e  fb0c2c10          MLS      r12,r12,r0,r2
000122  fa1ff28c          UXTH     r2,r12
000126  e000              B        |L19.298|
                  |L19.296|
;;;1071   					}
;;;1072   					else
;;;1073   					{
;;;1074   						G = 0;
000128  2200              MOVS     r2,#0
                  |L19.298|
;;;1075   					}
;;;1076   					if (B > bright)
00012a  4283              CMP      r3,r0
00012c  dd04              BLE      |L19.312|
;;;1077   					{
;;;1078   						B -= bright;
00012e  eba30c00          SUB      r12,r3,r0
000132  fa1ff38c          UXTH     r3,r12
000136  e000              B        |L19.314|
                  |L19.312|
;;;1079   					}
;;;1080   					else
;;;1081   					{
;;;1082   						B = 0;
000138  2300              MOVS     r3,#0
                  |L19.314|
;;;1083   					}
;;;1084   					usNewRGB = (R << 11) + (G << 5) + B;
00013a  ea4f2cc1          LSL      r12,r1,#11
00013e  eb0c1c42          ADD      r12,r12,r2,LSL #5
000142  449c              ADD      r12,r12,r3
000144  fa1ff88c          UXTH     r8,r12
;;;1085   				}
000148  bf00              NOP      
                  |L19.330|
;;;1086   
;;;1087   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
00014a  88a2              LDRH     r2,[r4,#4]
00014c  4432              ADD      r2,r2,r6
00014e  b291              UXTH     r1,r2
000150  8862              LDRH     r2,[r4,#2]
000152  442a              ADD      r2,r2,r5
000154  b290              UXTH     r0,r2
000156  4642              MOV      r2,r8
000158  f7fffffe          BL       LCD_PutPixel
                  |L19.348|
00015c  1c68              ADDS     r0,r5,#1              ;1027
00015e  b285              UXTH     r5,r0                 ;1027
                  |L19.352|
000160  8920              LDRH     r0,[r4,#8]            ;1027
000162  42a8              CMP      r0,r5                 ;1027
000164  f73faf56          BGT      |L19.20|
000168  1c70              ADDS     r0,r6,#1              ;1025
00016a  b286              UXTH     r6,r0                 ;1025
                  |L19.364|
00016c  88e0              LDRH     r0,[r4,#6]            ;1025
00016e  42b0              CMP      r0,r6                 ;1025
000170  f73faf4e          BGT      |L19.16|
;;;1088   			}
;;;1089   		}
;;;1090   	}
;;;1091   
;;;1092   	/* 绘制图标下的文字 */
;;;1093   	{
;;;1094   		uint16_t len;
;;;1095   		uint16_t width;
;;;1096   
;;;1097   		len = strlen(_tIcon->Text);
000174  f1040010          ADD      r0,r4,#0x10
000178  f7fffffe          BL       strlen
00017c  fa1ffb80          UXTH     r11,r0
;;;1098   
;;;1099   		if  (len == 0)
000180  f1bb0f00          CMP      r11,#0
000184  d101              BNE      |L19.394|
                  |L19.390|
;;;1100   		{
;;;1101   			return;	/* 如果图标文本长度为0，则不显示 */
;;;1102   		}
;;;1103   
;;;1104   		/* 计算文本的总宽度 */
;;;1105   		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;1106   		{
;;;1107   			width = 6 * (len + _tFont->Space);
;;;1108   		}
;;;1109   		else	/* FC_ST_16 */
;;;1110   		{
;;;1111   			width = 8 * (len + _tFont->Space);
;;;1112   		}
;;;1113   
;;;1114   
;;;1115   		/* 水平居中 */
;;;1116   		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;1117   		y = _tIcon->Top + _tIcon->Height + 2;
;;;1118   		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;1119   	}
;;;1120   }
000186  e8bd8ffe          POP      {r1-r11,pc}
                  |L19.394|
00018a  8838              LDRH     r0,[r7,#0]            ;1105
00018c  2801              CMP      r0,#1                 ;1105
00018e  d107              BNE      |L19.416|
000190  88f8              LDRH     r0,[r7,#6]            ;1107
000192  4458              ADD      r0,r0,r11             ;1107
000194  eb000040          ADD      r0,r0,r0,LSL #1       ;1107
000198  0440              LSLS     r0,r0,#17             ;1107
00019a  ea4f4910          LSR      r9,r0,#16             ;1107
00019e  e004              B        |L19.426|
                  |L19.416|
0001a0  88f8              LDRH     r0,[r7,#6]            ;1111
0001a2  4458              ADD      r0,r0,r11             ;1111
0001a4  04c0              LSLS     r0,r0,#19             ;1111
0001a6  ea4f4910          LSR      r9,r0,#16             ;1111
                  |L19.426|
0001aa  8920              LDRH     r0,[r4,#8]            ;1116
0001ac  eb0072d0          ADD      r2,r0,r0,LSR #31      ;1116
0001b0  8863              LDRH     r3,[r4,#2]            ;1116
0001b2  eb030262          ADD      r2,r3,r2,ASR #1       ;1116
0001b6  4649              MOV      r1,r9                 ;1116
0001b8  eb0973d1          ADD      r3,r9,r1,LSR #31      ;1116
0001bc  eba20263          SUB      r2,r2,r3,ASR #1       ;1116
0001c0  b295              UXTH     r5,r2                 ;1116
0001c2  88a0              LDRH     r0,[r4,#4]            ;1117
0001c4  88e1              LDRH     r1,[r4,#6]            ;1117
0001c6  4408              ADD      r0,r0,r1              ;1117
0001c8  1c80              ADDS     r0,r0,#2              ;1117
0001ca  b286              UXTH     r6,r0                 ;1117
0001cc  463b              MOV      r3,r7                 ;1118
0001ce  f1040210          ADD      r2,r4,#0x10           ;1118
0001d2  4631              MOV      r1,r6                 ;1118
0001d4  4628              MOV      r0,r5                 ;1118
0001d6  f7fffffe          BL       LCD_DispStr
0001da  bf00              NOP      
0001dc  e7d3              B        |L19.390|
;;;1121   
                          ENDP


                          AREA ||i.LCD_DrawIcon32||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon32 PROC
;;;1152   */
;;;1153   void LCD_DrawIcon32(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1154   {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;1155   	const uint8_t *p;
;;;1156   	uint16_t usOldRGB, usNewRGB;
;;;1157   	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1158   	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;1159   	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;1160   
;;;1161   	p = (const uint8_t *)_tIcon->pBmp;
00000a  68e5              LDR      r5,[r4,#0xc]
;;;1162   	p += 54;		/* 直接指向图像数据区 */
00000c  3536              ADDS     r5,r5,#0x36
;;;1163   
;;;1164   	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;1165   	for (y = _tIcon->Height - 1; y >= 0; y--)
00000e  88e0              LDRH     r0,[r4,#6]
000010  1e40              SUBS     r0,r0,#1
000012  fa0ff880          SXTH     r8,r0
000016  e099              B        |L20.332|
                  |L20.24|
;;;1166   	{
;;;1167   		for (x = 0; x < _tIcon->Width; x++)
000018  2700              MOVS     r7,#0
00001a  e08f              B        |L20.316|
                  |L20.28|
;;;1168   		{
;;;1169   			B1 = *p++;
00001c  f8150b01          LDRB     r0,[r5],#1
000020  9004              STR      r0,[sp,#0x10]
;;;1170   			G1 = *p++;
000022  f8150b01          LDRB     r0,[r5],#1
000026  9005              STR      r0,[sp,#0x14]
;;;1171   			R1 = *p++;
000028  f8150b01          LDRB     r0,[r5],#1
00002c  9006              STR      r0,[sp,#0x18]
;;;1172   			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002e  f8156b01          LDRB     r6,[r5],#1
;;;1173   
;;;1174   			if (A == 0x00)	/* 需要透明,显示背景 */
000032  2e00              CMP      r6,#0
000034  d01f              BEQ      |L20.118|
;;;1175   			{
;;;1176   				;	/* 不用刷新背景 */
;;;1177   			}
;;;1178   			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000036  2eff              CMP      r6,#0xff
000038  d11e              BNE      |L20.120|
;;;1179   			{
;;;1180   				usNewRGB = RGB(R1, G1, B1);
00003a  9806              LDR      r0,[sp,#0x18]
00003c  10c0              ASRS     r0,r0,#3
00003e  02c1              LSLS     r1,r0,#11
000040  9805              LDR      r0,[sp,#0x14]
000042  1080              ASRS     r0,r0,#2
000044  ea411140          ORR      r1,r1,r0,LSL #5
000048  9804              LDR      r0,[sp,#0x10]
00004a  ea4100e0          ORR      r0,r1,r0,ASR #3
00004e  9007              STR      r0,[sp,#0x1c]
;;;1181   				if (_ucFocusMode == 1)
000050  980a              LDR      r0,[sp,#0x28]
000052  2801              CMP      r0,#1
000054  d106              BNE      |L20.100|
;;;1182   				{
;;;1183   					usNewRGB = LCD_Blend565(usNewRGB, CL_YELLOW, 10);
000056  220a              MOVS     r2,#0xa
000058  f64f71e0          MOV      r1,#0xffe0
00005c  9807              LDR      r0,[sp,#0x1c]
00005e  f7fffffe          BL       LCD_Blend565
000062  9007              STR      r0,[sp,#0x1c]
                  |L20.100|
;;;1184   				}
;;;1185   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000064  88a2              LDRH     r2,[r4,#4]
000066  4442              ADD      r2,r2,r8
000068  b291              UXTH     r1,r2
00006a  8862              LDRH     r2,[r4,#2]
00006c  443a              ADD      r2,r2,r7
00006e  b290              UXTH     r0,r2
000070  9a07              LDR      r2,[sp,#0x1c]
000072  f7fffffe          BL       LCD_PutPixel
                  |L20.118|
000076  e05f              B        |L20.312|
                  |L20.120|
;;;1186   			}
;;;1187   			else 	/* 半透明 */
;;;1188   			{
;;;1189   				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;1190   				usOldRGB = LCD_GetPixel(x + _tIcon->Left, y + _tIcon->Top);
000078  88a2              LDRH     r2,[r4,#4]
00007a  4442              ADD      r2,r2,r8
00007c  b291              UXTH     r1,r2
00007e  8862              LDRH     r2,[r4,#2]
000080  443a              ADD      r2,r2,r7
000082  b290              UXTH     r0,r2
000084  f7fffffe          BL       LCD_GetPixel
000088  4682              MOV      r10,r0
;;;1191   				//usOldRGB = 0xFFFF;
;;;1192   				R0 = RGB565_R(usOldRGB);
00008a  21f8              MOVS     r1,#0xf8
00008c  ea01202a          AND      r0,r1,r10,ASR #8
000090  9003              STR      r0,[sp,#0xc]
;;;1193   				G0 = RGB565_G(usOldRGB);
000092  21fc              MOVS     r1,#0xfc
000094  ea0100ea          AND      r0,r1,r10,ASR #3
000098  9002              STR      r0,[sp,#8]
;;;1194   				B0 = RGB565_B(usOldRGB);
00009a  21f8              MOVS     r1,#0xf8
00009c  ea0100ca          AND      r0,r1,r10,LSL #3
0000a0  9001              STR      r0,[sp,#4]
;;;1195   
;;;1196   				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
0000a2  9806              LDR      r0,[sp,#0x18]
0000a4  4370              MULS     r0,r6,r0
0000a6  21ff              MOVS     r1,#0xff
0000a8  fb90f2f1          SDIV     r2,r0,r1
0000ac  f1c601ff          RSB      r1,r6,#0xff
0000b0  9803              LDR      r0,[sp,#0xc]
0000b2  4341              MULS     r1,r0,r1
0000b4  20ff              MOVS     r0,#0xff
0000b6  fb91f0f0          SDIV     r0,r1,r0
0000ba  4410              ADD      r0,r0,r2
0000bc  b2c0              UXTB     r0,r0
0000be  9006              STR      r0,[sp,#0x18]
;;;1197   				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000c0  9805              LDR      r0,[sp,#0x14]
0000c2  4370              MULS     r0,r6,r0
0000c4  21ff              MOVS     r1,#0xff
0000c6  fb90f2f1          SDIV     r2,r0,r1
0000ca  f1c601ff          RSB      r1,r6,#0xff
0000ce  9802              LDR      r0,[sp,#8]
0000d0  4341              MULS     r1,r0,r1
0000d2  20ff              MOVS     r0,#0xff
0000d4  fb91f0f0          SDIV     r0,r1,r0
0000d8  4410              ADD      r0,r0,r2
0000da  b2c0              UXTB     r0,r0
0000dc  9005              STR      r0,[sp,#0x14]
;;;1198   				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000de  9804              LDR      r0,[sp,#0x10]
0000e0  4370              MULS     r0,r6,r0
0000e2  21ff              MOVS     r1,#0xff
0000e4  fb90f2f1          SDIV     r2,r0,r1
0000e8  f1c601ff          RSB      r1,r6,#0xff
0000ec  9801              LDR      r0,[sp,#4]
0000ee  4341              MULS     r1,r0,r1
0000f0  20ff              MOVS     r0,#0xff
0000f2  fb91f0f0          SDIV     r0,r1,r0
0000f6  4410              ADD      r0,r0,r2
0000f8  b2c0              UXTB     r0,r0
0000fa  9004              STR      r0,[sp,#0x10]
;;;1199   				usNewRGB = RGB(R1, G1, B1);
0000fc  9806              LDR      r0,[sp,#0x18]
0000fe  10c0              ASRS     r0,r0,#3
000100  02c1              LSLS     r1,r0,#11
000102  9805              LDR      r0,[sp,#0x14]
000104  1080              ASRS     r0,r0,#2
000106  ea411140          ORR      r1,r1,r0,LSL #5
00010a  9804              LDR      r0,[sp,#0x10]
00010c  ea4100e0          ORR      r0,r1,r0,ASR #3
000110  9007              STR      r0,[sp,#0x1c]
;;;1200   				if (_ucFocusMode == 1)
000112  980a              LDR      r0,[sp,#0x28]
000114  2801              CMP      r0,#1
000116  d106              BNE      |L20.294|
;;;1201   				{
;;;1202   					usNewRGB = LCD_Blend565(usNewRGB, CL_YELLOW, 10);
000118  220a              MOVS     r2,#0xa
00011a  f64f71e0          MOV      r1,#0xffe0
00011e  9807              LDR      r0,[sp,#0x1c]
000120  f7fffffe          BL       LCD_Blend565
000124  9007              STR      r0,[sp,#0x1c]
                  |L20.294|
;;;1203   				}
;;;1204   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000126  88a2              LDRH     r2,[r4,#4]
000128  4442              ADD      r2,r2,r8
00012a  b291              UXTH     r1,r2
00012c  8862              LDRH     r2,[r4,#2]
00012e  443a              ADD      r2,r2,r7
000130  b290              UXTH     r0,r2
000132  9a07              LDR      r2,[sp,#0x1c]
000134  f7fffffe          BL       LCD_PutPixel
                  |L20.312|
000138  1c78              ADDS     r0,r7,#1              ;1167
00013a  b207              SXTH     r7,r0                 ;1167
                  |L20.316|
00013c  8920              LDRH     r0,[r4,#8]            ;1167
00013e  42b8              CMP      r0,r7                 ;1167
000140  f73faf6c          BGT      |L20.28|
000144  f1a80001          SUB      r0,r8,#1              ;1165
000148  fa0ff880          SXTH     r8,r0                 ;1165
                  |L20.332|
00014c  f1b80f00          CMP      r8,#0                 ;1165
000150  f6bfaf62          BGE      |L20.24|
;;;1205   			}
;;;1206   		}
;;;1207   	}
;;;1208   
;;;1209   	/* 绘制图标下的文字 */
;;;1210   	{
;;;1211   		uint16_t len;
;;;1212   		uint16_t width;
;;;1213   
;;;1214   		len = strlen(_tIcon->Text);
000154  f1040010          ADD      r0,r4,#0x10
000158  f7fffffe          BL       strlen
00015c  b280              UXTH     r0,r0
00015e  9000              STR      r0,[sp,#0]
;;;1215   
;;;1216   		if  (len == 0)
000160  9800              LDR      r0,[sp,#0]
000162  b910              CBNZ     r0,|L20.362|
                  |L20.356|
;;;1217   		{
;;;1218   			return;	/* 如果图标文本长度为0，则不显示 */
;;;1219   		}
;;;1220   
;;;1221   		/* 计算文本的总宽度 */
;;;1222   		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;1223   		{
;;;1224   			width = 6 * (len + _tFont->Space);
;;;1225   		}
;;;1226   		else	/* FC_ST_16 */
;;;1227   		{
;;;1228   			width = 8 * (len + _tFont->Space);
;;;1229   		}
;;;1230   
;;;1231   
;;;1232   		/* 水平居中 */
;;;1233   		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;1234   		y = _tIcon->Top + _tIcon->Height + 2;
;;;1235   		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;1236   	}
;;;1237   }
000164  b00b              ADD      sp,sp,#0x2c
000166  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.362|
00016a  f8b90000          LDRH     r0,[r9,#0]            ;1222
00016e  2801              CMP      r0,#1                 ;1222
000170  d109              BNE      |L20.390|
000172  f8b91006          LDRH     r1,[r9,#6]            ;1224
000176  9800              LDR      r0,[sp,#0]            ;1224
000178  4408              ADD      r0,r0,r1              ;1224
00017a  eb000040          ADD      r0,r0,r0,LSL #1       ;1224
00017e  0440              LSLS     r0,r0,#17             ;1224
000180  ea4f4b10          LSR      r11,r0,#16            ;1224
000184  e006              B        |L20.404|
                  |L20.390|
000186  f8b91006          LDRH     r1,[r9,#6]            ;1228
00018a  9800              LDR      r0,[sp,#0]            ;1228
00018c  4408              ADD      r0,r0,r1              ;1228
00018e  04c0              LSLS     r0,r0,#19             ;1228
000190  ea4f4b10          LSR      r11,r0,#16            ;1228
                  |L20.404|
000194  8920              LDRH     r0,[r4,#8]            ;1233
000196  eb0072d0          ADD      r2,r0,r0,LSR #31      ;1233
00019a  8863              LDRH     r3,[r4,#2]            ;1233
00019c  eb030262          ADD      r2,r3,r2,ASR #1       ;1233
0001a0  4659              MOV      r1,r11                ;1233
0001a2  eb0b73d1          ADD      r3,r11,r1,LSR #31     ;1233
0001a6  eba20263          SUB      r2,r2,r3,ASR #1       ;1233
0001aa  b217              SXTH     r7,r2                 ;1233
0001ac  88a0              LDRH     r0,[r4,#4]            ;1234
0001ae  88e1              LDRH     r1,[r4,#6]            ;1234
0001b0  4408              ADD      r0,r0,r1              ;1234
0001b2  1c80              ADDS     r0,r0,#2              ;1234
0001b4  fa0ff880          SXTH     r8,r0                 ;1234
0001b8  fa1ff188          UXTH     r1,r8                 ;1235
0001bc  b2b8              UXTH     r0,r7                 ;1235
0001be  464b              MOV      r3,r9                 ;1235
0001c0  f1040210          ADD      r2,r4,#0x10           ;1235
0001c4  f7fffffe          BL       LCD_DispStr
0001c8  bf00              NOP      
0001ca  e7cb              B        |L20.356|
;;;1238   
                          ENDP


                          AREA ||i.LCD_DrawLabel||, CODE, READONLY, ALIGN=1

                  LCD_DrawLabel PROC
;;;1312   */
;;;1313   void LCD_DrawLabel(LABEL_T *_pLabel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1314   {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
;;;1315   #if 1
;;;1316   	char dispbuf[256];
;;;1317   	uint16_t i;
;;;1318   	uint16_t NewLen;
;;;1319   
;;;1320   	NewLen = strlen(_pLabel->pCaption);
000006  6920              LDR      r0,[r4,#0x10]
000008  f7fffffe          BL       strlen
00000c  b286              UXTH     r6,r0
;;;1321   
;;;1322   	if (NewLen > _pLabel->MaxLen)
00000e  8960              LDRH     r0,[r4,#0xa]
000010  42b0              CMP      r0,r6
000012  da07              BGE      |L21.36|
;;;1323   	{
;;;1324   		LCD_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->pCaption, _pLabel->Font);
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  e9d43203          LDRD     r3,r2,[r4,#0xc]
00001c  f7fffffe          BL       LCD_DispStr
;;;1325   		_pLabel->MaxLen = NewLen;
000020  8166              STRH     r6,[r4,#0xa]
000022  e01b              B        |L21.92|
                  |L21.36|
;;;1326   	}
;;;1327   	else
;;;1328   	{
;;;1329   		for (i = 0; i < NewLen; i++)
000024  2500              MOVS     r5,#0
000026  e005              B        |L21.52|
                  |L21.40|
;;;1330   		{
;;;1331   			dispbuf[i] = _pLabel->pCaption[i];
000028  6920              LDR      r0,[r4,#0x10]
00002a  5d40              LDRB     r0,[r0,r5]
00002c  a901              ADD      r1,sp,#4
00002e  5548              STRB     r0,[r1,r5]
000030  1c68              ADDS     r0,r5,#1              ;1329
000032  b285              UXTH     r5,r0                 ;1329
                  |L21.52|
000034  42b5              CMP      r5,r6                 ;1329
000036  dbf7              BLT      |L21.40|
;;;1332   		}
;;;1333   		for (; i < _pLabel->MaxLen; i++)
000038  e004              B        |L21.68|
                  |L21.58|
;;;1334   		{
;;;1335   			dispbuf[i] = ' ';		/* 末尾填充空格 */
00003a  2020              MOVS     r0,#0x20
00003c  a901              ADD      r1,sp,#4
00003e  5548              STRB     r0,[r1,r5]
000040  1c68              ADDS     r0,r5,#1              ;1333
000042  b285              UXTH     r5,r0                 ;1333
                  |L21.68|
000044  8960              LDRH     r0,[r4,#0xa]          ;1333
000046  42a8              CMP      r0,r5                 ;1333
000048  dcf7              BGT      |L21.58|
;;;1336   		}
;;;1337   		dispbuf[i] = 0;
00004a  2000              MOVS     r0,#0
00004c  a901              ADD      r1,sp,#4
00004e  5548              STRB     r0,[r1,r5]
;;;1338   		LCD_DispStr(_pLabel->Left, _pLabel->Top, dispbuf, _pLabel->Font);
000050  88a1              LDRH     r1,[r4,#4]
000052  8860              LDRH     r0,[r4,#2]
000054  aa01              ADD      r2,sp,#4
000056  68e3              LDR      r3,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
                  |L21.92|
;;;1339   	}
;;;1340   #else
;;;1341   	if (g_ChipID == IC_8875)
;;;1342   	{
;;;1343   		RA8875_SetFont(_pLabel->Font->FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1344   
;;;1345   		RA8875_SetBackColor(_pLabel->Font->BackColor);
;;;1346   		RA8875_SetFrontColor(_pLabel->Font->FrontColor);
;;;1347   
;;;1348   		RA8875_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->Caption);
;;;1349   	}
;;;1350   	else
;;;1351   	{
;;;1352   
;;;1353   	}
;;;1354   #endif
;;;1355   }
00005c  b041              ADD      sp,sp,#0x104
00005e  bdf0              POP      {r4-r7,pc}
;;;1356   
                          ENDP


                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;800    */
;;;801    void LCD_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;802    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;803    	if (g_ChipID == IC_8875)
00000e  4811              LDR      r0,|L22.84|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L22.38|
;;;804    	{
;;;805    		RA8875_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawLine
000024  e014              B        |L22.80|
                  |L22.38|
;;;806    	}
;;;807    	else if (g_ChipID == IC_9488)
000026  480b              LDR      r0,|L22.84|
000028  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00002a  f2494188          MOV      r1,#0x9488
00002e  4288              CMP      r0,r1
000030  d107              BNE      |L22.66|
;;;808    	{
;;;809    		ILI9488_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000032  4643              MOV      r3,r8
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  9400              STR      r4,[sp,#0]
00003c  f7fffffe          BL       ILI9488_DrawLine
000040  e006              B        |L22.80|
                  |L22.66|
;;;810    	}
;;;811    	else
;;;812    	{
;;;813    		SPFD5420_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000042  4643              MOV      r3,r8
000044  463a              MOV      r2,r7
000046  4631              MOV      r1,r6
000048  4628              MOV      r0,r5
00004a  9400              STR      r4,[sp,#0]
00004c  f7fffffe          BL       SPFD5420_DrawLine
                  |L22.80|
;;;814    	}
;;;815    }
000050  e8bd83f8          POP      {r3-r9,pc}
;;;816    
                          ENDP

                  |L22.84|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineH||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineH PROC
;;;2152   */
;;;2153   void LCD_DrawLineH(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2154   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2155   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L23.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L23.34|
;;;2156   	{
;;;2157   		RA8875_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHLine
000020  e005              B        |L23.46|
                  |L23.34|
;;;2158   	}
;;;2159   	else
;;;2160   	{
;;;2161   		SPFD5420_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHLine
                  |L23.46|
;;;2162   	}
;;;2163   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;2164   
                          ENDP

000032  0000              DCW      0x0000
                  |L23.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineV||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineV PROC
;;;2130   */
;;;2131   void LCD_DrawLineV(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2132   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2133   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L24.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L24.34|
;;;2134   	{
;;;2135   		RA8875_DrawVLine(_usX1 , _usY1 , _usY2 , _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawVLine
000020  e005              B        |L24.46|
                  |L24.34|
;;;2136   	}
;;;2137   	else
;;;2138   	{
;;;2139   		SPFD5420_DrawVLine(_usX1 , _usY1 , _usY2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawVLine
                  |L24.46|
;;;2140   	}
;;;2141   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;2142   /*
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawPoints||, CODE, READONLY, ALIGN=1

                  LCD_DrawPoints PROC
;;;826    */
;;;827    void LCD_DrawPoints(uint16_t *x, uint16_t *y, uint16_t _usSize, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;828    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;829    	uint16_t i;
;;;830    
;;;831    	for (i = 0 ; i < _usSize - 1; i++)
00000c  2400              MOVS     r4,#0
00000e  e00f              B        |L25.48|
                  |L25.16|
;;;832    	{
;;;833    		LCD_DrawLine(x[i], y[i], x[i + 1], y[i + 1], _usColor);
000010  f1040c01          ADD      r12,r4,#1
000014  f8cd8000          STR      r8,[sp,#0]
000018  f836301c          LDRH     r3,[r6,r12,LSL #1]
00001c  f835201c          LDRH     r2,[r5,r12,LSL #1]
000020  f8361014          LDRH     r1,[r6,r4,LSL #1]
000024  f8350014          LDRH     r0,[r5,r4,LSL #1]
000028  f7fffffe          BL       LCD_DrawLine
00002c  1c60              ADDS     r0,r4,#1              ;831
00002e  b284              UXTH     r4,r0                 ;831
                  |L25.48|
000030  1e78              SUBS     r0,r7,#1              ;831
000032  42a0              CMP      r0,r4                 ;831
000034  dcec              BGT      |L25.16|
;;;834    	}
;;;835    }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;836    
                          ENDP


                          AREA ||i.LCD_DrawRect||, CODE, READONLY, ALIGN=2

                  LCD_DrawRect PROC
;;;847    */
;;;848    void LCD_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;849    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;850    	if (g_ChipID == IC_8875)
00000e  4811              LDR      r0,|L26.84|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L26.38|
;;;851    	{
;;;852    		RA8875_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000016  4643              MOV      r3,r8
000018  462a              MOV      r2,r5
00001a  4639              MOV      r1,r7
00001c  4630              MOV      r0,r6
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawRect
000024  e014              B        |L26.80|
                  |L26.38|
;;;853    	}
;;;854    	else if (g_ChipID == IC_9488)
000026  480b              LDR      r0,|L26.84|
000028  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00002a  f2494188          MOV      r1,#0x9488
00002e  4288              CMP      r0,r1
000030  d107              BNE      |L26.66|
;;;855    	{
;;;856    		ILI9488_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000032  4643              MOV      r3,r8
000034  462a              MOV      r2,r5
000036  4639              MOV      r1,r7
000038  4630              MOV      r0,r6
00003a  9400              STR      r4,[sp,#0]
00003c  f7fffffe          BL       ILI9488_DrawRect
000040  e006              B        |L26.80|
                  |L26.66|
;;;857    	}
;;;858    	else
;;;859    	{
;;;860    		SPFD5420_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000042  b2ea              UXTB     r2,r5
000044  4643              MOV      r3,r8
000046  4639              MOV      r1,r7
000048  4630              MOV      r0,r6
00004a  9400              STR      r4,[sp,#0]
00004c  f7fffffe          BL       SPFD5420_DrawRect
                  |L26.80|
;;;861    	}
;;;862    }
000050  e8bd83f8          POP      {r3-r9,pc}
;;;863    
                          ENDP

                  |L26.84|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawWin||, CODE, READONLY, ALIGN=1

                  LCD_DrawWin PROC
;;;956    */
;;;957    void LCD_DrawWin(WIN_T *_pWin)
000000  b5f8              PUSH     {r3-r7,lr}
;;;958    {
000002  4604              MOV      r4,r0
;;;959    #if 1
;;;960    	uint16_t TitleHegiht;
;;;961    
;;;962    	TitleHegiht = 20;
000004  2514              MOVS     r5,#0x14
;;;963    
;;;964    	/* 绘制窗口外框 */
;;;965    	LCD_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
000006  f44f7004          MOV      r0,#0x210
00000a  9000              STR      r0,[sp,#0]
00000c  8923              LDRH     r3,[r4,#8]
00000e  88e2              LDRH     r2,[r4,#6]
000010  88a1              LDRH     r1,[r4,#4]
000012  8860              LDRH     r0,[r4,#2]
000014  f7fffffe          BL       LCD_DrawRect
;;;966    	LCD_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
000018  f44f7004          MOV      r0,#0x210
00001c  9000              STR      r0,[sp,#0]
00001e  8926              LDRH     r6,[r4,#8]
000020  1eb6              SUBS     r6,r6,#2
000022  b2b3              UXTH     r3,r6
000024  88e6              LDRH     r6,[r4,#6]
000026  1eb6              SUBS     r6,r6,#2
000028  b2b2              UXTH     r2,r6
00002a  88a6              LDRH     r6,[r4,#4]
00002c  1c76              ADDS     r6,r6,#1
00002e  b2b1              UXTH     r1,r6
000030  8866              LDRH     r6,[r4,#2]
000032  1c76              ADDS     r6,r6,#1
000034  b2b0              UXTH     r0,r6
000036  f7fffffe          BL       LCD_DrawRect
;;;967    
;;;968    	/* 窗口标题栏 */
;;;969    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
00003a  f244203f          MOV      r0,#0x423f
00003e  9000              STR      r0,[sp,#0]
000040  8922              LDRH     r2,[r4,#8]
000042  1f12              SUBS     r2,r2,#4
000044  b293              UXTH     r3,r2
000046  88a2              LDRH     r2,[r4,#4]
000048  1c92              ADDS     r2,r2,#2
00004a  b291              UXTH     r1,r2
00004c  8862              LDRH     r2,[r4,#2]
00004e  1c92              ADDS     r2,r2,#2
000050  b290              UXTH     r0,r2
000052  462a              MOV      r2,r5
000054  f7fffffe          BL       LCD_Fill_Rect
;;;970    
;;;971    	/* 窗体填充 */
;;;972    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht,
000058  f24b50b6          MOV      r0,#0xb5b6
00005c  9000              STR      r0,[sp,#0]
00005e  8926              LDRH     r6,[r4,#8]
000060  1f36              SUBS     r6,r6,#4
000062  b2b3              UXTH     r3,r6
000064  88e6              LDRH     r6,[r4,#6]
000066  1f36              SUBS     r6,r6,#4
000068  1b76              SUBS     r6,r6,r5
00006a  b2b2              UXTH     r2,r6
00006c  88a6              LDRH     r6,[r4,#4]
00006e  442e              ADD      r6,r6,r5
000070  1cb6              ADDS     r6,r6,#2
000072  b2b1              UXTH     r1,r6
000074  8866              LDRH     r6,[r4,#2]
000076  1cb6              ADDS     r6,r6,#2
000078  b2b0              UXTH     r0,r6
00007a  f7fffffe          BL       LCD_Fill_Rect
;;;973    		_pWin->Width - 4, WIN_BODY_COLOR);
;;;974    
;;;975    	LCD_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->pCaption, _pWin->Font);
00007e  88a6              LDRH     r6,[r4,#4]
000080  1cb6              ADDS     r6,r6,#2
000082  b2b1              UXTH     r1,r6
000084  8866              LDRH     r6,[r4,#2]
000086  1cf6              ADDS     r6,r6,#3
000088  b2b0              UXTH     r0,r6
00008a  e9d43203          LDRD     r3,r2,[r4,#0xc]
00008e  f7fffffe          BL       LCD_DispStr
;;;976    #else
;;;977    	if (g_ChipID == IC_8875)
;;;978    	{
;;;979    		uint16_t TitleHegiht;
;;;980    
;;;981    		TitleHegiht = 28;
;;;982    
;;;983    		/* 绘制窗口外框 */
;;;984    		RA8875_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
;;;985    		RA8875_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
;;;986    
;;;987    		/* 窗口标题栏 */
;;;988    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
;;;989    
;;;990    		/* 窗体填充 */
;;;991    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht, _pWin->Width - 4, WIN_BODY_COLOR);
;;;992    
;;;993    		//RA8875_SetFont(_pWin->Font.FontCode, 0, 0);
;;;994    		RA8875_SetFont(RA_FONT_24, 0, 0);
;;;995    
;;;996    		RA8875_SetBackColor(WIN_TITLE_COLOR);
;;;997    		RA8875_SetFrontColor(WIN_CAPTION_COLOR);
;;;998    		RA8875_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->Caption);
;;;999    	}
;;;1000   	else
;;;1001   	{
;;;1002   		;
;;;1003   	}
;;;1004   #endif
;;;1005   }
000092  bdf8              POP      {r3-r7,pc}
;;;1006   
                          ENDP


                          AREA ||i.LCD_FSMCConfig||, CODE, READONLY, ALIGN=1

                  LCD_FSMCConfig PROC
;;;1822   */
;;;1823   static void LCD_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;1824   {
000002  b09f              SUB      sp,sp,#0x7c
;;;1825   	FMC_NORSRAMInitTypeDef  init;
;;;1826   	FMC_NORSRAMTimingInitTypeDef  timingWrite;
;;;1827   	FMC_NORSRAMTimingInitTypeDef  timingRead;
;;;1828   
;;;1829   	/*-- FSMC Configuration ------------------------------------------------------*/
;;;1830   	/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;1831   	/* FSMC_Bank1_NORSRAM4 configuration */
;;;1832   	/* 摄像头DMA麻点，需设置 4 0 5 2 0 0 */
;;;1833   	timingWrite.FMC_AddressSetupTime = 4;
000004  2004              MOVS     r0,#4
000006  9008              STR      r0,[sp,#0x20]
;;;1834   	timingWrite.FMC_AddressHoldTime = 0;
000008  2000              MOVS     r0,#0
00000a  9009              STR      r0,[sp,#0x24]
;;;1835   	timingWrite.FMC_DataSetupTime = 6;
00000c  2006              MOVS     r0,#6
00000e  900a              STR      r0,[sp,#0x28]
;;;1836   	timingWrite.FMC_BusTurnAroundDuration = 1;
000010  2001              MOVS     r0,#1
000012  900b              STR      r0,[sp,#0x2c]
;;;1837   	timingWrite.FMC_CLKDivision = 0;
000014  2000              MOVS     r0,#0
000016  900c              STR      r0,[sp,#0x30]
;;;1838   	timingWrite.FMC_DataLatency = 0;
000018  900d              STR      r0,[sp,#0x34]
;;;1839   	timingWrite.FMC_AccessMode = FMC_AccessMode_A;
00001a  900e              STR      r0,[sp,#0x38]
;;;1840   
;;;1841   	timingRead.FMC_AddressSetupTime = 4;
00001c  2004              MOVS     r0,#4
00001e  9001              STR      r0,[sp,#4]
;;;1842   	timingRead.FMC_AddressHoldTime = 0;
000020  2000              MOVS     r0,#0
000022  9002              STR      r0,[sp,#8]
;;;1843   	timingRead.FMC_DataSetupTime = 8;
000024  2008              MOVS     r0,#8
000026  9003              STR      r0,[sp,#0xc]
;;;1844   	timingRead.FMC_BusTurnAroundDuration = 1;
000028  2001              MOVS     r0,#1
00002a  9004              STR      r0,[sp,#0x10]
;;;1845   	timingRead.FMC_CLKDivision = 0;
00002c  2000              MOVS     r0,#0
00002e  9005              STR      r0,[sp,#0x14]
;;;1846   	timingRead.FMC_DataLatency = 0;
000030  9006              STR      r0,[sp,#0x18]
;;;1847   	timingRead.FMC_AccessMode = FMC_AccessMode_A;
000032  9007              STR      r0,[sp,#0x1c]
;;;1848   
;;;1849   
;;;1850   	/*
;;;1851   	 LCD configured as follow:
;;;1852   	    - Data/Address MUX = Disable
;;;1853   	    - Memory Type = SRAM
;;;1854   	    - Data Width = 16bit
;;;1855   	    - Write Operation = Enable
;;;1856   	    - Extended Mode = Enable
;;;1857   	    - Asynchronous Wait = Disable
;;;1858   	*/
;;;1859   	init.FMC_Bank = FMC_Bank1_NORSRAM4;
000034  2006              MOVS     r0,#6
000036  900f              STR      r0,[sp,#0x3c]
;;;1860   	init.FMC_DataAddressMux = FMC_DataAddressMux_Disable;
000038  2000              MOVS     r0,#0
00003a  9010              STR      r0,[sp,#0x40]
;;;1861   	init.FMC_MemoryType = FMC_MemoryType_SRAM;
00003c  9011              STR      r0,[sp,#0x44]
;;;1862   	init.FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
00003e  2010              MOVS     r0,#0x10
000040  9012              STR      r0,[sp,#0x48]
;;;1863   	init.FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
000042  2000              MOVS     r0,#0
000044  9013              STR      r0,[sp,#0x4c]
;;;1864   	init.FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;	/* 注意旧库无这个成员 */
000046  901a              STR      r0,[sp,#0x68]
;;;1865   	init.FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
000048  9014              STR      r0,[sp,#0x50]
;;;1866   	init.FMC_WrapMode = FMC_WrapMode_Disable;
00004a  9015              STR      r0,[sp,#0x54]
;;;1867   	init.FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
00004c  9016              STR      r0,[sp,#0x58]
;;;1868   	init.FMC_WriteOperation = FMC_WriteOperation_Enable;
00004e  f44f5080          MOV      r0,#0x1000
000052  9017              STR      r0,[sp,#0x5c]
;;;1869   	init.FMC_WaitSignal = FMC_WaitSignal_Disable;
000054  2000              MOVS     r0,#0
000056  9018              STR      r0,[sp,#0x60]
;;;1870   	init.FMC_ExtendedMode = FMC_ExtendedMode_Disable;
000058  9019              STR      r0,[sp,#0x64]
;;;1871   	init.FMC_WriteBurst = FMC_WriteBurst_Disable;
00005a  901b              STR      r0,[sp,#0x6c]
;;;1872   
;;;1873   	init.FMC_ReadWriteTimingStruct = &timingRead;
00005c  a801              ADD      r0,sp,#4
00005e  901d              STR      r0,[sp,#0x74]
;;;1874   	init.FMC_WriteTimingStruct = &timingWrite;
000060  a808              ADD      r0,sp,#0x20
000062  901e              STR      r0,[sp,#0x78]
;;;1875   
;;;1876   	FMC_NORSRAMInit(&init);
000064  a80f              ADD      r0,sp,#0x3c
000066  f7fffffe          BL       FMC_NORSRAMInit
;;;1877   
;;;1878   	/* - BANK 1 (of NOR/SRAM Bank 1~4) is enabled */
;;;1879   	FMC_NORSRAMCmd(FMC_Bank1_NORSRAM4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2006              MOVS     r0,#6
00006e  f7fffffe          BL       FMC_NORSRAMCmd
;;;1880   }
000072  b01f              ADD      sp,sp,#0x7c
000074  bd00              POP      {pc}
;;;1881   
                          ENDP


                          AREA ||i.LCD_Fill_Rect||, CODE, READONLY, ALIGN=2

                  LCD_Fill_Rect PROC
;;;874    */
;;;875    void LCD_Fill_Rect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;876    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;877    	if (g_ChipID == IC_8875)
00000e  4816              LDR      r0,|L29.104|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L29.38|
;;;878    	{
;;;879    		RA8875_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000016  464b              MOV      r3,r9
000018  4642              MOV      r2,r8
00001a  4639              MOV      r1,r7
00001c  4630              MOV      r0,r6
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_FillRect
000024  e01d              B        |L29.98|
                  |L29.38|
;;;880    	}
;;;881    	else if (g_ChipID == IC_9488)
000026  4810              LDR      r0,|L29.104|
000028  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00002a  f2494188          MOV      r1,#0x9488
00002e  4288              CMP      r0,r1
000030  d107              BNE      |L29.66|
;;;882    	{
;;;883    		ILI9488_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000032  464b              MOV      r3,r9
000034  4642              MOV      r2,r8
000036  4639              MOV      r1,r7
000038  4630              MOV      r0,r6
00003a  9400              STR      r4,[sp,#0]
00003c  f7fffffe          BL       ILI9488_FillRect
000040  e00f              B        |L29.98|
                  |L29.66|
;;;884    	}
;;;885    	else
;;;886    	{
;;;887    		uint32_t i;
;;;888    		for (i = 0; i < _usHeight; i++)
000042  2500              MOVS     r5,#0
000044  e00a              B        |L29.92|
                  |L29.70|
;;;889    		{
;;;890    			SPFD5420_DrawHLine(_usX, _usY + i, _usX + _usWidth - 1, _usColor);
000046  eb060009          ADD      r0,r6,r9
00004a  1e40              SUBS     r0,r0,#1
00004c  b282              UXTH     r2,r0
00004e  1978              ADDS     r0,r7,r5
000050  b281              UXTH     r1,r0
000052  4623              MOV      r3,r4
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       SPFD5420_DrawHLine
00005a  1c6d              ADDS     r5,r5,#1              ;888
                  |L29.92|
00005c  4545              CMP      r5,r8                 ;888
00005e  d3f2              BCC      |L29.70|
;;;891    		}
;;;892    	}
000060  bf00              NOP      
                  |L29.98|
;;;893    }
000062  e8bd83f8          POP      {r3-r9,pc}
;;;894    
                          ENDP

000066  0000              DCW      0x0000
                  |L29.104|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_GetBackLight PROC
;;;2021   */
;;;2022   uint8_t LCD_GetBackLight(void)
000000  4801              LDR      r0,|L30.8|
;;;2023   {
;;;2024   	return s_ucBright;
000002  7800              LDRB     r0,[r0,#0]  ; s_ucBright
;;;2025   }
000004  4770              BX       lr
;;;2026   /*
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      s_ucBright

                          AREA ||i.LCD_GetChipDescribe||, CODE, READONLY, ALIGN=2

                  LCD_GetChipDescribe PROC
;;;108    */
;;;109    void LCD_GetChipDescribe(char *_str)
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  4604              MOV      r4,r0
;;;111    	switch (g_ChipID)
000004  481b              LDR      r0,|L31.116|
000006  8801              LDRH     r1,[r0,#0]  ; g_ChipID
000008  f2454220          MOV      r2,#0x5420
00000c  1a88              SUBS     r0,r1,r2
00000e  4291              CMP      r1,r2
000010  d010              BEQ      |L31.52|
000012  dc06              BGT      |L31.34|
000014  2975              CMP      r1,#0x75
000016  d01c              BEQ      |L31.82|
000018  f46f4080          MVN      r0,#0x4000
00001c  4408              ADD      r0,r0,r1
00001e  bb10              CBNZ     r0,|L31.102|
000020  e00d              B        |L31.62|
                  |L31.34|
000022  f5a04080          SUB      r0,r0,#0x4000
000026  3868              SUBS     r0,r0,#0x68
000028  b1c0              CBZ      r0,|L31.92|
00002a  f46f5102          MVN      r1,#0x2080
00002e  4408              ADD      r0,r0,r1
000030  b9c8              CBNZ     r0,|L31.102|
000032  e009              B        |L31.72|
                  |L31.52|
;;;112    	{
;;;113    		case IC_5420:
;;;114    			strcpy(_str, CHIP_STR_5420);
000034  a110              ADR      r1,|L31.120|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       strcpy
;;;115    			break;
00003c  e018              B        |L31.112|
                  |L31.62|
;;;116    
;;;117    		case IC_4001:
;;;118    			strcpy(_str, CHIP_STR_4001);
00003e  a111              ADR      r1,|L31.132|
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       strcpy
;;;119    			break;
000046  e013              B        |L31.112|
                  |L31.72|
;;;120    
;;;121    		case IC_61509:
;;;122    			strcpy(_str, CHIP_STR_61509);
000048  a111              ADR      r1,|L31.144|
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       strcpy
;;;123    			break;
000050  e00e              B        |L31.112|
                  |L31.82|
;;;124    
;;;125    		case IC_8875:
;;;126    			strcpy(_str, CHIP_STR_8875);
000052  a111              ADR      r1,|L31.152|
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       strcpy
;;;127    			break;
00005a  e009              B        |L31.112|
                  |L31.92|
;;;128    
;;;129    		case IC_9488:
;;;130    			strcpy(_str, CHIP_STR_9488);
00005c  a110              ADR      r1,|L31.160|
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       strcpy
;;;131    			break;
000064  e004              B        |L31.112|
                  |L31.102|
;;;132    
;;;133    		default:
;;;134    			strcpy(_str, "Unknow");
000066  a110              ADR      r1,|L31.168|
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       strcpy
;;;135    			break;
00006e  bf00              NOP      
                  |L31.112|
000070  bf00              NOP                            ;115
;;;136    	}
;;;137    }
000072  bd10              POP      {r4,pc}
;;;138    
                          ENDP

                  |L31.116|
                          DCD      g_ChipID
                  |L31.120|
000078  53504644          DCB      "SPFD5420A",0
00007c  35343230
000080  4100    
000082  00                DCB      0
000083  00                DCB      0
                  |L31.132|
000084  4f544d34          DCB      "OTM4001A",0
000088  30303141
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L31.144|
000090  52363135          DCB      "R61509V",0
000094  30395600
                  |L31.152|
000098  52413838          DCB      "RA8875",0
00009c  373500  
00009f  00                DCB      0
                  |L31.160|
0000a0  494c4939          DCB      "ILI9488",0
0000a4  34383800
                  |L31.168|
0000a8  556e6b6e          DCB      "Unknow",0
0000ac  6f7700  
0000af  00                DCB      0

                          AREA ||i.LCD_GetFontHeight||, CODE, READONLY, ALIGN=1

                  LCD_GetFontHeight PROC
;;;487    */
;;;488    uint16_t LCD_GetFontHeight(FONT_T *_tFont)
000000  4601              MOV      r1,r0
;;;489    {
;;;490    	uint16_t height;
;;;491    
;;;492    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;493    	if (_tFont->FontCode == FC_ST_12)
000002  880a              LDRH     r2,[r1,#0]
000004  2a01              CMP      r2,#1
000006  d101              BNE      |L32.12|
;;;494    	{
;;;495    		height = 12;
000008  200c              MOVS     r0,#0xc
00000a  e000              B        |L32.14|
                  |L32.12|
;;;496    	}
;;;497    	else
;;;498    	{
;;;499    		height = 16;
00000c  2010              MOVS     r0,#0x10
                  |L32.14|
;;;500    	}
;;;501    
;;;502    	return height;
;;;503    }
00000e  4770              BX       lr
;;;504    
                          ENDP


                          AREA ||i.LCD_GetFontWidth||, CODE, READONLY, ALIGN=1

                  LCD_GetFontWidth PROC
;;;461    */
;;;462    uint16_t LCD_GetFontWidth(FONT_T *_tFont)
000000  4601              MOV      r1,r0
;;;463    {
;;;464    	uint16_t font_width;
;;;465    
;;;466    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;467    	if (_tFont->FontCode == FC_ST_12)
000002  880a              LDRH     r2,[r1,#0]
000004  2a01              CMP      r2,#1
000006  d101              BNE      |L33.12|
;;;468    	{
;;;469    		font_width = 12;
000008  200c              MOVS     r0,#0xc
00000a  e000              B        |L33.14|
                  |L33.12|
;;;470    	}
;;;471    	else
;;;472    	{
;;;473    		font_width = 16;
00000c  2010              MOVS     r0,#0x10
                  |L33.14|
;;;474    	}
;;;475    
;;;476    	return font_width;
;;;477    }
00000e  4770              BX       lr
;;;478    
                          ENDP


                          AREA ||i.LCD_GetHeight||, CODE, READONLY, ALIGN=2

                  LCD_GetHeight PROC
;;;146    */
;;;147    uint16_t LCD_GetHeight(void)
000000  4801              LDR      r0,|L34.8|
;;;148    {
;;;149    	return g_LcdHeight;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
;;;150    }
000004  4770              BX       lr
;;;151    
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      g_LcdHeight

                          AREA ||i.LCD_GetPixel||, CODE, READONLY, ALIGN=2

                  LCD_GetPixel PROC
;;;769    */
;;;770    uint16_t LCD_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;771    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;772    	uint16_t usRGB;
;;;773    
;;;774    	if (g_ChipID == IC_8875)
000006  480e              LDR      r0,|L35.64|
000008  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000a  2875              CMP      r0,#0x75
00000c  d105              BNE      |L35.26|
;;;775    	{
;;;776    		usRGB = RA8875_GetPixel(_usX, _usY);
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       RA8875_GetPixel
000016  4604              MOV      r4,r0
000018  e010              B        |L35.60|
                  |L35.26|
;;;777    	}
;;;778    	else if (g_ChipID == IC_9488)
00001a  4809              LDR      r0,|L35.64|
00001c  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00001e  f2494188          MOV      r1,#0x9488
000022  4288              CMP      r0,r1
000024  d105              BNE      |L35.50|
;;;779    	{
;;;780    		usRGB = ILI9488_GetPixel(_usX, _usY);
000026  4631              MOV      r1,r6
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       ILI9488_GetPixel
00002e  4604              MOV      r4,r0
000030  e004              B        |L35.60|
                  |L35.50|
;;;781    	}
;;;782    	else
;;;783    	{
;;;784    		usRGB = SPFD5420_GetPixel(_usX, _usY);
000032  4631              MOV      r1,r6
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       SPFD5420_GetPixel
00003a  4604              MOV      r4,r0
                  |L35.60|
;;;785    	}
;;;786    
;;;787    	return usRGB;
00003c  4620              MOV      r0,r4
;;;788    }
00003e  bd70              POP      {r4-r6,pc}
;;;789    
                          ENDP

                  |L35.64|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetStrWidth||, CODE, READONLY, ALIGN=1

                  LCD_GetStrWidth PROC
;;;514    */
;;;515    uint16_t LCD_GetStrWidth(char *_ptr, FONT_T *_tFont)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;516    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;517    	char *p = _ptr;
000008  4633              MOV      r3,r6
;;;518    	uint16_t width = 0;
00000a  2400              MOVS     r4,#0
;;;519    	uint8_t code1, code2;
;;;520    	uint16_t font_width;
;;;521    
;;;522    	font_width = LCD_GetFontWidth(_tFont);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       LCD_GetFontWidth
000012  4605              MOV      r5,r0
;;;523    
;;;524    	while (*p != 0)
000014  e016              B        |L36.68|
                  |L36.22|
;;;525    	{
;;;526    		code1 = *p;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
000016  f8939000          LDRB     r9,[r3,#0]
;;;527    		if (code1 < 0x80)	/* ASCII */
00001a  f1b90f80          CMP      r9,#0x80
00001e  da06              BGE      |L36.46|
;;;528    		{
;;;529    			width += font_width / 2;
000020  4628              MOV      r0,r5
000022  eb0571d0          ADD      r1,r5,r0,LSR #31
000026  eb040161          ADD      r1,r4,r1,ASR #1
00002a  b28c              UXTH     r4,r1
00002c  e009              B        |L36.66|
                  |L36.46|
;;;530    		}
;;;531    		else	/* 汉字 */
;;;532    		{
;;;533    			code2 = *++p;
00002e  1c58              ADDS     r0,r3,#1
000030  4603              MOV      r3,r0
000032  f8908000          LDRB     r8,[r0,#0]
;;;534    			if (code2 == 0)
000036  f1b80f00          CMP      r8,#0
00003a  d100              BNE      |L36.62|
;;;535    			{
;;;536    				break;
00003c  e005              B        |L36.74|
                  |L36.62|
;;;537    			}
;;;538    			width += font_width;
00003e  1960              ADDS     r0,r4,r5
000040  b284              UXTH     r4,r0
                  |L36.66|
;;;539    		}
;;;540    		p++;
000042  1c5b              ADDS     r3,r3,#1
                  |L36.68|
000044  7818              LDRB     r0,[r3,#0]            ;524
000046  2800              CMP      r0,#0                 ;524
000048  d1e5              BNE      |L36.22|
                  |L36.74|
00004a  bf00              NOP                            ;536
;;;541    	}
;;;542    
;;;543    	return width;
00004c  4620              MOV      r0,r4
;;;544    }
00004e  e8bd83f0          POP      {r4-r9,pc}
;;;545    
                          ENDP


                          AREA ||i.LCD_GetWidth||, CODE, READONLY, ALIGN=2

                  LCD_GetWidth PROC
;;;159    */
;;;160    uint16_t LCD_GetWidth(void)
000000  4801              LDR      r0,|L37.8|
;;;161    {
;;;162    	return g_LcdWidth;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
;;;163    }
000004  4770              BX       lr
;;;164    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      g_LcdWidth

                          AREA ||i.LCD_InitHard||, CODE, READONLY, ALIGN=2

                  LCD_InitHard PROC
;;;59     */
;;;60     void LCD_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62     	uint32_t id;
;;;63     
;;;64     	/* 配置LCD控制口线GPIO */
;;;65     	LCD_CtrlLinesConfig();
000002  f7fffffe          BL       LCD_CtrlLinesConfig
;;;66     
;;;67     	/* 配置FSMC接口，数据总线 */
;;;68     	LCD_FSMCConfig();
000006  f7fffffe          BL       LCD_FSMCConfig
;;;69     
;;;70     	/* FSMC重置后必须加延迟才能访问总线设备  */
;;;71     	bsp_DelayMS(20);
00000a  2014              MOVS     r0,#0x14
00000c  f7fffffe          BL       bsp_DelayMS
;;;72     
;;;73     	id = ILI9488_ReadID();
000010  f7fffffe          BL       ILI9488_ReadID
000014  4604              MOV      r4,r0
;;;74     	if (id == 0x548066)		/* 3.5寸屏 */
000016  4815              LDR      r0,|L38.108|
000018  4284              CMP      r4,r0
00001a  d106              BNE      |L38.42|
;;;75     	{
;;;76     		g_ChipID = IC_9488;
00001c  f2494088          MOV      r0,#0x9488
000020  4913              LDR      r1,|L38.112|
000022  8008              STRH     r0,[r1,#0]
;;;77     		ILI9488_InitHard();
000024  f7fffffe          BL       ILI9488_InitHard
000028  e016              B        |L38.88|
                  |L38.42|
;;;78     	}
;;;79     	else
;;;80     	{
;;;81     		id = SPFD5420_ReadID();  	/* 读取LCD驱动芯片ID */
00002a  f7fffffe          BL       SPFD5420_ReadID
00002e  4604              MOV      r4,r0
;;;82     		if ((id == 0x5420) || (id ==  0xB509) || (id == 0x5520))
000030  f2454020          MOV      r0,#0x5420
000034  4284              CMP      r4,r0
000036  d007              BEQ      |L38.72|
000038  f24b5009          MOV      r0,#0xb509
00003c  4284              CMP      r4,r0
00003e  d003              BEQ      |L38.72|
000040  f2455020          MOV      r0,#0x5520
000044  4284              CMP      r4,r0
000046  d102              BNE      |L38.78|
                  |L38.72|
;;;83     		{
;;;84     			SPFD5420_InitHard();	/* 初始化5420和4001屏硬件 */
000048  f7fffffe          BL       SPFD5420_InitHard
00004c  e004              B        |L38.88|
                  |L38.78|
;;;85     			/* g_ChipID 在函数内部设置了 */
;;;86     		}
;;;87     		else
;;;88     		{
;;;89     			g_ChipID = IC_8875;
00004e  2075              MOVS     r0,#0x75
000050  4907              LDR      r1,|L38.112|
000052  8008              STRH     r0,[r1,#0]
;;;90     			RA8875_InitHard();	/* 初始化RA8875芯片 */
000054  f7fffffe          BL       RA8875_InitHard
                  |L38.88|
;;;91     		}
;;;92     	}
;;;93     
;;;94     	LCD_SetDirection(0);
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       LCD_SetDirection
;;;95     
;;;96     	LCD_ClrScr(CL_BLACK);	/* 清屏，显示全黑 */
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       LCD_ClrScr
;;;97     	LCD_SetBackLight(BRIGHT_MAX);	 /* 打开背光，设置为缺省亮度 */
000064  20ff              MOVS     r0,#0xff
000066  f7fffffe          BL       LCD_SetBackLight
;;;98     }
00006a  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  |L38.108|
                          DCD      0x00548066
                  |L38.112|
                          DCD      g_ChipID

                          AREA ||i.LCD_PutPixel||, CODE, READONLY, ALIGN=2

                  LCD_PutPixel PROC
;;;743    */
;;;744    void LCD_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;745    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;746    	if (g_ChipID == IC_8875)
000008  480d              LDR      r0,|L39.64|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d105              BNE      |L39.28|
;;;747    	{
;;;748    		RA8875_PutPixel(_usX, _usY, _usColor);
000010  4632              MOV      r2,r6
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RA8875_PutPixel
00001a  e010              B        |L39.62|
                  |L39.28|
;;;749    	}
;;;750    	else if (g_ChipID == IC_9488)
00001c  4808              LDR      r0,|L39.64|
00001e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000020  f2494188          MOV      r1,#0x9488
000024  4288              CMP      r0,r1
000026  d105              BNE      |L39.52|
;;;751    	{
;;;752    		ILI9488_PutPixel(_usX, _usY, _usColor);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       ILI9488_PutPixel
000032  e004              B        |L39.62|
                  |L39.52|
;;;753    	}
;;;754    	else
;;;755    	{
;;;756    		SPFD5420_PutPixel(_usX, _usY, _usColor);
000034  4632              MOV      r2,r6
000036  4629              MOV      r1,r5
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       SPFD5420_PutPixel
                  |L39.62|
;;;757    	}
;;;758    }
00003e  bd70              POP      {r4-r6,pc}
;;;759    
                          ENDP

                  |L39.64|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetBackLight PROC
;;;1999   */
;;;2000   void LCD_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;2001   {
000002  4604              MOV      r4,r0
;;;2002   	s_ucBright =  _bright;	/* 保存背光值 */
000004  4806              LDR      r0,|L40.32|
000006  7004              STRB     r4,[r0,#0]
;;;2003   
;;;2004   	if (g_ChipID == IC_8875)
000008  4806              LDR      r0,|L40.36|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d103              BNE      |L40.24|
;;;2005   	{
;;;2006   		RA8875_SetBackLight(_bright);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetBackLight
000016  e002              B        |L40.30|
                  |L40.24|
;;;2007   	}
;;;2008   	else
;;;2009   	{
;;;2010   		LCD_SetPwmBackLight(_bright);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       LCD_SetPwmBackLight
                  |L40.30|
;;;2011   	}
;;;2012   }
00001e  bd10              POP      {r4,pc}
;;;2013   
                          ENDP

                  |L40.32|
                          DCD      s_ucBright
                  |L40.36|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetDirection||, CODE, READONLY, ALIGN=2

                  LCD_SetDirection PROC
;;;2033   */
;;;2034   void LCD_SetDirection(uint8_t _dir)
000000  b510              PUSH     {r4,lr}
;;;2035   {
000002  4604              MOV      r4,r0
;;;2036   	g_LcdDirection =  _dir;		/* 保存在全局变量 */
000004  4806              LDR      r0,|L41.32|
000006  7004              STRB     r4,[r0,#0]
;;;2037   
;;;2038   	if (g_ChipID == IC_8875)
000008  4806              LDR      r0,|L41.36|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d103              BNE      |L41.24|
;;;2039   	{
;;;2040   		RA8875_SetDirection(_dir);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetDirection
000016  e002              B        |L41.30|
                  |L41.24|
;;;2041   	}
;;;2042   	else
;;;2043   	{
;;;2044   		ILI9488_SetDirection(_dir);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ILI9488_SetDirection
                  |L41.30|
;;;2045   	}
;;;2046   }
00001e  bd10              POP      {r4,pc}
;;;2047   
                          ENDP

                  |L41.32|
                          DCD      g_LcdDirection
                  |L41.36|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetPwmBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetPwmBackLight PROC
;;;1891   */
;;;1892   void LCD_SetPwmBackLight(uint8_t _bright)
000000  b57c              PUSH     {r2-r6,lr}
;;;1893   {
000002  4604              MOV      r4,r0
;;;1894   	#if 1
;;;1895   
;;;1896   	bsp_SetTIMOutPWM(GPIOF, GPIO_Pin_6, TIM10, 1, 100, (_bright * 10000) /255);
000004  f2427010          MOV      r0,#0x2710
000008  4360              MULS     r0,r4,r0
00000a  21ff              MOVS     r1,#0xff
00000c  fb90f5f1          SDIV     r5,r0,r1
000010  2064              MOVS     r0,#0x64
000012  2301              MOVS     r3,#1
000014  4a03              LDR      r2,|L42.36|
000016  2140              MOVS     r1,#0x40
000018  e9cd0500          STRD     r0,r5,[sp,#0]
00001c  4802              LDR      r0,|L42.40|
00001e  f7fffffe          BL       bsp_SetTIMOutPWM
;;;1897   	#else
;;;1898   	/* STM32-V5 使用PF6 / TIM10_CH1 输出PWM, */
;;;1899   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1900   	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;1901   	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;1902   
;;;1903   	/* 第1步：打开GPIO 时钟	*/
;;;1904   	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
;;;1905   
;;;1906   	if (_bright == 0)
;;;1907   	{
;;;1908   		/* 配置背光GPIO为输入模式 */
;;;1909   		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;1910   		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;1911   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;1912   		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;1913   		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;1914   
;;;1915   		GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;1916   
;;;1917   		/* 关闭TIM10 */
;;;1918   		TIM_Cmd(TIM10, DISABLE);
;;;1919   		return;
;;;1920   	}
;;;1921   	else if (_bright == BRIGHT_MAX)	/* 最大亮度 */
;;;1922   	{
;;;1923   		/* 配置背光GPIO为推挽输出模式 */
;;;1924   		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;1925   		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;1926   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;1927   		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;1928   		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;1929   
;;;1930   		GPIO_SetBits(GPIOF, GPIO_Pin_1);
;;;1931   
;;;1932   		/* 关闭TIM8 */
;;;1933   		TIM_Cmd(TIM8, DISABLE);
;;;1934   		return;
;;;1935   	}
;;;1936   
;;;1937   	/* 配置背光GPIO为复用推挽输出模式 */
;;;1938   	GPIO_PinAFConfig(GPIOF, GPIO_PinSource6, GPIO_AF_TIM10);
;;;1939   
;;;1940   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;1941   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;1942   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;1943   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;1944   
;;;1945   	/* 使能TIM10的时钟 */
;;;1946   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM10, ENABLE);
;;;1947   
;;;1948   	/*
;;;1949   		TIM3 配置: 产生1路PWM信号;
;;;1950   		TIM3CLK = 72 MHz, Prescaler = 0(不分频), TIM3 counter clock = 72 MHz
;;;1951   		计算公式：
;;;1952   		PWM输出频率 = TIM3 counter clock /(ARR + 1)
;;;1953   
;;;1954   		我们期望设置为100Hz
;;;1955   
;;;1956   		如果不对TIM3CLK预分频，那么不可能得到100Hz低频。
;;;1957   		我们设置分频比 = 1000， 那么  TIM3 counter clock = 72KHz
;;;1958   		TIM_Period = 720 - 1;
;;;1959   		频率下不来。
;;;1960   	 */
;;;1961   	TIM_TimeBaseStructure.TIM_Period = 720 - 1;	/* TIM_Period = TIM3 ARR Register */
;;;1962   	TIM_TimeBaseStructure.TIM_Prescaler = 0;
;;;1963   	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;1964   	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;1965   
;;;1966   	TIM_TimeBaseInit(TIM10, &TIM_TimeBaseStructure);
;;;1967   
;;;1968   	/* PWM1 Mode configuration: Channel1 */
;;;1969   	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
;;;1970   	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
;;;1971   	/*
;;;1972   		_bright = 1 时, TIM_Pulse = 1
;;;1973   		_bright = 255 时, TIM_Pulse = TIM_Period
;;;1974   	*/
;;;1975   	TIM_OCInitStructure.TIM_Pulse = (TIM_TimeBaseStructure.TIM_Period * _bright) / BRIGHT_MAX;	/* 改变占空比 */
;;;1976   
;;;1977   	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
;;;1978   	TIM_OC1Init(TIM10, &TIM_OCInitStructure);
;;;1979   	TIM_OC1PreloadConfig(TIM10, TIM_OCPreload_Enable);
;;;1980   
;;;1981   	TIM_ARRPreloadConfig(TIM10, ENABLE);
;;;1982   
;;;1983   	/* 使能 TIM8 定时器 */
;;;1984   	TIM_Cmd(TIM10, ENABLE);
;;;1985   
;;;1986   	/* 下面这句话对于TIM1和TIM8是必须的，对于TIM2-TIM6则不必要 */
;;;1987   	//TIM_CtrlPWMOutputs(TIM10, ENABLE);
;;;1988   #endif
;;;1989   }
000022  bd7c              POP      {r2-r6,pc}
;;;1990   
                          ENDP

                  |L42.36|
                          DCD      0x40014400
                  |L42.40|
                          DCD      0x40021400

                          AREA ||.data||, DATA, ALIGN=1

                  g_ChipID
000000  4001              DCW      0x4001
                  g_LcdHeight
000002  00f0              DCW      0x00f0
                  g_LcdWidth
000004  0190              DCW      0x0190
                  s_ucBright
000006  00                DCB      0x00
                  g_LcdDirection
000007  00                DCB      0x00
                  font_width
000008  00                DCB      0x00
                  font_height
000009  00                DCB      0x00
                  width
00000a  0000              DCB      0x00,0x00
                  font_bytes
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\bsp_tft_lcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_tft_lcd_c_g_ChipID____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH|
#line 144
|__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
