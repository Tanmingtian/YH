; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_touch.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_touch.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\bsp_touch.crf ..\User\bsp_stm32f4xx\src\bsp_touch.c]
                          THUMB

                          AREA ||i.CalTwoPoint||, CODE, READONLY, ALIGN=1

                  CalTwoPoint PROC
;;;556    */
;;;557    static int32_t CalTwoPoint(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t x)
000000  b570              PUSH     {r4-r6,lr}
;;;558    {
000002  4604              MOV      r4,r0
000004  9d04              LDR      r5,[sp,#0x10]
;;;559    	return y1 + ((int32_t)(y2 - y1) * (x - x1)) / (x2 - x1);
000006  1a58              SUBS     r0,r3,r1
000008  1b2e              SUBS     r6,r5,r4
00000a  4370              MULS     r0,r6,r0
00000c  1b16              SUBS     r6,r2,r4
00000e  fb90f0f6          SDIV     r0,r0,r6
000012  4408              ADD      r0,r0,r1
;;;560    }
000014  bd70              POP      {r4-r6,pc}
;;;561    
                          ENDP


                          AREA ||i.TOUCH_Abs||, CODE, READONLY, ALIGN=1

                  TOUCH_Abs PROC
;;;930    */
;;;931    int32_t TOUCH_Abs(int32_t x)
000000  4601              MOV      r1,r0
;;;932    {
;;;933    	if (x >= 0)
000002  2900              CMP      r1,#0
000004  db01              BLT      |L2.10|
;;;934    	{
;;;935    		return x;
000006  4608              MOV      r0,r1
                  |L2.8|
;;;936    	}
;;;937    	else
;;;938    	{
;;;939    		return -x;
;;;940    	}
;;;941    }
000008  4770              BX       lr
                  |L2.10|
00000a  4248              RSBS     r0,r1,#0              ;939
00000c  e7fc              B        |L2.8|
;;;942    
                          ENDP


                          AREA ||i.TOUCH_Calibration||, CODE, READONLY, ALIGN=2

                  TOUCH_Calibration PROC
;;;950    */
;;;951    void TOUCH_Calibration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;952    {
;;;953    	uint16_t usAdcX;
;;;954    	uint16_t usAdcY;
;;;955    	uint8_t usCount;
;;;956    	uint8_t i;
;;;957    	uint32_t n;
;;;958    
;;;959    	TOUCH_CelarFIFO();		/* 清除无效的触摸事件 */
000004  f7fffffe          BL       TOUCH_CelarFIFO
;;;960    
;;;961    	for (i = 0; i < CALIB_POINT_COUNT; i++)
000008  2600              MOVS     r6,#0
00000a  e03f              B        |L3.140|
                  |L3.12|
;;;962    	{
;;;963    		TOUCH_DispPoint(i);		/* 显示校准点 */
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       TOUCH_DispPoint
;;;964    
;;;965    		TOUCH_WaitRelease(); 	/* 等待触笔释放 */
000012  f7fffffe          BL       TOUCH_WaitRelease
;;;966    
;;;967    		usCount = 0;
000016  f04f0800          MOV      r8,#0
;;;968    		for (n = 0; n < 500; n++)
00001a  2700              MOVS     r7,#0
00001c  e02b              B        |L3.118|
                  |L3.30|
;;;969    		{
;;;970    			usAdcX = TOUCH_ReadAdcX();
00001e  f7fffffe          BL       TOUCH_ReadAdcX
000022  4604              MOV      r4,r0
;;;971    			usAdcY = TOUCH_ReadAdcY();
000024  f7fffffe          BL       TOUCH_ReadAdcY
000028  4605              MOV      r5,r0
;;;972    
;;;973    			if (TOUCH_PressValid(usAdcX, usAdcY))
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TOUCH_PressValid
000032  b1d0              CBZ      r0,|L3.106|
;;;974    			{
;;;975    				if (++usCount > 5)
000034  f1080001          ADD      r0,r8,#1
000038  b2c0              UXTB     r0,r0
00003a  4680              MOV      r8,r0
00003c  2805              CMP      r0,#5
00003e  dd16              BLE      |L3.110|
;;;976    				{
;;;977    					/* 按压有效, 保存校准点ADC采样值 */
;;;978    					if (i == 0)
000040  b91e              CBNZ     r6,|L3.74|
;;;979    					{
;;;980    						g_tTP.usAdcX1 = usAdcX;
000042  483e              LDR      r0,|L3.316|
000044  8004              STRH     r4,[r0,#0]
;;;981    						g_tTP.usAdcY1 = usAdcY;
000046  8045              STRH     r5,[r0,#2]
000048  e00e              B        |L3.104|
                  |L3.74|
;;;982    					}
;;;983    					else if (i == 1)
00004a  2e01              CMP      r6,#1
00004c  d103              BNE      |L3.86|
;;;984    					{
;;;985    						g_tTP.usAdcX2 = usAdcX;
00004e  483b              LDR      r0,|L3.316|
000050  8084              STRH     r4,[r0,#4]
;;;986    						g_tTP.usAdcY2 = usAdcY;
000052  80c5              STRH     r5,[r0,#6]
000054  e008              B        |L3.104|
                  |L3.86|
;;;987    					}
;;;988    					else if (i == 2)
000056  2e02              CMP      r6,#2
000058  d103              BNE      |L3.98|
;;;989    					{
;;;990    						g_tTP.usAdcX3 = usAdcX;
00005a  4838              LDR      r0,|L3.316|
00005c  8104              STRH     r4,[r0,#8]
;;;991    						g_tTP.usAdcY3 = usAdcY;
00005e  8145              STRH     r5,[r0,#0xa]
000060  e002              B        |L3.104|
                  |L3.98|
;;;992    					}
;;;993    					else
;;;994    					{
;;;995    						g_tTP.usAdcX4 = usAdcX;
000062  4836              LDR      r0,|L3.316|
000064  8184              STRH     r4,[r0,#0xc]
;;;996    						g_tTP.usAdcY4 = usAdcY;
000066  81c5              STRH     r5,[r0,#0xe]
                  |L3.104|
;;;997    					}
;;;998    					break;
000068  e008              B        |L3.124|
                  |L3.106|
;;;999    				}
;;;1000   			}
;;;1001   			else
;;;1002   			{
;;;1003   				usCount = 0;
00006a  f04f0800          MOV      r8,#0
                  |L3.110|
;;;1004   			}
;;;1005   			bsp_DelayMS(10);
00006e  200a              MOVS     r0,#0xa
000070  f7fffffe          BL       bsp_DelayMS
000074  1c7f              ADDS     r7,r7,#1              ;968
                  |L3.118|
000076  f5b77ffa          CMP      r7,#0x1f4             ;968
00007a  d3d0              BCC      |L3.30|
                  |L3.124|
00007c  bf00              NOP                            ;998
;;;1006   		}
;;;1007   		if (n == 500)
00007e  f5b77ffa          CMP      r7,#0x1f4
000082  d101              BNE      |L3.136|
                  |L3.132|
;;;1008   		{
;;;1009   			return;
;;;1010   		}
;;;1011   	}
;;;1012   
;;;1013   	TOUCH_WaitRelease(); 	/* 等待触笔释放 */
;;;1014   
;;;1015   	/* 识别触摸的 X, Y 和 显示面板的 X，Y 是否需要交换 */
;;;1016   	g_tTP.XYChange = 0;		/* 1表示X Y需要交换 */
;;;1017   	if (LCD_GetHeight() < LCD_GetWidth())
;;;1018   	{
;;;1019   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) < TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
;;;1020   		{
;;;1021   			g_tTP.XYChange = 1;
;;;1022   		}
;;;1023   	}
;;;1024   	else
;;;1025   	{
;;;1026   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) > TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
;;;1027   		{
;;;1028   			g_tTP.XYChange = 1;
;;;1029   		}
;;;1030   	}
;;;1031   
;;;1032   	g_tTP.usLcdX1 = TP_X1;
;;;1033   	g_tTP.usLcdY1 = TP_Y1;
;;;1034   	g_tTP.usLcdX2 = TP_X2;
;;;1035   	g_tTP.usLcdY2 = TP_Y2;
;;;1036   	g_tTP.usLcdX3 = TP_X3;
;;;1037   	g_tTP.usLcdY3 = TP_Y3;
;;;1038   	g_tTP.usLcdX4 = TP_X3;
;;;1039   	g_tTP.usLcdY4 = TP_Y3;
;;;1040   
;;;1041   	/* 在最后一步，可以将校准参数保存入Flash 或者EEPROM */
;;;1042   	TOUCH_SaveParam();
;;;1043   }
000084  e8bd87f0          POP      {r4-r10,pc}
                  |L3.136|
000088  1c70              ADDS     r0,r6,#1              ;961
00008a  b2c6              UXTB     r6,r0                 ;961
                  |L3.140|
00008c  2e02              CMP      r6,#2                 ;961
00008e  dbbd              BLT      |L3.12|
000090  f7fffffe          BL       TOUCH_WaitRelease
000094  2000              MOVS     r0,#0                 ;1016
000096  4929              LDR      r1,|L3.316|
000098  8408              STRH     r0,[r1,#0x20]         ;1016
00009a  f7fffffe          BL       LCD_GetHeight
00009e  4681              MOV      r9,r0                 ;1017
0000a0  f7fffffe          BL       LCD_GetWidth
0000a4  4581              CMP      r9,r0                 ;1017
0000a6  da14              BGE      |L3.210|
0000a8  4924              LDR      r1,|L3.316|
0000aa  8809              LDRH     r1,[r1,#0]            ;1019  ; g_tTP
0000ac  4a23              LDR      r2,|L3.316|
0000ae  8892              LDRH     r2,[r2,#4]            ;1019  ; g_tTP
0000b0  1a88              SUBS     r0,r1,r2              ;1019
0000b2  f7fffffe          BL       TOUCH_Abs
0000b6  4602              MOV      r2,r0                 ;1019
0000b8  4920              LDR      r1,|L3.316|
0000ba  8849              LDRH     r1,[r1,#2]            ;1019  ; g_tTP
0000bc  4b1f              LDR      r3,|L3.316|
0000be  88db              LDRH     r3,[r3,#6]            ;1019  ; g_tTP
0000c0  1ac8              SUBS     r0,r1,r3              ;1019
0000c2  f7fffffe          BL       TOUCH_Abs
0000c6  4282              CMP      r2,r0                 ;1019
0000c8  da17              BGE      |L3.250|
0000ca  2001              MOVS     r0,#1                 ;1021
0000cc  491b              LDR      r1,|L3.316|
0000ce  8408              STRH     r0,[r1,#0x20]         ;1021
0000d0  e013              B        |L3.250|
                  |L3.210|
0000d2  491a              LDR      r1,|L3.316|
0000d4  8809              LDRH     r1,[r1,#0]            ;1026  ; g_tTP
0000d6  4a19              LDR      r2,|L3.316|
0000d8  8892              LDRH     r2,[r2,#4]            ;1026  ; g_tTP
0000da  1a88              SUBS     r0,r1,r2              ;1026
0000dc  f7fffffe          BL       TOUCH_Abs
0000e0  4602              MOV      r2,r0                 ;1026
0000e2  4916              LDR      r1,|L3.316|
0000e4  8849              LDRH     r1,[r1,#2]            ;1026  ; g_tTP
0000e6  4b15              LDR      r3,|L3.316|
0000e8  88db              LDRH     r3,[r3,#6]            ;1026  ; g_tTP
0000ea  1ac8              SUBS     r0,r1,r3              ;1026
0000ec  f7fffffe          BL       TOUCH_Abs
0000f0  4282              CMP      r2,r0                 ;1026
0000f2  dd02              BLE      |L3.250|
0000f4  2001              MOVS     r0,#1                 ;1028
0000f6  4911              LDR      r1,|L3.316|
0000f8  8408              STRH     r0,[r1,#0x20]         ;1028
                  |L3.250|
0000fa  2014              MOVS     r0,#0x14              ;1032
0000fc  490f              LDR      r1,|L3.316|
0000fe  8208              STRH     r0,[r1,#0x10]         ;1032
000100  8248              STRH     r0,[r1,#0x12]         ;1033
000102  f7fffffe          BL       LCD_GetWidth
000106  3814              SUBS     r0,r0,#0x14           ;1034
000108  490c              LDR      r1,|L3.316|
00010a  8288              STRH     r0,[r1,#0x14]         ;1034
00010c  f7fffffe          BL       LCD_GetHeight
000110  3814              SUBS     r0,r0,#0x14           ;1035
000112  490a              LDR      r1,|L3.316|
000114  82c8              STRH     r0,[r1,#0x16]         ;1035
000116  2014              MOVS     r0,#0x14              ;1036
000118  8308              STRH     r0,[r1,#0x18]         ;1036
00011a  f7fffffe          BL       LCD_GetHeight
00011e  3814              SUBS     r0,r0,#0x14           ;1037
000120  4906              LDR      r1,|L3.316|
000122  8348              STRH     r0,[r1,#0x1a]         ;1037
000124  2014              MOVS     r0,#0x14              ;1038
000126  8388              STRH     r0,[r1,#0x1c]         ;1038
000128  f7fffffe          BL       LCD_GetHeight
00012c  3814              SUBS     r0,r0,#0x14           ;1039
00012e  4903              LDR      r1,|L3.316|
000130  83c8              STRH     r0,[r1,#0x1e]         ;1039
000132  f7fffffe          BL       TOUCH_SaveParam
000136  bf00              NOP      
000138  e7a4              B        |L3.132|
;;;1044   
                          ENDP

00013a  0000              DCW      0x0000
                  |L3.316|
                          DCD      g_tTP

                          AREA ||i.TOUCH_CelarFIFO||, CODE, READONLY, ALIGN=2

                  TOUCH_CelarFIFO PROC
;;;358    */
;;;359    void TOUCH_CelarFIFO(void)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;362    	g_tTP.Write = g_tTP.Read;
000008  4804              LDR      r0,|L4.28|
00000a  f8900038          LDRB     r0,[r0,#0x38]  ; g_tTP
00000e  4903              LDR      r1,|L4.28|
000010  f8810039          STRB     r0,[r1,#0x39]
;;;363    	__set_PRIMASK(0);  		/* 开中断 */
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       __set_PRIMASK
;;;364    }
00001a  bd10              POP      {r4,pc}
;;;365    
                          ENDP

                  |L4.28|
                          DCD      g_tTP

                          AREA ||i.TOUCH_DataFilter||, CODE, READONLY, ALIGN=1

                  TOUCH_DataFilter PROC
;;;771    */
;;;772    static uint16_t TOUCH_DataFilter(uint16_t *_pBuf, uint8_t _ucCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;773    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;774    #if 0
;;;775    	uint8_t i;
;;;776    	uint32_t uiSum;
;;;777    
;;;778    	uiSum = 0;
;;;779    	for (i = 0; i < _ucCount; i++)
;;;780    	{
;;;781    		uiSum += _pBuf[i];
;;;782    	}
;;;783    	return uiSum / _ucCount;
;;;784    #else
;;;785    	uint8_t flag;
;;;786    	uint8_t i;
;;;787    	uint16_t usTemp;
;;;788    	uint32_t uiSum;
;;;789    
;;;790    	/* 升序排列 */
;;;791        do
000006  bf00              NOP      
                  |L5.8|
;;;792    	{
;;;793    		flag = 0;
000008  2500              MOVS     r5,#0
;;;794    		for (i = 0; i < _ucCount - 1; i++)
00000a  2100              MOVS     r1,#0
00000c  e012              B        |L5.52|
                  |L5.14|
;;;795    		{
;;;796    			if (_pBuf[i] > _pBuf[i+1])
00000e  f8327011          LDRH     r7,[r2,r1,LSL #1]
000012  1c4e              ADDS     r6,r1,#1
000014  f8326016          LDRH     r6,[r2,r6,LSL #1]
000018  42b7              CMP      r7,r6
00001a  dd09              BLE      |L5.48|
;;;797    			{
;;;798    				usTemp = _pBuf[i + 1];
00001c  1c4e              ADDS     r6,r1,#1
00001e  f8320016          LDRH     r0,[r2,r6,LSL #1]
;;;799    				_pBuf[i+1] = _pBuf[i];
000022  f8327011          LDRH     r7,[r2,r1,LSL #1]
000026  f8227016          STRH     r7,[r2,r6,LSL #1]
;;;800    				_pBuf[i] = usTemp;
00002a  f8220011          STRH     r0,[r2,r1,LSL #1]
;;;801    				flag = 1;
00002e  2501              MOVS     r5,#1
                  |L5.48|
000030  1c4e              ADDS     r6,r1,#1              ;794
000032  b2f1              UXTB     r1,r6                 ;794
                  |L5.52|
000034  1e5e              SUBS     r6,r3,#1              ;794
000036  428e              CMP      r6,r1                 ;794
000038  dce9              BGT      |L5.14|
;;;802    			}
;;;803    		}
;;;804    	}while(flag);
00003a  2d00              CMP      r5,#0
00003c  d1e4              BNE      |L5.8|
;;;805    
;;;806    	uiSum = 0;
00003e  2400              MOVS     r4,#0
;;;807    	for (i = 0; i < _ucCount / 3; i++)
000040  2100              MOVS     r1,#0
000042  e008              B        |L5.86|
                  |L5.68|
;;;808    	{
;;;809    		uiSum += _pBuf[_ucCount / 3 + i];
000044  2603              MOVS     r6,#3
000046  fb93f6f6          SDIV     r6,r3,r6
00004a  440e              ADD      r6,r6,r1
00004c  f8326016          LDRH     r6,[r2,r6,LSL #1]
000050  4434              ADD      r4,r4,r6
000052  1c4e              ADDS     r6,r1,#1              ;807
000054  b2f1              UXTB     r1,r6                 ;807
                  |L5.86|
000056  2603              MOVS     r6,#3                 ;807
000058  fb93f6f6          SDIV     r6,r3,r6              ;807
00005c  428e              CMP      r6,r1                 ;807
00005e  dcf1              BGT      |L5.68|
;;;810    	}
;;;811    	usTemp = uiSum / (_ucCount / 3);
000060  2603              MOVS     r6,#3
000062  fb93f6f6          SDIV     r6,r3,r6
000066  fbb4f6f6          UDIV     r6,r4,r6
00006a  b2b0              UXTH     r0,r6
;;;812    	return usTemp;
;;;813    #endif
;;;814    }
00006c  bdf0              POP      {r4-r7,pc}
;;;815    
                          ENDP


                          AREA ||i.TOUCH_DispPoint||, CODE, READONLY, ALIGN=2

                  TOUCH_DispPoint PROC
;;;823    */
;;;824    static void TOUCH_DispPoint(uint8_t _ucIndex)
000000  b5fe              PUSH     {r1-r7,lr}
;;;825    {
000002  4604              MOV      r4,r0
;;;826    	FONT_T tFont16;			/* 定义一个字体结构体变量，用于设置字体参数 */
;;;827    
;;;828    	/* 设置字体参数 */
;;;829    	{
;;;830    		tFont16.FontCode = FC_ST_16;	/* 字体代码 16点阵 */
000004  2000              MOVS     r0,#0
000006  f8ad0004          STRH     r0,[sp,#4]
;;;831    		tFont16.FrontColor = CL_WHITE;		/* 字体颜色 0 或 1 */
00000a  f64f70ff          MOV      r0,#0xffff
00000e  f8ad0006          STRH     r0,[sp,#6]
;;;832    		tFont16.BackColor = CL_BLUE;	/* 文字背景颜色 */
000012  201f              MOVS     r0,#0x1f
000014  f8ad0008          STRH     r0,[sp,#8]
;;;833    		tFont16.Space = 0;			/* 文字间距，单位 = 像素 */
000018  2000              MOVS     r0,#0
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;834    	}
;;;835    
;;;836    /*
;;;837    	第1个点 ： x1 = CALIB_OFFSET, y1 = CALIB_OFFSET
;;;838    	第2个点 ： x2 = LCD_GetHeight() - CALIB_OFFSET, y2 = LCD_GetWidth - CALIB_OFFSET
;;;839    */
;;;840    	if (_ucIndex == 0)
00001e  bb84              CBNZ     r4,|L6.130|
;;;841    	{
;;;842    		LCD_ClrScr(CL_BLUE);  		/* 清屏，背景蓝色 */
000020  201f              MOVS     r0,#0x1f
000022  f7fffffe          BL       LCD_ClrScr
;;;843    
;;;844    		/* 在屏幕边沿绘制2个矩形框(用于检测面板边缘像素是否正常) */
;;;845    		LCD_DrawRect(0, 0, LCD_GetHeight(), LCD_GetWidth(), CL_WHITE);
000026  f7fffffe          BL       LCD_GetWidth
00002a  4605              MOV      r5,r0
00002c  f7fffffe          BL       LCD_GetHeight
000030  4606              MOV      r6,r0
000032  f64f70ff          MOV      r0,#0xffff
000036  462b              MOV      r3,r5
000038  4632              MOV      r2,r6
00003a  2100              MOVS     r1,#0
00003c  9000              STR      r0,[sp,#0]
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       LCD_DrawRect
;;;846    		LCD_DrawRect(2, 2, LCD_GetHeight() - 4, LCD_GetWidth() - 4, CL_YELLOW);
000044  f7fffffe          BL       LCD_GetWidth
000048  1f00              SUBS     r0,r0,#4
00004a  b285              UXTH     r5,r0
00004c  f7fffffe          BL       LCD_GetHeight
000050  1f00              SUBS     r0,r0,#4
000052  b286              UXTH     r6,r0
000054  f64f70e0          MOV      r0,#0xffe0
000058  462b              MOV      r3,r5
00005a  4632              MOV      r2,r6
00005c  2102              MOVS     r1,#2
00005e  9000              STR      r0,[sp,#0]
000060  4608              MOV      r0,r1
000062  f7fffffe          BL       LCD_DrawRect
;;;847    
;;;848    		LCD_DispStr(50, 10, "校准触摸屏", &tFont16);		/* 在(8,3)坐标处显示一串汉字 */
000066  ab01              ADD      r3,sp,#4
000068  a22b              ADR      r2,|L6.280|
00006a  210a              MOVS     r1,#0xa
00006c  2032              MOVS     r0,#0x32
00006e  f7fffffe          BL       LCD_DispStr
;;;849    
;;;850    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_WHITE);
000072  f64f73ff          MOV      r3,#0xffff
000076  2206              MOVS     r2,#6
000078  2114              MOVS     r1,#0x14
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       LCD_DrawCircle
000080  e049              B        |L6.278|
                  |L6.130|
000082  e7ff              B        |L6.132|
                  |L6.132|
;;;851    	}
;;;852    	else if (_ucIndex == 1)
000084  2c01              CMP      r4,#1
000086  d115              BNE      |L6.180|
;;;853    	{
;;;854    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_BLUE);			/* 擦除第1个点 */
000088  231f              MOVS     r3,#0x1f
00008a  2206              MOVS     r2,#6
00008c  2114              MOVS     r1,#0x14
00008e  4608              MOV      r0,r1
000090  f7fffffe          BL       LCD_DrawCircle
;;;855    
;;;856    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_WHITE);
000094  f7fffffe          BL       LCD_GetHeight
000098  3814              SUBS     r0,r0,#0x14
00009a  b285              UXTH     r5,r0
00009c  f7fffffe          BL       LCD_GetWidth
0000a0  3814              SUBS     r0,r0,#0x14
0000a2  b286              UXTH     r6,r0
0000a4  f64f73ff          MOV      r3,#0xffff
0000a8  2206              MOVS     r2,#6
0000aa  4629              MOV      r1,r5
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       LCD_DrawCircle
0000b2  e030              B        |L6.278|
                  |L6.180|
;;;857    	}
;;;858    	else if (_ucIndex == 2)
0000b4  2c02              CMP      r4,#2
0000b6  d119              BNE      |L6.236|
;;;859    	{
;;;860    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_BLUE);			/* 擦除第2个点 */
0000b8  f7fffffe          BL       LCD_GetHeight
0000bc  3814              SUBS     r0,r0,#0x14
0000be  b285              UXTH     r5,r0
0000c0  f7fffffe          BL       LCD_GetWidth
0000c4  3814              SUBS     r0,r0,#0x14
0000c6  b286              UXTH     r6,r0
0000c8  231f              MOVS     r3,#0x1f
0000ca  2206              MOVS     r2,#6
0000cc  4629              MOV      r1,r5
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       LCD_DrawCircle
;;;861    
;;;862    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_WHITE);
0000d4  f7fffffe          BL       LCD_GetHeight
0000d8  3814              SUBS     r0,r0,#0x14
0000da  b285              UXTH     r5,r0
0000dc  f64f73ff          MOV      r3,#0xffff
0000e0  2206              MOVS     r2,#6
0000e2  4629              MOV      r1,r5
0000e4  2014              MOVS     r0,#0x14
0000e6  f7fffffe          BL       LCD_DrawCircle
0000ea  e014              B        |L6.278|
                  |L6.236|
;;;863    	}
;;;864    	else
;;;865    	{
;;;866    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_BLUE);			/* 擦除第3个点 */
0000ec  f7fffffe          BL       LCD_GetHeight
0000f0  3814              SUBS     r0,r0,#0x14
0000f2  b285              UXTH     r5,r0
0000f4  231f              MOVS     r3,#0x1f
0000f6  2206              MOVS     r2,#6
0000f8  4629              MOV      r1,r5
0000fa  2014              MOVS     r0,#0x14
0000fc  f7fffffe          BL       LCD_DrawCircle
;;;867    
;;;868    		LCD_DrawCircle(TP_X4, TP_Y4, 6, CL_WHITE);
000100  f7fffffe          BL       LCD_GetWidth
000104  3814              SUBS     r0,r0,#0x14
000106  b285              UXTH     r5,r0
000108  f64f73ff          MOV      r3,#0xffff
00010c  2206              MOVS     r2,#6
00010e  2114              MOVS     r1,#0x14
000110  4628              MOV      r0,r5
000112  f7fffffe          BL       LCD_DrawCircle
                  |L6.278|
;;;869    	}
;;;870    }
000116  bdfe              POP      {r1-r7,pc}
;;;871    
                          ENDP

                  |L6.280|
000118  d0a3d7bc          DCB      208,163,215,188,180,165,195,254,198,193,0
00011c  b4a5c3fe
000120  c6c100  
000123  00                DCB      0

                          AREA ||i.TOUCH_GetKey||, CODE, READONLY, ALIGN=2

                  TOUCH_GetKey PROC
;;;328    */
;;;329    uint8_t TOUCH_GetKey(int16_t *_pX, int16_t *_pY)
000000  b510              PUSH     {r4,lr}
;;;330    {
000002  4602              MOV      r2,r0
;;;331    	uint8_t ret;
;;;332    
;;;333    	if (g_tTP.Read == g_tTP.Write)
000004  4815              LDR      r0,|L7.92|
000006  f8900038          LDRB     r0,[r0,#0x38]  ; g_tTP
00000a  4c14              LDR      r4,|L7.92|
00000c  f8944039          LDRB     r4,[r4,#0x39]  ; g_tTP
000010  42a0              CMP      r0,r4
000012  d101              BNE      |L7.24|
;;;334    	{
;;;335    		return TOUCH_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;336    	}
;;;337    	else
;;;338    	{
;;;339    		ret = g_tTP.Event[g_tTP.Read];
;;;340    		*_pX = g_tTP.XBuf[g_tTP.Read];
;;;341    		*_pY = g_tTP.YBuf[g_tTP.Read];
;;;342    
;;;343    		if (++g_tTP.Read >= TOUCH_FIFO_SIZE)
;;;344    		{
;;;345    			g_tTP.Read = 0;
;;;346    		}
;;;347    		return ret;
;;;348    	}
;;;349    }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  4810              LDR      r0,|L7.92|
00001a  f8904038          LDRB     r4,[r0,#0x38]         ;339  ; g_tTP
00001e  3029              ADDS     r0,r0,#0x29           ;339
000020  5d03              LDRB     r3,[r0,r4]            ;339
000022  3829              SUBS     r0,r0,#0x29           ;340
000024  f8904038          LDRB     r4,[r0,#0x38]         ;340  ; g_tTP
000028  302c              ADDS     r0,r0,#0x2c           ;340
00002a  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;340
00002e  8010              STRH     r0,[r2,#0]            ;340
000030  480a              LDR      r0,|L7.92|
000032  f8904038          LDRB     r4,[r0,#0x38]         ;341  ; g_tTP
000036  3032              ADDS     r0,r0,#0x32           ;341
000038  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;341
00003c  8008              STRH     r0,[r1,#0]            ;341
00003e  4807              LDR      r0,|L7.92|
000040  f8900038          LDRB     r0,[r0,#0x38]         ;343  ; g_tTP
000044  1c40              ADDS     r0,r0,#1              ;343
000046  b2c0              UXTB     r0,r0                 ;343
000048  4c04              LDR      r4,|L7.92|
00004a  f8840038          STRB     r0,[r4,#0x38]         ;343
00004e  2803              CMP      r0,#3                 ;343
000050  db02              BLT      |L7.88|
000052  2000              MOVS     r0,#0                 ;345
000054  f8840038          STRB     r0,[r4,#0x38]         ;345
                  |L7.88|
000058  4618              MOV      r0,r3                 ;347
00005a  e7dc              B        |L7.22|
;;;350    
                          ENDP

                  |L7.92|
                          DCD      g_tTP

                          AREA ||i.TOUCH_GetX||, CODE, READONLY, ALIGN=1

                  TOUCH_GetX PROC
;;;745    */
;;;746    int16_t TOUCH_GetX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;747    {
;;;748    	return TOUCH_TransX(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4604              MOV      r4,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  4605              MOV      r5,r0
00000e  4621              MOV      r1,r4
000010  f7fffffe          BL       TOUCH_TransX
;;;749    }
000014  bd70              POP      {r4-r6,pc}
;;;750    
                          ENDP


                          AREA ||i.TOUCH_GetY||, CODE, READONLY, ALIGN=1

                  TOUCH_GetY PROC
;;;758    */
;;;759    int16_t TOUCH_GetY(void)
000000  b570              PUSH     {r4-r6,lr}
;;;760    {
;;;761    	return TOUCH_TransY(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4604              MOV      r4,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  4605              MOV      r5,r0
00000e  4621              MOV      r1,r4
000010  f7fffffe          BL       TOUCH_TransY
;;;762    }
000014  bd70              POP      {r4-r6,pc}
;;;763    
                          ENDP


                          AREA ||i.TOUCH_InRect||, CODE, READONLY, ALIGN=1

                  TOUCH_InRect PROC
;;;375    */
;;;376    uint8_t TOUCH_InRect(uint16_t _usX, uint16_t _usY,
000000  b570              PUSH     {r4-r6,lr}
;;;377    	uint16_t _usRectX, uint16_t _usRectY, uint16_t _usRectH, uint16_t _usRectW)
;;;378    {
000002  4604              MOV      r4,r0
000004  e9dd5604          LDRD     r5,r6,[sp,#0x10]
;;;379    	if ((_usX > _usRectX) && (_usX < _usRectX + _usRectW)
000008  4294              CMP      r4,r2
00000a  dd09              BLE      |L10.32|
00000c  1990              ADDS     r0,r2,r6
00000e  42a0              CMP      r0,r4
000010  dd06              BLE      |L10.32|
;;;380    		&& (_usY > _usRectY) && (_usY < _usRectY + _usRectH))
000012  4299              CMP      r1,r3
000014  dd04              BLE      |L10.32|
000016  1958              ADDS     r0,r3,r5
000018  4288              CMP      r0,r1
00001a  dd01              BLE      |L10.32|
;;;381    	{
;;;382    		return 1;
00001c  2001              MOVS     r0,#1
                  |L10.30|
;;;383    	}
;;;384    	else
;;;385    	{
;;;386    		return 0;
;;;387    	}
;;;388    }
00001e  bd70              POP      {r4-r6,pc}
                  |L10.32|
000020  2000              MOVS     r0,#0                 ;386
000022  e7fc              B        |L10.30|
;;;389    
                          ENDP


                          AREA ||i.TOUCH_InitHard||, CODE, READONLY, ALIGN=2

                  TOUCH_InitHard PROC
;;;106    */
;;;107    void TOUCH_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109    	uint16_t i;
;;;110    	
;;;111        g_tTP.Enable = 0;
000002  2000              MOVS     r0,#0
000004  4918              LDR      r1,|L11.104|
000006  f8810028          STRB     r0,[r1,#0x28]
;;;112    
;;;113    	/* 50ms，等待GT811复位就绪，才能探测GT811芯片 ID */
;;;114    	for (i = 0; i < 5; i++)
00000a  2400              MOVS     r4,#0
00000c  e00b              B        |L11.38|
                  |L11.14|
;;;115    	{
;;;116    		if (i2c_CheckDevice(GT811_I2C_ADDR) == 0)
00000e  20ba              MOVS     r0,#0xba
000010  f7fffffe          BL       i2c_CheckDevice
000014  b910              CBNZ     r0,|L11.28|
;;;117    		{
;;;118    			GT811_InitHard();
000016  f7fffffe          BL       GT811_InitHard
;;;119    			break;
00001a  e006              B        |L11.42|
                  |L11.28|
;;;120    		}
;;;121    		bsp_DelayMS(10);
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       bsp_DelayMS
000022  1c60              ADDS     r0,r4,#1              ;114
000024  b284              UXTH     r4,r0                 ;114
                  |L11.38|
000026  2c05              CMP      r4,#5                 ;114
000028  dbf1              BLT      |L11.14|
                  |L11.42|
00002a  bf00              NOP                            ;119
;;;122    	}
;;;123    		
;;;124    	if (g_ChipID == IC_8875)
00002c  480f              LDR      r0,|L11.108|
00002e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000030  2875              CMP      r0,#0x75
000032  d106              BNE      |L11.66|
;;;125    	{
;;;126    		RA8875_TouchInit();//
000034  f7fffffe          BL       RA8875_TouchInit
;;;127    
;;;128    		g_tTP.usMaxAdc = 1023;	/* 10位ADC */
000038  f24030ff          MOV      r0,#0x3ff
00003c  490a              LDR      r1,|L11.104|
00003e  8448              STRH     r0,[r1,#0x22]
000040  e005              B        |L11.78|
                  |L11.66|
;;;129    	}
;;;130    	else
;;;131    	{	
;;;132    		TSC2046_InitHard();//电阻触摸芯片驱动
000042  f7fffffe          BL       TSC2046_InitHard
;;;133    
;;;134    		g_tTP.usMaxAdc = 4095;	/* 12位ADC */
000046  f64070ff          MOV      r0,#0xfff
00004a  4907              LDR      r1,|L11.104|
00004c  8448              STRH     r0,[r1,#0x22]
                  |L11.78|
;;;135    	}
;;;136    
;;;137    	TOUCH_LoadParam();	/* 读取校准参数 */
00004e  f7fffffe          BL       TOUCH_LoadParam
;;;138    
;;;139        g_tTP.Write = g_tTP.Read = 0;
000052  2000              MOVS     r0,#0
000054  4904              LDR      r1,|L11.104|
000056  f8810038          STRB     r0,[r1,#0x38]
00005a  f8810039          STRB     r0,[r1,#0x39]
;;;140    
;;;141    	g_tTP.Enable = 1;
00005e  2001              MOVS     r0,#1
000060  f8810028          STRB     r0,[r1,#0x28]
;;;142    }
000064  bd10              POP      {r4,pc}
;;;143    
                          ENDP

000066  0000              DCW      0x0000
                  |L11.104|
                          DCD      g_tTP
                  |L11.108|
                          DCD      g_ChipID

                          AREA ||i.TOUCH_LoadParam||, CODE, READONLY, ALIGN=2

                  TOUCH_LoadParam PROC
;;;1091   extern void LoadParam(void);
;;;1092   static void TOUCH_LoadParam(void)
000000  b510              PUSH     {r4,lr}
;;;1093   {
;;;1094   #if 1
;;;1095   	LoadParam();	/* 从Flash中读取参数 */
000002  f7fffffe          BL       LoadParam
;;;1096   
;;;1097   	g_tTP.usAdcX1 = g_tParam.usAdcX1;
000006  482b              LDR      r0,|L12.180|
000008  8900              LDRH     r0,[r0,#8]  ; g_tParam
00000a  492b              LDR      r1,|L12.184|
00000c  8008              STRH     r0,[r1,#0]
;;;1098   	g_tTP.usAdcY1 = g_tParam.usAdcY1;
00000e  4829              LDR      r0,|L12.180|
000010  8940              LDRH     r0,[r0,#0xa]  ; g_tParam
000012  8048              STRH     r0,[r1,#2]
;;;1099   	g_tTP.usAdcX2 = g_tParam.usAdcX2;
000014  4827              LDR      r0,|L12.180|
000016  8980              LDRH     r0,[r0,#0xc]  ; g_tParam
000018  8088              STRH     r0,[r1,#4]
;;;1100   	g_tTP.usAdcY2 = g_tParam.usAdcY2;
00001a  4826              LDR      r0,|L12.180|
00001c  89c0              LDRH     r0,[r0,#0xe]  ; g_tParam
00001e  80c8              STRH     r0,[r1,#6]
;;;1101   	g_tTP.usAdcX3 = g_tParam.usAdcX3;
000020  4824              LDR      r0,|L12.180|
000022  8a00              LDRH     r0,[r0,#0x10]  ; g_tParam
000024  8108              STRH     r0,[r1,#8]
;;;1102   	g_tTP.usAdcY3 = g_tParam.usAdcY3;
000026  4823              LDR      r0,|L12.180|
000028  8a40              LDRH     r0,[r0,#0x12]  ; g_tParam
00002a  8148              STRH     r0,[r1,#0xa]
;;;1103   	g_tTP.usAdcX4 = g_tParam.usAdcX4;
00002c  4821              LDR      r0,|L12.180|
00002e  8a80              LDRH     r0,[r0,#0x14]  ; g_tParam
000030  8188              STRH     r0,[r1,#0xc]
;;;1104   	g_tTP.usAdcY4 = g_tParam.usAdcY4;
000032  4820              LDR      r0,|L12.180|
000034  8ac0              LDRH     r0,[r0,#0x16]  ; g_tParam
000036  81c8              STRH     r0,[r1,#0xe]
;;;1105   
;;;1106   	g_tTP.usLcdX1 = g_tParam.usLcdX1;
000038  481e              LDR      r0,|L12.180|
00003a  8b00              LDRH     r0,[r0,#0x18]  ; g_tParam
00003c  8208              STRH     r0,[r1,#0x10]
;;;1107   	g_tTP.usLcdY1 = g_tParam.usLcdY1;
00003e  481d              LDR      r0,|L12.180|
000040  8b40              LDRH     r0,[r0,#0x1a]  ; g_tParam
000042  8248              STRH     r0,[r1,#0x12]
;;;1108   	g_tTP.usLcdX2 = g_tParam.usLcdX2;
000044  481b              LDR      r0,|L12.180|
000046  8b80              LDRH     r0,[r0,#0x1c]  ; g_tParam
000048  8288              STRH     r0,[r1,#0x14]
;;;1109   	g_tTP.usLcdY2 = g_tParam.usLcdY2;
00004a  481a              LDR      r0,|L12.180|
00004c  8bc0              LDRH     r0,[r0,#0x1e]  ; g_tParam
00004e  82c8              STRH     r0,[r1,#0x16]
;;;1110   	g_tTP.usLcdX3 = g_tParam.usLcdX3;
000050  4818              LDR      r0,|L12.180|
000052  8c00              LDRH     r0,[r0,#0x20]  ; g_tParam
000054  8308              STRH     r0,[r1,#0x18]
;;;1111   	g_tTP.usLcdY3 = g_tParam.usLcdY3;
000056  4817              LDR      r0,|L12.180|
000058  8c40              LDRH     r0,[r0,#0x22]  ; g_tParam
00005a  8348              STRH     r0,[r1,#0x1a]
;;;1112   	g_tTP.usLcdX4 = g_tParam.usLcdX4;
00005c  4815              LDR      r0,|L12.180|
00005e  8c80              LDRH     r0,[r0,#0x24]  ; g_tParam
000060  8388              STRH     r0,[r1,#0x1c]
;;;1113   	g_tTP.usLcdY4 = g_tParam.usLcdY4;
000062  4814              LDR      r0,|L12.180|
000064  8cc0              LDRH     r0,[r0,#0x26]  ; g_tParam
000066  83c8              STRH     r0,[r1,#0x1e]
;;;1114   
;;;1115   	g_tTP.XYChange = g_tParam.XYChange;
000068  4812              LDR      r0,|L12.180|
00006a  7980              LDRB     r0,[r0,#6]  ; g_tParam
00006c  8408              STRH     r0,[r1,#0x20]
;;;1116   	
;;;1117   	g_tTP.usAdcX1 = 955;
00006e  f24030bb          MOV      r0,#0x3bb
000072  8008              STRH     r0,[r1,#0]
;;;1118   	g_tTP.usAdcY1 = 888;
000074  f44f705e          MOV      r0,#0x378
000078  8048              STRH     r0,[r1,#2]
;;;1119   	g_tTP.usAdcX2 = 68;
00007a  2044              MOVS     r0,#0x44
00007c  8088              STRH     r0,[r1,#4]
;;;1120   	g_tTP.usAdcY2 = 88;
00007e  2058              MOVS     r0,#0x58
000080  80c8              STRH     r0,[r1,#6]
;;;1121   	g_tTP.usAdcX3 = 0;
000082  2000              MOVS     r0,#0
000084  8108              STRH     r0,[r1,#8]
;;;1122   	g_tTP.usAdcY3 = 0;
000086  8148              STRH     r0,[r1,#0xa]
;;;1123   	g_tTP.usAdcX4 = 0;
000088  8188              STRH     r0,[r1,#0xc]
;;;1124   	g_tTP.usAdcY4 = 0;
00008a  81c8              STRH     r0,[r1,#0xe]
;;;1125   
;;;1126   	g_tTP.usLcdX1 = 20;
00008c  2014              MOVS     r0,#0x14
00008e  8208              STRH     r0,[r1,#0x10]
;;;1127   	g_tTP.usLcdY1 = 20;
000090  8248              STRH     r0,[r1,#0x12]
;;;1128   	g_tTP.usLcdX2 = 780;
000092  f44f7043          MOV      r0,#0x30c
000096  8288              STRH     r0,[r1,#0x14]
;;;1129   	g_tTP.usLcdY2 = 460;
000098  f44f70e6          MOV      r0,#0x1cc
00009c  82c8              STRH     r0,[r1,#0x16]
;;;1130   	g_tTP.usLcdX3 = 20;
00009e  2014              MOVS     r0,#0x14
0000a0  8308              STRH     r0,[r1,#0x18]
;;;1131   	g_tTP.usLcdY3 = 460;
0000a2  f44f70e6          MOV      r0,#0x1cc
0000a6  8348              STRH     r0,[r1,#0x1a]
;;;1132   	g_tTP.usLcdX4 = 20;
0000a8  2014              MOVS     r0,#0x14
0000aa  8388              STRH     r0,[r1,#0x1c]
;;;1133   	g_tTP.usLcdY4 = 460;
0000ac  f44f70e6          MOV      r0,#0x1cc
0000b0  83c8              STRH     r0,[r1,#0x1e]
;;;1134   #endif
;;;1135   }
0000b2  bd10              POP      {r4,pc}
;;;1136   
                          ENDP

                  |L12.180|
                          DCD      g_tParam
                  |L12.184|
                          DCD      g_tTP

                          AREA ||i.TOUCH_MoveValid||, CODE, READONLY, ALIGN=2

                  TOUCH_MoveValid PROC
;;;398    */
;;;399    uint8_t TOUCH_MoveValid(uint16_t _usX1, uint16_t _usY1, uint16_t _usX2, uint16_t _usY2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;400    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;401    	int16_t iX, iY;
;;;402    	static uint8_t s_invalid_count = 0;
;;;403    
;;;404    	iX = TOUCH_Abs(_usX1 - _usX2);
000006  1aa0              SUBS     r0,r4,r2
000008  f7fffffe          BL       TOUCH_Abs
00000c  b206              SXTH     r6,r0
;;;405    	iY = TOUCH_Abs(_usY1 - _usY2);
00000e  1ae8              SUBS     r0,r5,r3
000010  f7fffffe          BL       TOUCH_Abs
000014  b207              SXTH     r7,r0
;;;406    
;;;407    	if ((iX < 25) && (iY < 25))
000016  2e19              CMP      r6,#0x19
000018  da06              BGE      |L13.40|
00001a  2f19              CMP      r7,#0x19
00001c  da04              BGE      |L13.40|
;;;408    	{
;;;409    		s_invalid_count = 0;
00001e  2000              MOVS     r0,#0
000020  4908              LDR      r1,|L13.68|
000022  7008              STRB     r0,[r1,#0]
;;;410    		return 1;
000024  2001              MOVS     r0,#1
                  |L13.38|
;;;411    	}
;;;412    	else
;;;413    	{
;;;414    		if (++s_invalid_count >= 3)
;;;415    		{
;;;416    			s_invalid_count = 0;
;;;417    			return 1;
;;;418    		}
;;;419    		return 0;
;;;420    	}
;;;421    }
000026  bdf0              POP      {r4-r7,pc}
                  |L13.40|
000028  4806              LDR      r0,|L13.68|
00002a  7800              LDRB     r0,[r0,#0]            ;414  ; s_invalid_count
00002c  1c40              ADDS     r0,r0,#1              ;414
00002e  b2c0              UXTB     r0,r0                 ;414
000030  4904              LDR      r1,|L13.68|
000032  7008              STRB     r0,[r1,#0]            ;414
000034  2803              CMP      r0,#3                 ;414
000036  db03              BLT      |L13.64|
000038  2000              MOVS     r0,#0                 ;416
00003a  7008              STRB     r0,[r1,#0]            ;416
00003c  2001              MOVS     r0,#1                 ;417
00003e  e7f2              B        |L13.38|
                  |L13.64|
000040  2000              MOVS     r0,#0                 ;419
000042  e7f0              B        |L13.38|
;;;422    
                          ENDP

                  |L13.68|
                          DCD      s_invalid_count

                          AREA ||i.TOUCH_PressValid||, CODE, READONLY, ALIGN=2

                  TOUCH_PressValid PROC
;;;879    */
;;;880    static uint8_t	TOUCH_PressValid(uint16_t _usX, uint16_t _usY)
000000  4602              MOV      r2,r0
;;;881    {
;;;882    	if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
000002  2a02              CMP      r2,#2
000004  dd0b              BLE      |L14.30|
000006  2902              CMP      r1,#2
000008  dd09              BLE      |L14.30|
;;;883    		|| (_usX >= g_tTP.usMaxAdc - ADC_VALID_OFFSET)
00000a  4807              LDR      r0,|L14.40|
00000c  8c40              LDRH     r0,[r0,#0x22]  ; g_tTP
00000e  1e80              SUBS     r0,r0,#2
000010  4290              CMP      r0,r2
000012  dd04              BLE      |L14.30|
;;;884    		|| (_usY >= g_tTP.usMaxAdc - ADC_VALID_OFFSET))
000014  4804              LDR      r0,|L14.40|
000016  8c40              LDRH     r0,[r0,#0x22]  ; g_tTP
000018  1e80              SUBS     r0,r0,#2
00001a  4288              CMP      r0,r1
00001c  dc01              BGT      |L14.34|
                  |L14.30|
;;;885    	{
;;;886    		return 0;
00001e  2000              MOVS     r0,#0
                  |L14.32|
;;;887    	}
;;;888    	else
;;;889    	{
;;;890    		return 1;
;;;891    	}
;;;892    }
000020  4770              BX       lr
                  |L14.34|
000022  2001              MOVS     r0,#1                 ;890
000024  e7fc              B        |L14.32|
;;;893    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      g_tTP

                          AREA ||i.TOUCH_PutKey||, CODE, READONLY, ALIGN=2

                  TOUCH_PutKey PROC
;;;189    */
;;;190    void TOUCH_PutKey(uint8_t _ucEvent, uint16_t _usX, uint16_t _usY)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;191    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;192    	uint16_t xx, yy;
;;;193    	uint16_t x = 0, y = 0;
00000a  f04f0900          MOV      r9,#0
00000e  46ca              MOV      r10,r9
;;;194    
;;;195    	g_tTP.Event[g_tTP.Write] = _ucEvent;
000010  4880              LDR      r0,|L15.532|
000012  f8901039          LDRB     r1,[r0,#0x39]  ; g_tTP
000016  3029              ADDS     r0,r0,#0x29
000018  f8008001          STRB     r8,[r0,r1]
;;;196    
;;;197    	if (g_GT811.Enable == 1)	/* 电容屏 (无需校准) */
00001c  487e              LDR      r0,|L15.536|
00001e  7800              LDRB     r0,[r0,#0]  ; g_GT811
000020  2801              CMP      r0,#1
000022  d102              BNE      |L15.42|
;;;198    	{
;;;199    		xx = _usX;
000024  4634              MOV      r4,r6
;;;200    		yy = _usY;
000026  463d              MOV      r5,r7
000028  e009              B        |L15.62|
                  |L15.42|
;;;201    	}
;;;202    	else	/* 电阻屏 */
;;;203    	{
;;;204    		xx = TOUCH_TransX(_usX, _usY);
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       TOUCH_TransX
000032  b284              UXTH     r4,r0
;;;205    		yy = TOUCH_TransY(_usX, _usY);
000034  4639              MOV      r1,r7
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       TOUCH_TransY
00003c  b285              UXTH     r5,r0
                  |L15.62|
;;;206    	}
;;;207    	
;;;208    	/* 横屏和竖屏方向识别 */
;;;209    	switch (g_tParam.TouchDirection)
00003e  4877              LDR      r0,|L15.540|
000040  7940              LDRB     r0,[r0,#5]  ; g_tParam
000042  b130              CBZ      r0,|L15.82|
000044  2801              CMP      r0,#1
000046  d033              BEQ      |L15.176|
000048  2802              CMP      r0,#2
00004a  d060              BEQ      |L15.270|
00004c  2803              CMP      r0,#3
00004e  d175              BNE      |L15.316|
000050  e08d              B        |L15.366|
                  |L15.82|
;;;210    	{
;;;211    		case 0:	/* 校准触摸时，屏幕方向为0 */
;;;212    			if (g_LcdDirection == 0)		/* 横屏 */
000052  4873              LDR      r0,|L15.544|
000054  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000056  b910              CBNZ     r0,|L15.94|
;;;213    			{
;;;214    				x = xx;
000058  46a1              MOV      r9,r4
;;;215    				y = yy;
00005a  46aa              MOV      r10,r5
00005c  e027              B        |L15.174|
                  |L15.94|
;;;216    			}
;;;217    			else if (g_LcdDirection == 1)	/* 横屏180°*/
00005e  4870              LDR      r0,|L15.544|
000060  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000062  2801              CMP      r0,#1
000064  d10c              BNE      |L15.128|
;;;218    			{
;;;219    				x = g_LcdWidth - xx - 1;
000066  486f              LDR      r0,|L15.548|
000068  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
00006a  1b00              SUBS     r0,r0,r4
00006c  1e40              SUBS     r0,r0,#1
00006e  fa1ff980          UXTH     r9,r0
;;;220    				y = g_LcdHeight - yy - 1;
000072  486d              LDR      r0,|L15.552|
000074  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000076  1b40              SUBS     r0,r0,r5
000078  1e40              SUBS     r0,r0,#1
00007a  fa1ffa80          UXTH     r10,r0
00007e  e016              B        |L15.174|
                  |L15.128|
;;;221    			}
;;;222    			else if (g_LcdDirection == 2)	/* 竖屏 */
000080  4867              LDR      r0,|L15.544|
000082  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000084  2802              CMP      r0,#2
000086  d107              BNE      |L15.152|
;;;223    			{
;;;224    				y = xx;
000088  46a2              MOV      r10,r4
;;;225    				x = g_LcdWidth - yy - 1;
00008a  4866              LDR      r0,|L15.548|
00008c  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
00008e  1b40              SUBS     r0,r0,r5
000090  1e40              SUBS     r0,r0,#1
000092  fa1ff980          UXTH     r9,r0
000096  e00a              B        |L15.174|
                  |L15.152|
;;;226    			}
;;;227    			else if (g_LcdDirection == 3)	/* 竖屏180° */
000098  4861              LDR      r0,|L15.544|
00009a  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00009c  2803              CMP      r0,#3
00009e  d106              BNE      |L15.174|
;;;228    			{
;;;229    				y = g_LcdHeight - xx - 1;
0000a0  4861              LDR      r0,|L15.552|
0000a2  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0000a4  1b00              SUBS     r0,r0,r4
0000a6  1e40              SUBS     r0,r0,#1
0000a8  fa1ffa80          UXTH     r10,r0
;;;230    				x = yy;
0000ac  46a9              MOV      r9,r5
                  |L15.174|
;;;231    			}
;;;232    			break;
0000ae  e091              B        |L15.468|
                  |L15.176|
;;;233    
;;;234    		case 1:	/* 校准触摸时，屏幕方向为1 */
;;;235    			if (g_LcdDirection == 0)		/* 横屏 */
0000b0  485b              LDR      r0,|L15.544|
0000b2  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000b4  b960              CBNZ     r0,|L15.208|
;;;236    			{
;;;237    				x = g_LcdWidth - xx - 1;
0000b6  485b              LDR      r0,|L15.548|
0000b8  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
0000ba  1b00              SUBS     r0,r0,r4
0000bc  1e40              SUBS     r0,r0,#1
0000be  fa1ff980          UXTH     r9,r0
;;;238    				y = g_LcdHeight - yy - 1;
0000c2  4859              LDR      r0,|L15.552|
0000c4  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0000c6  1b40              SUBS     r0,r0,r5
0000c8  1e40              SUBS     r0,r0,#1
0000ca  fa1ffa80          UXTH     r10,r0
0000ce  e01d              B        |L15.268|
                  |L15.208|
;;;239    			}
;;;240    			else if (g_LcdDirection == 1)	/* 横屏180°*/
0000d0  4853              LDR      r0,|L15.544|
0000d2  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000d4  2801              CMP      r0,#1
0000d6  d102              BNE      |L15.222|
;;;241    			{
;;;242    				x = xx;
0000d8  46a1              MOV      r9,r4
;;;243    				y = yy;
0000da  46aa              MOV      r10,r5
0000dc  e016              B        |L15.268|
                  |L15.222|
;;;244    			}
;;;245    			else if (g_LcdDirection == 2)	/* 竖屏 */
0000de  4850              LDR      r0,|L15.544|
0000e0  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000e2  2802              CMP      r0,#2
0000e4  d107              BNE      |L15.246|
;;;246    			{
;;;247    				y = g_LcdHeight - xx - 1;
0000e6  4850              LDR      r0,|L15.552|
0000e8  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0000ea  1b00              SUBS     r0,r0,r4
0000ec  1e40              SUBS     r0,r0,#1
0000ee  fa1ffa80          UXTH     r10,r0
;;;248    				x = yy;
0000f2  46a9              MOV      r9,r5
0000f4  e00a              B        |L15.268|
                  |L15.246|
;;;249    			}
;;;250    			else if (g_LcdDirection == 3)	/* 竖屏180° */
0000f6  484a              LDR      r0,|L15.544|
0000f8  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0000fa  2803              CMP      r0,#3
0000fc  d106              BNE      |L15.268|
;;;251    			{
;;;252    				y = xx;
0000fe  46a2              MOV      r10,r4
;;;253    				x = g_LcdWidth - yy - 1;
000100  4848              LDR      r0,|L15.548|
000102  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000104  1b40              SUBS     r0,r0,r5
000106  1e40              SUBS     r0,r0,#1
000108  fa1ff980          UXTH     r9,r0
                  |L15.268|
;;;254    			}
;;;255    			break;
00010c  e062              B        |L15.468|
                  |L15.270|
;;;256    
;;;257    		case 2:	/* 校准触摸时，屏幕方向为2 */
;;;258    			if (g_LcdDirection == 0)		/* 横屏 */
00010e  4844              LDR      r0,|L15.544|
000110  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000112  b938              CBNZ     r0,|L15.292|
;;;259    			{
;;;260    				y = xx;
000114  46a2              MOV      r10,r4
;;;261    				x = g_LcdWidth - yy - 1;
000116  4843              LDR      r0,|L15.548|
000118  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
00011a  1b40              SUBS     r0,r0,r5
00011c  1e40              SUBS     r0,r0,#1
00011e  fa1ff980          UXTH     r9,r0
000122  e023              B        |L15.364|
                  |L15.292|
;;;262    			}
;;;263    			else if (g_LcdDirection == 1)	/* 横屏180°*/
000124  483e              LDR      r0,|L15.544|
000126  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000128  2801              CMP      r0,#1
00012a  d108              BNE      |L15.318|
;;;264    			{
;;;265    				y = g_LcdHeight - xx - 1;
00012c  483e              LDR      r0,|L15.552|
00012e  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000130  1b00              SUBS     r0,r0,r4
000132  1e40              SUBS     r0,r0,#1
000134  fa1ffa80          UXTH     r10,r0
;;;266    				x = yy;
000138  46a9              MOV      r9,r5
00013a  e017              B        |L15.364|
                  |L15.316|
00013c  e046              B        |L15.460|
                  |L15.318|
;;;267    			}
;;;268    			else if (g_LcdDirection == 2)	/* 竖屏 */
00013e  4838              LDR      r0,|L15.544|
000140  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000142  2802              CMP      r0,#2
000144  d102              BNE      |L15.332|
;;;269    			{
;;;270    				x = xx;
000146  46a1              MOV      r9,r4
;;;271    				y = yy;
000148  46aa              MOV      r10,r5
00014a  e00f              B        |L15.364|
                  |L15.332|
;;;272    			}
;;;273    			else if (g_LcdDirection == 3)	/* 竖屏180° */
00014c  4834              LDR      r0,|L15.544|
00014e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000150  2803              CMP      r0,#3
000152  d10b              BNE      |L15.364|
;;;274    			{
;;;275    				x = g_LcdWidth - xx - 1;
000154  4833              LDR      r0,|L15.548|
000156  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
000158  1b00              SUBS     r0,r0,r4
00015a  1e40              SUBS     r0,r0,#1
00015c  fa1ff980          UXTH     r9,r0
;;;276    				y = g_LcdHeight - yy - 1;
000160  4831              LDR      r0,|L15.552|
000162  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000164  1b40              SUBS     r0,r0,r5
000166  1e40              SUBS     r0,r0,#1
000168  fa1ffa80          UXTH     r10,r0
                  |L15.364|
;;;277    			}
;;;278    			break;
00016c  e032              B        |L15.468|
                  |L15.366|
;;;279    
;;;280    		case 3:	/* 校准触摸时，屏幕方向为3 */
;;;281    			if (g_LcdDirection == 0)		/* 横屏 */
00016e  482c              LDR      r0,|L15.544|
000170  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000172  b938              CBNZ     r0,|L15.388|
;;;282    			{
;;;283    				y = xx;
000174  46a2              MOV      r10,r4
;;;284    				x = g_LcdWidth - yy - 1;
000176  482b              LDR      r0,|L15.548|
000178  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
00017a  1b40              SUBS     r0,r0,r5
00017c  1e40              SUBS     r0,r0,#1
00017e  fa1ff980          UXTH     r9,r0
000182  e022              B        |L15.458|
                  |L15.388|
;;;285    			}
;;;286    			else if (g_LcdDirection == 1)	/* 横屏180°*/
000184  4826              LDR      r0,|L15.544|
000186  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000188  2801              CMP      r0,#1
00018a  d107              BNE      |L15.412|
;;;287    			{
;;;288    				y = g_LcdHeight - xx - 1;
00018c  4826              LDR      r0,|L15.552|
00018e  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
000190  1b00              SUBS     r0,r0,r4
000192  1e40              SUBS     r0,r0,#1
000194  fa1ffa80          UXTH     r10,r0
;;;289    				x = yy;
000198  46a9              MOV      r9,r5
00019a  e016              B        |L15.458|
                  |L15.412|
;;;290    			}
;;;291    			else if (g_LcdDirection == 2)	/* 竖屏 */
00019c  4820              LDR      r0,|L15.544|
00019e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0001a0  2802              CMP      r0,#2
0001a2  d10c              BNE      |L15.446|
;;;292    			{
;;;293    				x = g_LcdWidth - xx - 1;
0001a4  481f              LDR      r0,|L15.548|
0001a6  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
0001a8  1b00              SUBS     r0,r0,r4
0001aa  1e40              SUBS     r0,r0,#1
0001ac  fa1ff980          UXTH     r9,r0
;;;294    				y = g_LcdHeight - yy - 1;
0001b0  481d              LDR      r0,|L15.552|
0001b2  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
0001b4  1b40              SUBS     r0,r0,r5
0001b6  1e40              SUBS     r0,r0,#1
0001b8  fa1ffa80          UXTH     r10,r0
0001bc  e005              B        |L15.458|
                  |L15.446|
;;;295    			}
;;;296    			else if (g_LcdDirection == 3)	/* 竖屏180° */
0001be  4818              LDR      r0,|L15.544|
0001c0  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
0001c2  2803              CMP      r0,#3
0001c4  d101              BNE      |L15.458|
;;;297    			{
;;;298    				x = xx;
0001c6  46a1              MOV      r9,r4
;;;299    				y = yy;
0001c8  46aa              MOV      r10,r5
                  |L15.458|
;;;300    			}
;;;301    			break;
0001ca  e003              B        |L15.468|
                  |L15.460|
;;;302    
;;;303    		default:
;;;304    			g_tParam.TouchDirection = 0;	/* 方向参数无效时，纠正为缺省的横屏 */
0001cc  2000              MOVS     r0,#0
0001ce  4913              LDR      r1,|L15.540|
0001d0  7148              STRB     r0,[r1,#5]
;;;305    			break;
0001d2  bf00              NOP      
                  |L15.468|
0001d4  bf00              NOP                            ;232
;;;306    	}
;;;307    
;;;308    	g_tTP.XBuf[g_tTP.Write] = x;
0001d6  fa0ff189          SXTH     r1,r9
0001da  480e              LDR      r0,|L15.532|
0001dc  f8902039          LDRB     r2,[r0,#0x39]  ; g_tTP
0001e0  302c              ADDS     r0,r0,#0x2c
0001e2  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;309    	g_tTP.YBuf[g_tTP.Write] = y;
0001e6  fa0ff18a          SXTH     r1,r10
0001ea  382c              SUBS     r0,r0,#0x2c
0001ec  f8902039          LDRB     r2,[r0,#0x39]  ; g_tTP
0001f0  3032              ADDS     r0,r0,#0x32
0001f2  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;310    
;;;311    	if (++g_tTP.Write  >= TOUCH_FIFO_SIZE)
0001f6  3832              SUBS     r0,r0,#0x32
0001f8  f8900039          LDRB     r0,[r0,#0x39]  ; g_tTP
0001fc  1c40              ADDS     r0,r0,#1
0001fe  b2c0              UXTB     r0,r0
000200  4904              LDR      r1,|L15.532|
000202  f8810039          STRB     r0,[r1,#0x39]
000206  2803              CMP      r0,#3
000208  db02              BLT      |L15.528|
;;;312    	{
;;;313    		g_tTP.Write = 0;
00020a  2000              MOVS     r0,#0
00020c  f8810039          STRB     r0,[r1,#0x39]
                  |L15.528|
;;;314    	}
;;;315    }
000210  e8bd87f0          POP      {r4-r10,pc}
;;;316    
                          ENDP

                  |L15.532|
                          DCD      g_tTP
                  |L15.536|
                          DCD      g_GT811
                  |L15.540|
                          DCD      g_tParam
                  |L15.544|
                          DCD      g_LcdDirection
                  |L15.548|
                          DCD      g_LcdWidth
                  |L15.552|
                          DCD      g_LcdHeight

                          AREA ||i.TOUCH_ReadAdcX||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcX PROC
;;;151    */
;;;152    uint16_t TOUCH_ReadAdcX(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154    	uint16_t usAdc;
;;;155    
;;;156    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;157    	usAdc = g_tTP.usAdcNowX;
000008  4803              LDR      r0,|L16.24|
00000a  8c84              LDRH     r4,[r0,#0x24]  ; g_tTP
;;;158    	__set_PRIMASK(0);  		/* 开中断 */
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       __set_PRIMASK
;;;159    
;;;160    	return usAdc;
000012  4620              MOV      r0,r4
;;;161    }
000014  bd10              POP      {r4,pc}
;;;162    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      g_tTP

                          AREA ||i.TOUCH_ReadAdcY||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcY PROC
;;;170    */
;;;171    uint16_t TOUCH_ReadAdcY(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173    	uint16_t usAdc;
;;;174    
;;;175    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;176    	usAdc = g_tTP.usAdcNowY;
000008  4803              LDR      r0,|L17.24|
00000a  8cc4              LDRH     r4,[r0,#0x26]  ; g_tTP
;;;177    	__set_PRIMASK(0);  		/* 开中断 */
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       __set_PRIMASK
;;;178    
;;;179    	return usAdc;
000012  4620              MOV      r0,r4
;;;180    }
000014  bd10              POP      {r4,pc}
;;;181    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      g_tTP

                          AREA ||i.TOUCH_SaveParam||, CODE, READONLY, ALIGN=2

                  TOUCH_SaveParam PROC
;;;1053   extern void SaveParam(void);
;;;1054   static void TOUCH_SaveParam(void)
000000  b510              PUSH     {r4,lr}
;;;1055   {
;;;1056   #if 1
;;;1057   	g_tParam.usAdcX1 = g_tTP.usAdcX1;
000002  481d              LDR      r0,|L18.120|
000004  8800              LDRH     r0,[r0,#0]  ; g_tTP
000006  491d              LDR      r1,|L18.124|
000008  8108              STRH     r0,[r1,#8]
;;;1058   	g_tParam.usAdcY1 = g_tTP.usAdcY1;
00000a  481b              LDR      r0,|L18.120|
00000c  8840              LDRH     r0,[r0,#2]  ; g_tTP
00000e  8148              STRH     r0,[r1,#0xa]
;;;1059   	g_tParam.usAdcX2 = g_tTP.usAdcX2;
000010  4819              LDR      r0,|L18.120|
000012  8880              LDRH     r0,[r0,#4]  ; g_tTP
000014  8188              STRH     r0,[r1,#0xc]
;;;1060   	g_tParam.usAdcY2 = g_tTP.usAdcY2;
000016  4818              LDR      r0,|L18.120|
000018  88c0              LDRH     r0,[r0,#6]  ; g_tTP
00001a  81c8              STRH     r0,[r1,#0xe]
;;;1061   	g_tParam.usAdcX3 = g_tTP.usAdcX3;
00001c  4816              LDR      r0,|L18.120|
00001e  8900              LDRH     r0,[r0,#8]  ; g_tTP
000020  8208              STRH     r0,[r1,#0x10]
;;;1062   	g_tParam.usAdcY3 = g_tTP.usAdcY3;
000022  4815              LDR      r0,|L18.120|
000024  8940              LDRH     r0,[r0,#0xa]  ; g_tTP
000026  8248              STRH     r0,[r1,#0x12]
;;;1063   	g_tParam.usAdcX4 = g_tTP.usAdcX4;
000028  4813              LDR      r0,|L18.120|
00002a  8980              LDRH     r0,[r0,#0xc]  ; g_tTP
00002c  8288              STRH     r0,[r1,#0x14]
;;;1064   	g_tParam.usAdcY4 = g_tTP.usAdcY4;
00002e  4812              LDR      r0,|L18.120|
000030  89c0              LDRH     r0,[r0,#0xe]  ; g_tTP
000032  82c8              STRH     r0,[r1,#0x16]
;;;1065   
;;;1066   	g_tParam.usLcdX1 = g_tTP.usLcdX1;
000034  4810              LDR      r0,|L18.120|
000036  8a00              LDRH     r0,[r0,#0x10]  ; g_tTP
000038  8308              STRH     r0,[r1,#0x18]
;;;1067   	g_tParam.usLcdY1 = g_tTP.usLcdY1;
00003a  480f              LDR      r0,|L18.120|
00003c  8a40              LDRH     r0,[r0,#0x12]  ; g_tTP
00003e  8348              STRH     r0,[r1,#0x1a]
;;;1068   	g_tParam.usLcdX2 = g_tTP.usLcdX2;
000040  480d              LDR      r0,|L18.120|
000042  8a80              LDRH     r0,[r0,#0x14]  ; g_tTP
000044  8388              STRH     r0,[r1,#0x1c]
;;;1069   	g_tParam.usLcdY2 = g_tTP.usLcdY2;
000046  480c              LDR      r0,|L18.120|
000048  8ac0              LDRH     r0,[r0,#0x16]  ; g_tTP
00004a  83c8              STRH     r0,[r1,#0x1e]
;;;1070   	g_tParam.usLcdX3 = g_tTP.usLcdX3;
00004c  480a              LDR      r0,|L18.120|
00004e  8b00              LDRH     r0,[r0,#0x18]  ; g_tTP
000050  8408              STRH     r0,[r1,#0x20]
;;;1071   	g_tParam.usLcdY3 = g_tTP.usLcdY3;
000052  4809              LDR      r0,|L18.120|
000054  8b40              LDRH     r0,[r0,#0x1a]  ; g_tTP
000056  8448              STRH     r0,[r1,#0x22]
;;;1072   	g_tParam.usLcdX4 = g_tTP.usLcdX4;
000058  4807              LDR      r0,|L18.120|
00005a  8b80              LDRH     r0,[r0,#0x1c]  ; g_tTP
00005c  8488              STRH     r0,[r1,#0x24]
;;;1073   	g_tParam.usLcdY4 = g_tTP.usLcdY4;
00005e  4806              LDR      r0,|L18.120|
000060  8bc0              LDRH     r0,[r0,#0x1e]  ; g_tTP
000062  84c8              STRH     r0,[r1,#0x26]
;;;1074   
;;;1075   	g_tParam.XYChange = g_tTP.XYChange;
000064  4804              LDR      r0,|L18.120|
000066  f8900020          LDRB     r0,[r0,#0x20]  ; g_tTP
00006a  7188              STRB     r0,[r1,#6]
;;;1076   
;;;1077   	g_tParam.TouchDirection = g_LcdDirection;	/* 2014-09-11 添加屏幕方向, 用于屏幕旋转时无需再次校准 */
00006c  4804              LDR      r0,|L18.128|
00006e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000070  7148              STRB     r0,[r1,#5]
;;;1078   
;;;1079   	SaveParam();	/* 将参数写入Flash */
000072  f7fffffe          BL       SaveParam
;;;1080   #endif
;;;1081   }
000076  bd10              POP      {r4,pc}
;;;1082   
                          ENDP

                  |L18.120|
                          DCD      g_tTP
                  |L18.124|
                          DCD      g_tParam
                  |L18.128|
                          DCD      g_LcdDirection

                          AREA ||i.TOUCH_Scan||, CODE, READONLY, ALIGN=2

                  TOUCH_Scan PROC
;;;430    */
;;;431    void TOUCH_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
;;;433    	uint16_t usAdcX;
;;;434    	uint16_t usAdcY;
;;;435    	static uint16_t s_usXBuf[SAMPLE_COUNT];
;;;436    	static uint16_t s_usYBuf[SAMPLE_COUNT];
;;;437    	static uint8_t s_ucPos = 0;
;;;438    	static uint8_t s_count = 0;
;;;439    	static uint8_t s_down = 0;
;;;440    	static uint16_t s_usSaveAdcX, s_usSaveAdcY; /* 用于触笔抬起事件，保存按下和移动的最后采样值 */
;;;441    
;;;442    	if (g_tTP.Enable == 0)
000002  4853              LDR      r0,|L19.336|
000004  f8900028          LDRB     r0,[r0,#0x28]  ; g_tTP
000008  b900              CBNZ     r0,|L19.12|
                  |L19.10|
;;;443    	{
;;;444    		return;
;;;445    	}
;;;446    
;;;447    	/* 获得原始的ADC值，未滤波 */
;;;448    	if (g_ChipID == IC_8875)
;;;449    	{
;;;450    		/* 如果主程序正在访问RA8875,则丢弃本次触摸采集，避免影响显示 */
;;;451    		if (RA8875_IsBusy())
;;;452    		{
;;;453    			return;
;;;454    		}
;;;455    
;;;456    		usAdcX = RA8875_TouchReadX();
;;;457    		usAdcY = RA8875_TouchReadY();
;;;458    	}
;;;459    	else
;;;460    	{
;;;461    		if (TSC2046_PenInt())
;;;462    		{
;;;463    			/* 如果主程序正在访问其他SPI外设，则丢弃本次触摸采集 */
;;;464    			if (bsp_SpiBusBusy())
;;;465    			{
;;;466    				return;
;;;467    			}
;;;468    
;;;469    			usAdcX = TSC2046_ReadAdc(ADC_CH_X);
;;;470    			usAdcY = TSC2046_ReadAdc(ADC_CH_Y);
;;;471    		}
;;;472    		else
;;;473    		{
;;;474    			usAdcX = 0;
;;;475    			usAdcY = 0;
;;;476    		}
;;;477    	}
;;;478    			
;;;479    	if (TOUCH_PressValid(usAdcX, usAdcY))
;;;480    	{
;;;481    		/* 按压30ms之后才开始采集数据 */
;;;482    		if (s_count >= DOWN_VALID)
;;;483    		{
;;;484    			s_usXBuf[s_ucPos] = usAdcX;
;;;485    			s_usYBuf[s_ucPos] = usAdcY;
;;;486    
;;;487    			/* 采集30ms数据进行滤波 */
;;;488    			if (++s_ucPos >= SAMPLE_COUNT)
;;;489    			{
;;;490    				s_ucPos = 0;
;;;491    
;;;492    			   	/* 对ADC采样值进行软件滤波 */
;;;493    				g_tTP.usAdcNowX = TOUCH_DataFilter(s_usXBuf, SAMPLE_COUNT);
;;;494    				g_tTP.usAdcNowY = TOUCH_DataFilter(s_usYBuf, SAMPLE_COUNT);
;;;495    
;;;496    				if (s_down == 0)
;;;497    				{
;;;498    					s_down = 1;
;;;499    					/* 触摸按下事件 */
;;;500    					TOUCH_PutKey(TOUCH_DOWN, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;501    
;;;502    					s_usSaveAdcX = g_tTP.usAdcNowX;
;;;503    					s_usSaveAdcY = g_tTP.usAdcNowY;
;;;504    				}
;;;505    				else
;;;506    				{
;;;507    
;;;508    					if (TOUCH_MoveValid(s_usSaveAdcX, s_usSaveAdcY, g_tTP.usAdcNowX, g_tTP.usAdcNowY))
;;;509    					{
;;;510    						/* 触摸移动事件 */
;;;511    						TOUCH_PutKey(TOUCH_MOVE, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;512    
;;;513    						s_usSaveAdcX = g_tTP.usAdcNowX;
;;;514    						s_usSaveAdcY = g_tTP.usAdcNowY;
;;;515    					}
;;;516    					else
;;;517    					{
;;;518    						g_tTP.usAdcNowX = 0; /* for debug stop */
;;;519    					}
;;;520    				}
;;;521    			}
;;;522    		}
;;;523    		else
;;;524    		{
;;;525    			s_count++;
;;;526    		}
;;;527    	}
;;;528    	else
;;;529    	{
;;;530    		if (s_count > 0)
;;;531    		{
;;;532    			if (--s_count == 0)
;;;533    			{
;;;534    				/* 触摸释放事件 */
;;;535    				//TOUCH_PutKey(TOUCH_RELEASE, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;536    				TOUCH_PutKey(TOUCH_RELEASE, s_usSaveAdcX, s_usSaveAdcY);
;;;537    
;;;538    				g_tTP.usAdcNowX = 0;
;;;539    				g_tTP.usAdcNowY = 0;
;;;540    
;;;541    				s_count = 0;
;;;542    				s_down = 0;
;;;543    			}
;;;544    		}
;;;545    		s_ucPos = 0;
;;;546    	}
;;;547    }
00000a  bd70              POP      {r4-r6,pc}
                  |L19.12|
00000c  4851              LDR      r0,|L19.340|
00000e  8800              LDRH     r0,[r0,#0]            ;448  ; g_ChipID
000010  2875              CMP      r0,#0x75              ;448
000012  d10a              BNE      |L19.42|
000014  f7fffffe          BL       RA8875_IsBusy
000018  b100              CBZ      r0,|L19.28|
00001a  e7f6              B        |L19.10|
                  |L19.28|
00001c  f7fffffe          BL       RA8875_TouchReadX
000020  4605              MOV      r5,r0                 ;456
000022  f7fffffe          BL       RA8875_TouchReadY
000026  4604              MOV      r4,r0                 ;457
000028  e011              B        |L19.78|
                  |L19.42|
00002a  f7fffffe          BL       TSC2046_PenInt
00002e  b160              CBZ      r0,|L19.74|
000030  f7fffffe          BL       bsp_SpiBusBusy
000034  b100              CBZ      r0,|L19.56|
000036  e7e8              B        |L19.10|
                  |L19.56|
000038  2001              MOVS     r0,#1                 ;469
00003a  f7fffffe          BL       TSC2046_ReadAdc
00003e  4605              MOV      r5,r0                 ;469
000040  2005              MOVS     r0,#5                 ;470
000042  f7fffffe          BL       TSC2046_ReadAdc
000046  4604              MOV      r4,r0                 ;470
000048  e001              B        |L19.78|
                  |L19.74|
00004a  2500              MOVS     r5,#0                 ;474
00004c  2400              MOVS     r4,#0                 ;475
                  |L19.78|
00004e  4621              MOV      r1,r4                 ;479
000050  4628              MOV      r0,r5                 ;479
000052  f7fffffe          BL       TOUCH_PressValid
000056  2800              CMP      r0,#0                 ;479
000058  d05b              BEQ      |L19.274|
00005a  483f              LDR      r0,|L19.344|
00005c  7800              LDRB     r0,[r0,#0]            ;482  ; s_count
00005e  281e              CMP      r0,#0x1e              ;482
000060  db51              BLT      |L19.262|
000062  483e              LDR      r0,|L19.348|
000064  493e              LDR      r1,|L19.352|
000066  7809              LDRB     r1,[r1,#0]            ;484  ; s_ucPos
000068  f8205011          STRH     r5,[r0,r1,LSL #1]     ;484
00006c  483d              LDR      r0,|L19.356|
00006e  493c              LDR      r1,|L19.352|
000070  7809              LDRB     r1,[r1,#0]            ;485  ; s_ucPos
000072  f8204011          STRH     r4,[r0,r1,LSL #1]     ;485
000076  483a              LDR      r0,|L19.352|
000078  7800              LDRB     r0,[r0,#0]            ;488  ; s_ucPos
00007a  1c40              ADDS     r0,r0,#1              ;488
00007c  b2c0              UXTB     r0,r0                 ;488
00007e  4938              LDR      r1,|L19.352|
000080  7008              STRB     r0,[r1,#0]            ;488
000082  280a              CMP      r0,#0xa               ;488
000084  db62              BLT      |L19.332|
000086  2000              MOVS     r0,#0                 ;490
000088  7008              STRB     r0,[r1,#0]            ;490
00008a  210a              MOVS     r1,#0xa               ;493
00008c  4833              LDR      r0,|L19.348|
00008e  f7fffffe          BL       TOUCH_DataFilter
000092  492f              LDR      r1,|L19.336|
000094  8488              STRH     r0,[r1,#0x24]         ;493
000096  210a              MOVS     r1,#0xa               ;494
000098  4832              LDR      r0,|L19.356|
00009a  f7fffffe          BL       TOUCH_DataFilter
00009e  492c              LDR      r1,|L19.336|
0000a0  84c8              STRH     r0,[r1,#0x26]         ;494
0000a2  4831              LDR      r0,|L19.360|
0000a4  7800              LDRB     r0,[r0,#0]            ;496  ; s_down
0000a6  b988              CBNZ     r0,|L19.204|
0000a8  2001              MOVS     r0,#1                 ;498
0000aa  492f              LDR      r1,|L19.360|
0000ac  7008              STRB     r0,[r1,#0]            ;498
0000ae  4828              LDR      r0,|L19.336|
0000b0  8cc2              LDRH     r2,[r0,#0x26]         ;500  ; g_tTP
0000b2  8c81              LDRH     r1,[r0,#0x24]         ;500  ; g_tTP
0000b4  2001              MOVS     r0,#1                 ;500
0000b6  f7fffffe          BL       TOUCH_PutKey
0000ba  4825              LDR      r0,|L19.336|
0000bc  8c80              LDRH     r0,[r0,#0x24]         ;502  ; g_tTP
0000be  492b              LDR      r1,|L19.364|
0000c0  8008              STRH     r0,[r1,#0]            ;502
0000c2  4823              LDR      r0,|L19.336|
0000c4  8cc0              LDRH     r0,[r0,#0x26]         ;503  ; g_tTP
0000c6  492a              LDR      r1,|L19.368|
0000c8  8008              STRH     r0,[r1,#0]            ;503
0000ca  e03f              B        |L19.332|
                  |L19.204|
0000cc  4820              LDR      r0,|L19.336|
0000ce  8cc3              LDRH     r3,[r0,#0x26]         ;508  ; g_tTP
0000d0  8c82              LDRH     r2,[r0,#0x24]         ;508  ; g_tTP
0000d2  4827              LDR      r0,|L19.368|
0000d4  8801              LDRH     r1,[r0,#0]            ;508  ; s_usSaveAdcY
0000d6  4825              LDR      r0,|L19.364|
0000d8  8800              LDRH     r0,[r0,#0]            ;508  ; s_usSaveAdcX
0000da  f7fffffe          BL       TOUCH_MoveValid
0000de  b170              CBZ      r0,|L19.254|
0000e0  481b              LDR      r0,|L19.336|
0000e2  8cc2              LDRH     r2,[r0,#0x26]         ;511  ; g_tTP
0000e4  8c81              LDRH     r1,[r0,#0x24]         ;511  ; g_tTP
0000e6  2002              MOVS     r0,#2                 ;511
0000e8  f7fffffe          BL       TOUCH_PutKey
0000ec  4818              LDR      r0,|L19.336|
0000ee  8c80              LDRH     r0,[r0,#0x24]         ;513  ; g_tTP
0000f0  491e              LDR      r1,|L19.364|
0000f2  8008              STRH     r0,[r1,#0]            ;513
0000f4  4816              LDR      r0,|L19.336|
0000f6  8cc0              LDRH     r0,[r0,#0x26]         ;514  ; g_tTP
0000f8  491d              LDR      r1,|L19.368|
0000fa  8008              STRH     r0,[r1,#0]            ;514
0000fc  e026              B        |L19.332|
                  |L19.254|
0000fe  2000              MOVS     r0,#0                 ;518
000100  4913              LDR      r1,|L19.336|
000102  8488              STRH     r0,[r1,#0x24]         ;518
000104  e022              B        |L19.332|
                  |L19.262|
000106  4814              LDR      r0,|L19.344|
000108  7800              LDRB     r0,[r0,#0]            ;525  ; s_count
00010a  1c40              ADDS     r0,r0,#1              ;525
00010c  4912              LDR      r1,|L19.344|
00010e  7008              STRB     r0,[r1,#0]            ;525
000110  e01c              B        |L19.332|
                  |L19.274|
000112  4811              LDR      r0,|L19.344|
000114  7800              LDRB     r0,[r0,#0]            ;530  ; s_count
000116  2800              CMP      r0,#0                 ;530
000118  dd15              BLE      |L19.326|
00011a  480f              LDR      r0,|L19.344|
00011c  7800              LDRB     r0,[r0,#0]            ;532  ; s_count
00011e  1e40              SUBS     r0,r0,#1              ;532
000120  b2c0              UXTB     r0,r0                 ;532
000122  490d              LDR      r1,|L19.344|
000124  7008              STRB     r0,[r1,#0]            ;532
000126  b970              CBNZ     r0,|L19.326|
000128  4811              LDR      r0,|L19.368|
00012a  8802              LDRH     r2,[r0,#0]            ;536  ; s_usSaveAdcY
00012c  480f              LDR      r0,|L19.364|
00012e  8801              LDRH     r1,[r0,#0]            ;536  ; s_usSaveAdcX
000130  2003              MOVS     r0,#3                 ;536
000132  f7fffffe          BL       TOUCH_PutKey
000136  2000              MOVS     r0,#0                 ;538
000138  4905              LDR      r1,|L19.336|
00013a  8488              STRH     r0,[r1,#0x24]         ;538
00013c  84c8              STRH     r0,[r1,#0x26]         ;539
00013e  4906              LDR      r1,|L19.344|
000140  7008              STRB     r0,[r1,#0]            ;541
000142  4909              LDR      r1,|L19.360|
000144  7008              STRB     r0,[r1,#0]            ;542
                  |L19.326|
000146  2000              MOVS     r0,#0                 ;545
000148  4905              LDR      r1,|L19.352|
00014a  7008              STRB     r0,[r1,#0]            ;545
                  |L19.332|
00014c  bf00              NOP      
00014e  e75c              B        |L19.10|
;;;548    
                          ENDP

                  |L19.336|
                          DCD      g_tTP
                  |L19.340|
                          DCD      g_ChipID
                  |L19.344|
                          DCD      s_count
                  |L19.348|
                          DCD      s_usXBuf
                  |L19.352|
                          DCD      s_ucPos
                  |L19.356|
                          DCD      s_usYBuf
                  |L19.360|
                          DCD      s_down
                  |L19.364|
                          DCD      s_usSaveAdcX
                  |L19.368|
                          DCD      s_usSaveAdcY

                          AREA ||i.TOUCH_TransX||, CODE, READONLY, ALIGN=2

                  TOUCH_TransX PROC
;;;569    */
;;;570    static int16_t TOUCH_TransX(uint16_t _usAdcX, uint16_t _usAdcY)
000000  b5f8              PUSH     {r3-r7,lr}
;;;571    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;572    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;573    	uint16_t x;
;;;574    	int32_t y;
;;;575    
;;;576    	if (g_tTP.XYChange == 0)
000006  4815              LDR      r0,|L20.92|
000008  8c00              LDRH     r0,[r0,#0x20]  ; g_tTP
00000a  b990              CBNZ     r0,|L20.50|
;;;577    	{
;;;578    		x = _usAdcX;
00000c  4634              MOV      r4,r6
;;;579    		if (x == 0)
00000e  b90c              CBNZ     r4,|L20.20|
;;;580    		{
;;;581    			y = 0;
000010  2500              MOVS     r5,#0
000012  e020              B        |L20.86|
                  |L20.20|
;;;582    		}
;;;583    		else
;;;584    		{
;;;585    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_X1, g_tTP.usAdcX2, TP_X2, x);
;;;586    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdX1, g_tTP.usAdcX2, g_tTP.usLcdX2, x);
000014  f8dfc044          LDR      r12,|L20.92|
000018  9400              STR      r4,[sp,#0]
00001a  f8bc3014          LDRH     r3,[r12,#0x14]  ; g_tTP
00001e  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
000022  f8bc1010          LDRH     r1,[r12,#0x10]  ; g_tTP
000026  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
00002a  f7fffffe          BL       CalTwoPoint
00002e  4605              MOV      r5,r0
000030  e011              B        |L20.86|
                  |L20.50|
;;;587    		}
;;;588    	}
;;;589    	else
;;;590    	{
;;;591    		x = _usAdcY;
000032  463c              MOV      r4,r7
;;;592    		if (x == 0)
000034  b90c              CBNZ     r4,|L20.58|
;;;593    		{
;;;594    			y = 0;
000036  2500              MOVS     r5,#0
000038  e00d              B        |L20.86|
                  |L20.58|
;;;595    		}
;;;596    		else
;;;597    		{
;;;598    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_X1, g_tTP.usAdcY2, TP_X2, x);
;;;599    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdX1, g_tTP.usAdcY2, g_tTP.usLcdX2, x);
00003a  f8dfc020          LDR      r12,|L20.92|
00003e  9400              STR      r4,[sp,#0]
000040  f8bc3014          LDRH     r3,[r12,#0x14]  ; g_tTP
000044  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
000048  f8bc1010          LDRH     r1,[r12,#0x10]  ; g_tTP
00004c  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
000050  f7fffffe          BL       CalTwoPoint
000054  4605              MOV      r5,r0
                  |L20.86|
;;;600    		}
;;;601    	}
;;;602    	return y;
000056  b228              SXTH     r0,r5
;;;603    #else		/* 4点校准 */
;;;604    	uint16_t x, x1, x2;
;;;605    	int32_t y;
;;;606    
;;;607    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
;;;608    	{
;;;609    		x = _usAdcX;
;;;610    
;;;611    		/* 根据 Y ADC 实时计算直线方程的参考点x1, x2
;;;612    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_X1, AdcX4, TP_X4, _usAdcY)
;;;613    			if  _usAdcY = usAdcY2 then  取点 = (AdcX3, TP_X3, AdcX2, TP_X2, _usAdcY)
;;;614    
;;;615    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;616    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;617    		*/
;;;618    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX3, _usAdcY);
;;;619    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX4, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
;;;620    	}
;;;621    	else						/* X Y 坐标交换 */
;;;622    	{
;;;623    		x = _usAdcY;
;;;624    
;;;625    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;626    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_X1, AdcY4, TP_X4, _usAdcX)
;;;627    			if  _usAdcX = usAdcX2 then  取点 = (AdcY3, TP_X3, AdcY2, TP_X2, _usAdcX)
;;;628    
;;;629    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;630    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;631    		*/
;;;632    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY3, _usAdcX);
;;;633    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY4, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
;;;634    	}
;;;635    
;;;636    	if (x == 0)
;;;637    	{
;;;638    		y = 0;
;;;639    	}
;;;640    	else
;;;641    	{
;;;642    		/* 根据2点直线方程，计算坐标 */
;;;643    		//y = CalTwoPoint(x1, TP_X1, x2, TP_X2, x);
;;;644    		CalTwoPoint(x1, g_tTP.usLcdX1, x2, g_tTP.usLcd2, x);
;;;645    	}
;;;646    	return y;
;;;647    #endif
;;;648    }
000058  bdf8              POP      {r3-r7,pc}
;;;649    
                          ENDP

00005a  0000              DCW      0x0000
                  |L20.92|
                          DCD      g_tTP

                          AREA ||i.TOUCH_TransY||, CODE, READONLY, ALIGN=2

                  TOUCH_TransY PROC
;;;657    */
;;;658    static int16_t TOUCH_TransY(uint16_t _usAdcX, uint16_t _usAdcY)
000000  b5f8              PUSH     {r3-r7,lr}
;;;659    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;660    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;661    	int32_t x;
;;;662    	int32_t y;
;;;663    
;;;664    	if (g_tTP.XYChange == 0)
000006  4816              LDR      r0,|L21.96|
000008  8c00              LDRH     r0,[r0,#0x20]  ; g_tTP
00000a  b998              CBNZ     r0,|L21.52|
;;;665    	{
;;;666    		x = _usAdcY;
00000c  463c              MOV      r4,r7
;;;667    		if (x == 0)
00000e  b90c              CBNZ     r4,|L21.20|
;;;668    		{
;;;669    			y = 0;
000010  2500              MOVS     r5,#0
000012  e022              B        |L21.90|
                  |L21.20|
;;;670    		}
;;;671    		else
;;;672    		{
;;;673    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_Y1, g_tTP.usAdcY2, TP_Y2, x);
;;;674    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdY1, g_tTP.usAdcY2, g_tTP.usLcdY2, x);
000014  b2a0              UXTH     r0,r4
000016  f8dfc048          LDR      r12,|L21.96|
00001a  9000              STR      r0,[sp,#0]
00001c  f8bc3016          LDRH     r3,[r12,#0x16]  ; g_tTP
000020  f8bc2006          LDRH     r2,[r12,#6]  ; g_tTP
000024  f8bc1012          LDRH     r1,[r12,#0x12]  ; g_tTP
000028  f8bc0002          LDRH     r0,[r12,#2]  ; g_tTP
00002c  f7fffffe          BL       CalTwoPoint
000030  4605              MOV      r5,r0
000032  e012              B        |L21.90|
                  |L21.52|
;;;675    		}
;;;676    	}
;;;677    	else
;;;678    	{
;;;679    		x = _usAdcX;
000034  4634              MOV      r4,r6
;;;680    		if (x == 0)
000036  b90c              CBNZ     r4,|L21.60|
;;;681    		{
;;;682    			y = 0;
000038  2500              MOVS     r5,#0
00003a  e00e              B        |L21.90|
                  |L21.60|
;;;683    		}
;;;684    		else
;;;685    		{
;;;686    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_Y1, g_tTP.usAdcX2, TP_Y2, x);
;;;687    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdY1, g_tTP.usAdcX2, g_tTP.usLcdY2, x);
00003c  b2a0              UXTH     r0,r4
00003e  f8dfc020          LDR      r12,|L21.96|
000042  9000              STR      r0,[sp,#0]
000044  f8bc3016          LDRH     r3,[r12,#0x16]  ; g_tTP
000048  f8bc2004          LDRH     r2,[r12,#4]  ; g_tTP
00004c  f8bc1012          LDRH     r1,[r12,#0x12]  ; g_tTP
000050  f8bc0000          LDRH     r0,[r12,#0]  ; g_tTP
000054  f7fffffe          BL       CalTwoPoint
000058  4605              MOV      r5,r0
                  |L21.90|
;;;688    		}
;;;689    	}
;;;690    	return y;
00005a  b228              SXTH     r0,r5
;;;691    #else		/* 4点校准 */
;;;692    	int32_t x, x1, x2;
;;;693    	int32_t y;
;;;694    
;;;695    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
;;;696    	{
;;;697    		x = _usAdcY;
;;;698    
;;;699    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;700    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_Y1, AdcY3, TP_Y3, _usAdcX)
;;;701    			if  _usAdcX = usAdcX2 then  取点 = (AdcY4, TP_Y4, AdcY2, TP_Y2, _usAdcX)
;;;702    
;;;703    			其中 TP_Y1 = TP_Y4;  TP_Y3 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;704    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;705    		*/
;;;706    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY4, _usAdcX);
;;;707    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY3, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
;;;708    	}
;;;709    	else						/* X Y 坐标交换 */
;;;710    	{
;;;711    		x = _usAdcX;
;;;712    
;;;713    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;714    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_Y1, AdcX3, TP_Y3, _usAdcY)
;;;715    			if  _usAdcY = usAdcY2 then  取点 = (AdcX4, TP_Y4, AdcX2, TP_Y2, _usAdcY)
;;;716    
;;;717    			其中 TP_Y1 = TP_Y3;  TP_Y4 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;718    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;719    		*/
;;;720    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX4, _usAdcY);
;;;721    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX3, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
;;;722    	}
;;;723    
;;;724    	if (x == 0)
;;;725    	{
;;;726    		y = 0;
;;;727    	}
;;;728    	else
;;;729    	{
;;;730    		/* 根据2点直线方程，计算坐标 */
;;;731    		//y = CalTwoPoint(x1, TP_Y1, x2, TP_Y2, x);
;;;732    		y = CalTwoPoint(x1, g_tTP.usLcdY1, x2, g_tTP.usLcdY2, x);
;;;733    	}
;;;734    	return y;
;;;735    #endif
;;;736    }
00005c  bdf8              POP      {r3-r7,pc}
;;;737    
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      g_tTP

                          AREA ||i.TOUCH_WaitRelease||, CODE, READONLY, ALIGN=1

                  TOUCH_WaitRelease PROC
;;;901    */
;;;902    static void TOUCH_WaitRelease(void)
000000  b570              PUSH     {r4-r6,lr}
;;;903    {
;;;904    	uint8_t usCount = 0;
000002  2400              MOVS     r4,#0
;;;905    
;;;906    	for (;;)
000004  bf00              NOP      
                  |L22.6|
;;;907    	{
;;;908    		if (TOUCH_PressValid(TOUCH_ReadAdcX(), TOUCH_ReadAdcY()) == 0)
000006  f7fffffe          BL       TOUCH_ReadAdcY
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       TOUCH_ReadAdcX
000010  4606              MOV      r6,r0
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       TOUCH_PressValid
000018  b928              CBNZ     r0,|L22.38|
;;;909    		{
;;;910    			if (++usCount > 5)
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c0              UXTB     r0,r0
00001e  4604              MOV      r4,r0
000020  2805              CMP      r0,#5
000022  dd01              BLE      |L22.40|
;;;911    			{
;;;912    				break;
000024  e004              B        |L22.48|
                  |L22.38|
;;;913    			}
;;;914    		}
;;;915    		else
;;;916    		{
;;;917    			usCount = 0;
000026  2400              MOVS     r4,#0
                  |L22.40|
;;;918    		}
;;;919    		bsp_DelayMS(10);
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       bsp_DelayMS
00002e  e7ea              B        |L22.6|
                  |L22.48|
000030  bf00              NOP                            ;912
;;;920    	}
;;;921    }
000032  bd70              POP      {r4-r6,pc}
;;;922    
                          ENDP


                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;193     */
;;;194    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;195    {
;;;196      register uint32_t __regPriMask         __ASM("primask");
;;;197      __regPriMask = (priMask);
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tTP
                          %        58
                  g_tTPSL
                          %        10
                  s_usXBuf
                          %        20
                  s_usYBuf
                          %        20

                          AREA ||.data||, DATA, ALIGN=1

                  s_invalid_count
000000  00                DCB      0x00
                  s_ucPos
000001  00                DCB      0x00
                  s_count
000002  00                DCB      0x00
                  s_down
000003  00                DCB      0x00
                  s_usSaveAdcX
000004  0000              DCB      0x00,0x00
                  s_usSaveAdcY
000006  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\bsp_touch.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_touch_c_30847bcd____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REVSH|
#line 144
|__asm___11_bsp_touch_c_30847bcd____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
