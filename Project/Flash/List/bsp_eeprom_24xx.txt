; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IF:\keil\ARM\RV31\INC -IF:\keil\ARM\CMSIS\Include -IF:\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\User\bsp_stm32f4xx\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;31     */
;;;32     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;35     	{
;;;36     		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;37     	}
;;;38     	else
;;;39     	{
;;;40     		/* 失败后，切记发送I2C总线停止信号 */
;;;41     		i2c_Stop();
;;;42     		return 0;
;;;43     	}
;;;44     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;42
000014  e7fa              B        |L1.12|
;;;45     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;56     */
;;;57     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;59     	uint16_t i;
;;;60     
;;;61     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;62     
;;;63     	/* 第1步：发起I2C总线启动信号 */
;;;64     	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;65     
;;;66     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;67     	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;68     
;;;69     	/* 第3步：发送ACK */
;;;70     	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L2.28|
;;;71     	{
;;;72     		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e02c              B        |L2.118|
                  |L2.28|
;;;73     	}
;;;74     
;;;75     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;76     	if (EE_ADDR_BYTES == 1)
;;;77     	{
;;;78     		i2c_SendByte((uint8_t)_usAddress);
;;;79     		if (i2c_WaitAck() != 0)
;;;80     		{
;;;81     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;82     		}
;;;83     	}
;;;84     	else
;;;85     	{
;;;86     		i2c_SendByte(_usAddress >> 8);
00001c  1228              ASRS     r0,r5,#8
00001e  f7fffffe          BL       i2c_SendByte
;;;87     		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L2.42|
;;;88     		{
;;;89     			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e025              B        |L2.118|
                  |L2.42|
;;;90     		}
;;;91     
;;;92     		i2c_SendByte(_usAddress);
00002a  b2e8              UXTB     r0,r5
00002c  f7fffffe          BL       i2c_SendByte
;;;93     		if (i2c_WaitAck() != 0)
000030  f7fffffe          BL       i2c_WaitAck
000034  b100              CBZ      r0,|L2.56|
;;;94     		{
;;;95     			goto cmd_fail;	/* EEPROM器件无应答 */
000036  e01e              B        |L2.118|
                  |L2.56|
;;;96     		}
;;;97     	}
;;;98     
;;;99     	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;100    	i2c_Start();
000038  f7fffffe          BL       i2c_Start
;;;101    
;;;102    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;103    	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
00003c  20a1              MOVS     r0,#0xa1
00003e  f7fffffe          BL       i2c_SendByte
;;;104    
;;;105    	/* 第8步：发送ACK */
;;;106    	if (i2c_WaitAck() != 0)
000042  f7fffffe          BL       i2c_WaitAck
000046  b100              CBZ      r0,|L2.74|
;;;107    	{
;;;108    		goto cmd_fail;	/* EEPROM器件无应答 */
000048  e015              B        |L2.118|
                  |L2.74|
;;;109    	}
;;;110    
;;;111    	/* 第9步：循环读取数据 */
;;;112    	for (i = 0; i < _usSize; i++)
00004a  2400              MOVS     r4,#0
00004c  e00c              B        |L2.104|
                  |L2.78|
;;;113    	{
;;;114    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
00004e  f7fffffe          BL       i2c_ReadByte
000052  5538              STRB     r0,[r7,r4]
;;;115    
;;;116    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;117    		if (i != _usSize - 1)
000054  1e70              SUBS     r0,r6,#1
000056  42a0              CMP      r0,r4
000058  d002              BEQ      |L2.96|
;;;118    		{
;;;119    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00005a  f7fffffe          BL       i2c_Ack
00005e  e001              B        |L2.100|
                  |L2.96|
;;;120    		}
;;;121    		else
;;;122    		{
;;;123    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000060  f7fffffe          BL       i2c_NAck
                  |L2.100|
000064  1c60              ADDS     r0,r4,#1              ;112
000066  b284              UXTH     r4,r0                 ;112
                  |L2.104|
000068  42b4              CMP      r4,r6                 ;112
00006a  dbf0              BLT      |L2.78|
;;;124    		}
;;;125    	}
;;;126    	/* 发送I2C总线停止信号 */
;;;127    	i2c_Stop();
00006c  f7fffffe          BL       i2c_Stop
;;;128    	return 1;	/* 执行成功 */
000070  2001              MOVS     r0,#1
                  |L2.114|
;;;129    
;;;130    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;131    	/* 发送I2C总线停止信号 */
;;;132    	i2c_Stop();
;;;133    	return 0;
;;;134    }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L2.118|
000076  f7fffffe          BL       i2c_Stop
00007a  2000              MOVS     r0,#0                 ;133
00007c  e7f9              B        |L2.114|
;;;135    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;145    */
;;;146    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;147    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;148    	uint16_t i,m;
;;;149    	uint16_t usAddr;
;;;150    
;;;151    	/*
;;;152    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;153    		对于24xx02，page size = 8
;;;154    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;155    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;156    	*/
;;;157    
;;;158    	usAddr = _usAddress;
00000a  4645              MOV      r5,r8
;;;159    	for (i = 0; i < _usSize; i++)
00000c  2400              MOVS     r4,#0
00000e  e033              B        |L3.120|
                  |L3.16|
;;;160    	{
;;;161    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;162    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000010  b114              CBZ      r4,|L3.24|
000012  f0150f3f          TST      r5,#0x3f
000016  d124              BNE      |L3.98|
                  |L3.24|
;;;163    		{
;;;164    			/*　第０步：发停止信号，启动内部写操作　*/
;;;165    			i2c_Stop();
000018  f7fffffe          BL       i2c_Stop
;;;166    
;;;167    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;168    				CLK频率为200KHz时，查询次数为30次左右
;;;169    			*/
;;;170    			for (m = 0; m < 1000; m++)
00001c  2600              MOVS     r6,#0
00001e  e00a              B        |L3.54|
                  |L3.32|
;;;171    			{
;;;172    				/* 第1步：发起I2C总线启动信号 */
;;;173    				i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;174    
;;;175    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;176    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000024  20a0              MOVS     r0,#0xa0
000026  f7fffffe          BL       i2c_SendByte
;;;177    
;;;178    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;179    				if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b900              CBNZ     r0,|L3.50|
;;;180    				{
;;;181    					break;
000030  e004              B        |L3.60|
                  |L3.50|
000032  1c70              ADDS     r0,r6,#1              ;170
000034  b286              UXTH     r6,r0                 ;170
                  |L3.54|
000036  f5b67f7a          CMP      r6,#0x3e8             ;170
00003a  dbf1              BLT      |L3.32|
                  |L3.60|
00003c  bf00              NOP      
;;;182    				}
;;;183    			}
;;;184    			if (m  == 1000)
00003e  f5b67f7a          CMP      r6,#0x3e8
000042  d100              BNE      |L3.70|
;;;185    			{
;;;186    				goto cmd_fail;	/* EEPROM器件写超时 */
000044  e01f              B        |L3.134|
                  |L3.70|
;;;187    			}
;;;188    
;;;189    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;190    			if (EE_ADDR_BYTES == 1)
;;;191    			{
;;;192    				i2c_SendByte((uint8_t)usAddr);
;;;193    				if (i2c_WaitAck() != 0)
;;;194    				{
;;;195    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;196    				}
;;;197    			}
;;;198    			else
;;;199    			{
;;;200    				i2c_SendByte(usAddr >> 8);
000046  1228              ASRS     r0,r5,#8
000048  f7fffffe          BL       i2c_SendByte
;;;201    				if (i2c_WaitAck() != 0)
00004c  f7fffffe          BL       i2c_WaitAck
000050  b100              CBZ      r0,|L3.84|
;;;202    				{
;;;203    					goto cmd_fail;	/* EEPROM器件无应答 */
000052  e018              B        |L3.134|
                  |L3.84|
;;;204    				}
;;;205    
;;;206    				i2c_SendByte(usAddr);
000054  b2e8              UXTB     r0,r5
000056  f7fffffe          BL       i2c_SendByte
;;;207    				if (i2c_WaitAck() != 0)
00005a  f7fffffe          BL       i2c_WaitAck
00005e  b100              CBZ      r0,|L3.98|
;;;208    				{
;;;209    					goto cmd_fail;	/* EEPROM器件无应答 */
000060  e011              B        |L3.134|
                  |L3.98|
;;;210    				}
;;;211    			}
;;;212    		}
;;;213    
;;;214    		/* 第6步：开始写入数据 */
;;;215    		i2c_SendByte(_pWriteBuf[i]);
000062  5d38              LDRB     r0,[r7,r4]
000064  f7fffffe          BL       i2c_SendByte
;;;216    
;;;217    		/* 第7步：发送ACK */
;;;218    		if (i2c_WaitAck() != 0)
000068  f7fffffe          BL       i2c_WaitAck
00006c  b100              CBZ      r0,|L3.112|
;;;219    		{
;;;220    			goto cmd_fail;	/* EEPROM器件无应答 */
00006e  e00a              B        |L3.134|
                  |L3.112|
;;;221    		}
;;;222    
;;;223    		usAddr++;	/* 地址增1 */
000070  1c68              ADDS     r0,r5,#1
000072  b285              UXTH     r5,r0
000074  1c60              ADDS     r0,r4,#1              ;159
000076  b284              UXTH     r4,r0                 ;159
                  |L3.120|
000078  454c              CMP      r4,r9                 ;159
00007a  dbc9              BLT      |L3.16|
;;;224    	}
;;;225    
;;;226    	/* 命令执行成功，发送I2C总线停止信号 */
;;;227    	i2c_Stop();
00007c  f7fffffe          BL       i2c_Stop
;;;228    	return 1;
000080  2001              MOVS     r0,#1
                  |L3.130|
;;;229    
;;;230    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;231    	/* 发送I2C总线停止信号 */
;;;232    	i2c_Stop();
;;;233    	return 0;
;;;234    }
000082  e8bd87f0          POP      {r4-r10,pc}
                  |L3.134|
000086  f7fffffe          BL       i2c_Stop
00008a  2000              MOVS     r0,#0                 ;233
00008c  e7f9              B        |L3.130|
;;;235    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\User\\bsp_stm32f4xx\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 129 "F:\\keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 144
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
