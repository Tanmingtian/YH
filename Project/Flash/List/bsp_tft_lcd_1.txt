; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_tft_lcd_1.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_tft_lcd_1.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\User\fatfs\src -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_tft_lcd_1.crf ..\..\User\bsp_stm32f4xx\src\bsp_tft_lcd.c]
                          THUMB

                          AREA ||i.Blend565||, CODE, READONLY, ALIGN=2

                  Blend565 PROC
;;;751    */
;;;752    uint16_t Blend565(uint16_t src, uint16_t dst, uint8_t alpha)
000000  b570              PUSH     {r4-r6,lr}
;;;753    {
000002  4603              MOV      r3,r0
;;;754    	uint32_t src2;
;;;755    	uint32_t dst2;
;;;756    
;;;757    	src2 = ((src << 16) |src) & 0x07E0F81F;
000004  ea434003          ORR      r0,r3,r3,LSL #16
000008  4e08              LDR      r6,|L1.44|
00000a  ea000406          AND      r4,r0,r6
;;;758    	dst2 = ((dst << 16) | dst) & 0x07E0F81F;
00000e  ea414001          ORR      r0,r1,r1,LSL #16
000012  ea000506          AND      r5,r0,r6
;;;759    	dst2 = ((((dst2 - src2) * alpha) >> 5) + src2) & 0x07E0F81F;
000016  1b28              SUBS     r0,r5,r4
000018  4350              MULS     r0,r2,r0
00001a  eb041050          ADD      r0,r4,r0,LSR #5
00001e  ea000506          AND      r5,r0,r6
;;;760    	return (dst2 >> 16) | dst2;
000022  ea454015          ORR      r0,r5,r5,LSR #16
000026  b280              UXTH     r0,r0
;;;761    }
000028  bd70              POP      {r4-r6,pc}
;;;762    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x07e0f81f

                          AREA ||i.Bus_Delay||, CODE, READONLY, ALIGN=1

                  Bus_Delay PROC
;;;57     */
;;;58     static void Bus_Delay(__IO uint32_t nCount)
000000  b501              PUSH     {r0,lr}
;;;59     {
;;;60       for(; nCount != 0; nCount--);
000002  e002              B        |L2.10|
                  |L2.4|
000004  9800              LDR      r0,[sp,#0]
000006  1e40              SUBS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L2.10|
00000a  9800              LDR      r0,[sp,#0]
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L2.4|
;;;61     }
000010  bd08              POP      {r3,pc}
;;;62     
                          ENDP


                          AREA ||i.LCD_ClrScr||, CODE, READONLY, ALIGN=2

                  LCD_ClrScr PROC
;;;224    */
;;;225    void LCD_ClrScr(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;226    {
000002  4604              MOV      r4,r0
;;;227    	if (g_ChipID == IC_8875)	/* RA8875 分支 */
000004  4805              LDR      r0,|L3.28|
000006  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000008  2875              CMP      r0,#0x75
00000a  d103              BNE      |L3.20|
;;;228    	{
;;;229    		RA8875_ClrScr(_usColor);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RA8875_ClrScr
000012  e002              B        |L3.26|
                  |L3.20|
;;;230    	}
;;;231    	else	/* 5420，4001，61509 分支 */
;;;232    	{
;;;233    		SPFD5420_ClrScr(_usColor);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPFD5420_ClrScr
                  |L3.26|
;;;234    	}
;;;235    }
00001a  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L3.28|
                          DCD      g_ChipID

                          AREA ||i.LCD_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  LCD_CtrlLinesConfig PROC
;;;1423   */
;;;1424   static void LCD_CtrlLinesConfig(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;1425   {
;;;1426   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1427   
;;;1428   	/* 使能FSMC时钟 */
;;;1429   	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;1430   
;;;1431   	/* 使能 GPIO时钟 */
;;;1432   	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2058              MOVS     r0,#0x58
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1433   
;;;1434   	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;1435   	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;1436   
;;;1437   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
000012  220c              MOVS     r2,#0xc
000014  2100              MOVS     r1,#0
000016  484a              LDR      r0,|L4.320|
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;1438   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
00001c  220c              MOVS     r2,#0xc
00001e  2101              MOVS     r1,#1
000020  4847              LDR      r0,|L4.320|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;1439   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000026  220c              MOVS     r2,#0xc
000028  2104              MOVS     r1,#4
00002a  4845              LDR      r0,|L4.320|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;1440   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
000030  220c              MOVS     r2,#0xc
000032  2105              MOVS     r1,#5
000034  4842              LDR      r0,|L4.320|
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;1441   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
00003a  220c              MOVS     r2,#0xc
00003c  2108              MOVS     r1,#8
00003e  4840              LDR      r0,|L4.320|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;1442   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
000044  220c              MOVS     r2,#0xc
000046  2109              MOVS     r1,#9
000048  483d              LDR      r0,|L4.320|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;1443   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
00004e  220c              MOVS     r2,#0xc
000050  210a              MOVS     r1,#0xa
000052  483b              LDR      r0,|L4.320|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;1444   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000058  220c              MOVS     r2,#0xc
00005a  210e              MOVS     r1,#0xe
00005c  4838              LDR      r0,|L4.320|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;1445   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
000062  220c              MOVS     r2,#0xc
000064  210f              MOVS     r1,#0xf
000066  4836              LDR      r0,|L4.320|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;1446   
;;;1447   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
00006c  f24c7033          MOV      r0,#0xc733
000070  9000              STR      r0,[sp,#0]
;;;1448   	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;1449   	                            GPIO_Pin_15;
;;;1450   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000072  2002              MOVS     r0,#2
000074  f88d0004          STRB     r0,[sp,#4]
;;;1451   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000078  2003              MOVS     r0,#3
00007a  f88d0005          STRB     r0,[sp,#5]
;;;1452   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00007e  2000              MOVS     r0,#0
000080  f88d0006          STRB     r0,[sp,#6]
;;;1453   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000084  f88d0007          STRB     r0,[sp,#7]
;;;1454   	GPIO_Init(GPIOD, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  482d              LDR      r0,|L4.320|
00008c  f7fffffe          BL       GPIO_Init
;;;1455   
;;;1456   	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;1457   	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;1458   
;;;1459   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FSMC);
000090  220c              MOVS     r2,#0xc
000092  2104              MOVS     r1,#4
000094  482b              LDR      r0,|L4.324|
000096  f7fffffe          BL       GPIO_PinAFConfig
;;;1460   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FSMC);
00009a  220c              MOVS     r2,#0xc
00009c  2105              MOVS     r1,#5
00009e  4829              LDR      r0,|L4.324|
0000a0  f7fffffe          BL       GPIO_PinAFConfig
;;;1461   
;;;1462   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
0000a4  220c              MOVS     r2,#0xc
0000a6  2107              MOVS     r1,#7
0000a8  4826              LDR      r0,|L4.324|
0000aa  f7fffffe          BL       GPIO_PinAFConfig
;;;1463   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
0000ae  220c              MOVS     r2,#0xc
0000b0  2108              MOVS     r1,#8
0000b2  4824              LDR      r0,|L4.324|
0000b4  f7fffffe          BL       GPIO_PinAFConfig
;;;1464   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
0000b8  220c              MOVS     r2,#0xc
0000ba  2109              MOVS     r1,#9
0000bc  4821              LDR      r0,|L4.324|
0000be  f7fffffe          BL       GPIO_PinAFConfig
;;;1465   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
0000c2  220c              MOVS     r2,#0xc
0000c4  210a              MOVS     r1,#0xa
0000c6  481f              LDR      r0,|L4.324|
0000c8  f7fffffe          BL       GPIO_PinAFConfig
;;;1466   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
0000cc  220c              MOVS     r2,#0xc
0000ce  210b              MOVS     r1,#0xb
0000d0  481c              LDR      r0,|L4.324|
0000d2  f7fffffe          BL       GPIO_PinAFConfig
;;;1467   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0000d6  220c              MOVS     r2,#0xc
0000d8  4611              MOV      r1,r2
0000da  481a              LDR      r0,|L4.324|
0000dc  f7fffffe          BL       GPIO_PinAFConfig
;;;1468   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0000e0  220c              MOVS     r2,#0xc
0000e2  210d              MOVS     r1,#0xd
0000e4  4817              LDR      r0,|L4.324|
0000e6  f7fffffe          BL       GPIO_PinAFConfig
;;;1469   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0000ea  220c              MOVS     r2,#0xc
0000ec  210e              MOVS     r1,#0xe
0000ee  4815              LDR      r0,|L4.324|
0000f0  f7fffffe          BL       GPIO_PinAFConfig
;;;1470   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0000f4  220c              MOVS     r2,#0xc
0000f6  210f              MOVS     r1,#0xf
0000f8  4812              LDR      r0,|L4.324|
0000fa  f7fffffe          BL       GPIO_PinAFConfig
;;;1471   
;;;1472   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0000fe  f64f70b0          MOV      r0,#0xffb0
000102  9000              STR      r0,[sp,#0]
;;;1473   	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;1474   	                            GPIO_Pin_15;
;;;1475   	GPIO_Init(GPIOE, &GPIO_InitStructure);
000104  4669              MOV      r1,sp
000106  480f              LDR      r0,|L4.324|
000108  f7fffffe          BL       GPIO_Init
;;;1476   
;;;1477   	/* 设置 PD.13(A18 (RS))  为复用推挽输出 */
;;;1478   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
00010c  220c              MOVS     r2,#0xc
00010e  210d              MOVS     r1,#0xd
000110  480b              LDR      r0,|L4.320|
000112  f7fffffe          BL       GPIO_PinAFConfig
;;;1479   
;;;1480   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000116  f44f5000          MOV      r0,#0x2000
00011a  9000              STR      r0,[sp,#0]
;;;1481   	GPIO_Init(GPIOD, &GPIO_InitStructure);
00011c  4669              MOV      r1,sp
00011e  4808              LDR      r0,|L4.320|
000120  f7fffffe          BL       GPIO_Init
;;;1482   
;;;1483   	/* 设置 PG12 (LCD/CS)) 为复用推挽输出 */
;;;1484   	GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_FSMC);
000124  220c              MOVS     r2,#0xc
000126  4611              MOV      r1,r2
000128  4807              LDR      r0,|L4.328|
00012a  f7fffffe          BL       GPIO_PinAFConfig
;;;1485   
;;;1486   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00012e  f44f5080          MOV      r0,#0x1000
000132  9000              STR      r0,[sp,#0]
;;;1487   	GPIO_Init(GPIOG, &GPIO_InitStructure);
000134  4669              MOV      r1,sp
000136  4804              LDR      r0,|L4.328|
000138  f7fffffe          BL       GPIO_Init
;;;1488   }
00013c  bd1c              POP      {r2-r4,pc}
;;;1489   
                          ENDP

00013e  0000              DCW      0x0000
                  |L4.320|
                          DCD      0x40020c00
                  |L4.324|
                          DCD      0x40021000
                  |L4.328|
                          DCD      0x40021800

                          AREA ||i.LCD_DispControl||, CODE, READONLY, ALIGN=1

                  LCD_DispControl PROC
;;;1269   */
;;;1270   void LCD_DispControl(void *_pControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1271   {
000002  4604              MOV      r4,r0
;;;1272   	uint8_t id;
;;;1273   
;;;1274   	id = *(uint8_t *)_pControl;	/* 读取ID */
000004  7825              LDRB     r5,[r4,#0]
;;;1275   
;;;1276   	switch (id)
000006  2d08              CMP      r5,#8
000008  d21e              BCS      |L5.72|
00000a  e8dff005          TBB      [pc,r5]
00000e  1d04              DCB      0x1d,0x04
000010  05090d11          DCB      0x05,0x09,0x0d,0x11
000014  1519              DCB      0x15,0x19
;;;1277   	{
;;;1278   		case ID_ICON:
;;;1279   			//void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode);
;;;1280   			break;
000016  e017              B        |L5.72|
;;;1281   
;;;1282   		case ID_WIN:
;;;1283   			LCD_DrawWin((WIN_T *)_pControl);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       LCD_DrawWin
;;;1284   			break;
00001e  e013              B        |L5.72|
;;;1285   
;;;1286   		case ID_LABEL:
;;;1287   			LCD_DrawLabel((LABEL_T *)_pControl);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       LCD_DrawLabel
;;;1288   			break;
000026  e00f              B        |L5.72|
;;;1289   
;;;1290   		case ID_BUTTON:
;;;1291   			LCD_DrawButton((BUTTON_T *)_pControl);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       LCD_DrawButton
;;;1292   			break;
00002e  e00b              B        |L5.72|
;;;1293   
;;;1294   		case ID_CHECK:
;;;1295   			LCD_DrawCheckBox((CHECK_T *)_pControl);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       LCD_DrawCheckBox
;;;1296   			break;
000036  e007              B        |L5.72|
;;;1297   
;;;1298   		case ID_EDIT:
;;;1299   			LCD_DrawEdit((EDIT_T *)_pControl);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       LCD_DrawEdit
;;;1300   			break;
00003e  e003              B        |L5.72|
;;;1301   
;;;1302   		case ID_GROUP:
;;;1303   			LCD_DrawGroupBox((GROUP_T *)_pControl);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       LCD_DrawGroupBox
;;;1304   			break;
000046  bf00              NOP      
                  |L5.72|
000048  bf00              NOP                            ;1280
;;;1305   	}
;;;1306   }
00004a  bd70              POP      {r4-r6,pc}
;;;1307   
                          ENDP


                          AREA ||i.LCD_DispOff||, CODE, READONLY, ALIGN=2

                  LCD_DispOff PROC
;;;204    */
;;;205    void LCD_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;206    {
;;;207    	if (g_ChipID == IC_8875)
000002  4805              LDR      r0,|L6.24|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L6.16|
;;;208    	{
;;;209    		RA8875_DispOff();
00000a  f7fffffe          BL       RA8875_DispOff
00000e  e001              B        |L6.20|
                  |L6.16|
;;;210    	}
;;;211    	else	/* 61509, 5420, 4001 */
;;;212    	{
;;;213    		SPFD5420_DispOff();
000010  f7fffffe          BL       SPFD5420_DispOff
                  |L6.20|
;;;214    	}
;;;215    }
000014  bd10              POP      {r4,pc}
;;;216    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispOn||, CODE, READONLY, ALIGN=2

                  LCD_DispOn PROC
;;;184    */
;;;185    void LCD_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;186    {
;;;187    	if (g_ChipID == IC_8875)
000002  4805              LDR      r0,|L7.24|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L7.16|
;;;188    	{
;;;189    		RA8875_DispOn();
00000a  f7fffffe          BL       RA8875_DispOn
00000e  e001              B        |L7.20|
                  |L7.16|
;;;190    	}
;;;191    	else	/* 61509, 5420, 4001 */
;;;192    	{
;;;193    		SPFD5420_DispOn();
000010  f7fffffe          BL       SPFD5420_DispOn
                  |L7.20|
;;;194    	}
;;;195    }
000014  bd10              POP      {r4,pc}
;;;196    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispStr||, CODE, READONLY, ALIGN=2

                  LCD_DispStr PROC
;;;248    */
;;;249    void LCD_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;250    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4691              MOV      r9,r2
000008  461f              MOV      r7,r3
;;;251    	uint32_t i;
;;;252    	uint8_t code1;
;;;253    	uint8_t code2;
;;;254    	uint32_t address;
;;;255    	uint8_t buf[24 * 24 / 8];	/* 最大支持24点阵汉字 */
;;;256    	uint8_t width;
;;;257    	uint16_t m;
;;;258    	uint8_t font_width,font_height, font_bytes;
;;;259    	uint16_t x, y;
;;;260    	const uint8_t *pAscDot;
;;;261    
;;;262    #ifdef USE_SMALL_FONT	
;;;263    	const uint8_t *pHzDot;
;;;264    #else	
;;;265    	uint32_t AddrHZK;
;;;266    #endif	
;;;267    
;;;268    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;269    	if (_tFont->FontCode == FC_ST_12)
00000a  8838              LDRH     r0,[r7,#0]
00000c  2801              CMP      r0,#1
00000e  d107              BNE      |L8.32|
;;;270    	{
;;;271    		font_height = 12;
000010  200c              MOVS     r0,#0xc
000012  9005              STR      r0,[sp,#0x14]
;;;272    		font_width = 12;
000014  4680              MOV      r8,r0
;;;273    		font_bytes = 24;
000016  2418              MOVS     r4,#0x18
;;;274    		pAscDot = g_Ascii12;
000018  4855              LDR      r0,|L8.368|
00001a  9002              STR      r0,[sp,#8]
;;;275    		
;;;276    	#ifdef USE_SMALL_FONT		
;;;277    		pHzDot = g_Hz12;		
00001c  4e55              LDR      r6,|L8.372|
00001e  e006              B        |L8.46|
                  |L8.32|
;;;278    	#else
;;;279    		AddrHZK = HZK12_ADDR;
;;;280    	#endif		
;;;281    	}
;;;282    	else
;;;283    	{
;;;284    		/* 缺省是16点阵 */
;;;285    		font_height = 16;
000020  2010              MOVS     r0,#0x10
000022  9005              STR      r0,[sp,#0x14]
;;;286    		font_width = 16;
000024  4680              MOV      r8,r0
;;;287    		font_bytes = 32;
000026  2420              MOVS     r4,#0x20
;;;288    		pAscDot = g_Ascii16;
000028  4853              LDR      r0,|L8.376|
00002a  9002              STR      r0,[sp,#8]
;;;289    		
;;;290    	#ifdef USE_SMALL_FONT	
;;;291    		pHzDot = g_Hz16;	
00002c  4e53              LDR      r6,|L8.380|
                  |L8.46|
;;;292    	#else
;;;293    		AddrHZK = HZK16_ADDR;
;;;294    	#endif		
;;;295    	}
;;;296    
;;;297    	/* 开始循环处理字符 */
;;;298    	while (*_ptr != 0)
00002e  e096              B        |L8.350|
                  |L8.48|
;;;299    	{
;;;300    		code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
000030  f8990000          LDRB     r0,[r9,#0]
000034  901a              STR      r0,[sp,#0x68]
;;;301    		if (code1 < 0x80)
000036  981a              LDR      r0,[sp,#0x68]
000038  2880              CMP      r0,#0x80
00003a  da16              BGE      |L8.106|
;;;302    		{
;;;303    			/* 将ascii字符点阵复制到buf */
;;;304    			memcpy(buf, &pAscDot[code1 * (font_bytes / 2)], (font_bytes / 2));
00003c  9401              STR      r4,[sp,#4]
00003e  eb0470d4          ADD      r0,r4,r4,LSR #31
000042  ea4f0c60          ASR      r12,r0,#1
000046  9400              STR      r4,[sp,#0]
000048  9b1a              LDR      r3,[sp,#0x68]
00004a  9802              LDR      r0,[sp,#8]
00004c  fb03010c          MLA      r1,r3,r12,r0
000050  eb0470d4          ADD      r0,r4,r4,LSR #31
000054  1042              ASRS     r2,r0,#1
000056  a807              ADD      r0,sp,#0x1c
000058  f7fffffe          BL       __aeabi_memcpy
;;;305    			width = font_width / 2;
00005c  4640              MOV      r0,r8
00005e  eb0871d0          ADD      r1,r8,r0,LSR #31
000062  f3c10147          UBFX     r1,r1,#1,#8
000066  9106              STR      r1,[sp,#0x18]
000068  e032              B        |L8.208|
                  |L8.106|
;;;306    		}
;;;307    		else
;;;308    		{
;;;309    			code2 = *++_ptr;
00006a  f1090001          ADD      r0,r9,#1
00006e  4681              MOV      r9,r0
000070  7800              LDRB     r0,[r0,#0]
000072  9019              STR      r0,[sp,#0x64]
;;;310    			if (code2 == 0)
000074  9819              LDR      r0,[sp,#0x64]
000076  b900              CBNZ     r0,|L8.122|
;;;311    			{
;;;312    				break;
000078  e076              B        |L8.360|
                  |L8.122|
;;;313    			}
;;;314    
;;;315    			/* 计算16点阵汉字点阵地址
;;;316    				ADDRESS = [(code1-0xa1) * 94 + (code2-0xa1)] * 32
;;;317    				;
;;;318    			*/
;;;319    			#ifdef USE_SMALL_FONT
;;;320    				m = 0;
00007a  f04f0a00          MOV      r10,#0
;;;321    				while(1)
00007e  e023              B        |L8.200|
                  |L8.128|
;;;322    				{
;;;323    					address = m * (font_bytes + 2);
000080  1ca0              ADDS     r0,r4,#2
000082  fb0af500          MUL      r5,r10,r0
;;;324    					m++;
000086  f10a0001          ADD      r0,r10,#1
00008a  fa1ffa80          UXTH     r10,r0
;;;325    					if ((code1 == pHzDot[address + 0]) && (code2 == pHzDot[address + 1]))
00008e  5d71              LDRB     r1,[r6,r5]
000090  981a              LDR      r0,[sp,#0x68]
000092  4281              CMP      r1,r0
000094  d10b              BNE      |L8.174|
000096  1c68              ADDS     r0,r5,#1
000098  5c31              LDRB     r1,[r6,r0]
00009a  9819              LDR      r0,[sp,#0x64]
00009c  4281              CMP      r1,r0
00009e  d106              BNE      |L8.174|
;;;326    					{
;;;327    						address += 2;
0000a0  1cad              ADDS     r5,r5,#2
;;;328    						memcpy(buf, &pHzDot[address], font_bytes);
0000a2  1971              ADDS     r1,r6,r5
0000a4  4622              MOV      r2,r4
0000a6  a807              ADD      r0,sp,#0x1c
0000a8  f7fffffe          BL       __aeabi_memcpy
;;;329    						break;
0000ac  e00d              B        |L8.202|
                  |L8.174|
;;;330    					}
;;;331    					else if ((pHzDot[address + 0] == 0xFF) && (pHzDot[address + 1] == 0xFF))
0000ae  5d70              LDRB     r0,[r6,r5]
0000b0  28ff              CMP      r0,#0xff
0000b2  d109              BNE      |L8.200|
0000b4  1c68              ADDS     r0,r5,#1
0000b6  5c30              LDRB     r0,[r6,r0]
0000b8  28ff              CMP      r0,#0xff
0000ba  d105              BNE      |L8.200|
;;;332    					{
;;;333    						/* 字库搜索完毕，未找到，则填充全FF */
;;;334    						memset(buf, 0xFF, font_bytes);
0000bc  22ff              MOVS     r2,#0xff
0000be  4621              MOV      r1,r4
0000c0  a807              ADD      r0,sp,#0x1c
0000c2  f7fffffe          BL       __aeabi_memset
;;;335    						break;
0000c6  e000              B        |L8.202|
                  |L8.200|
0000c8  e7da              B        |L8.128|
                  |L8.202|
0000ca  bf00              NOP                            ;329
;;;336    					}
;;;337    				}
;;;338    			#else	/* 用全字库 */
;;;339    				/* 此处需要根据字库文件存放位置进行修改 */
;;;340    				if (code1 >=0xA1 && code1 <= 0xA9 && code2 >=0xA1)
;;;341    				{
;;;342    					address = ((code1 - 0xA1) * 94 + (code2 - 0xA1)) * font_bytes + AddrHZK;
;;;343    				}
;;;344    				else if (code1 >=0xB0 && code1 <= 0xF7 && code2 >=0xA1)
;;;345    				{
;;;346    					address = ((code1 - 0xB0) * 94 + (code2 - 0xA1) + 846) * font_bytes + AddrHZK;
;;;347    				}
;;;348    				memcpy(buf, (const uint8_t *)address, font_bytes);
;;;349    			#endif
;;;350    
;;;351    				width = font_width;
0000cc  f8cd8018          STR      r8,[sp,#0x18]
                  |L8.208|
;;;352    		}
;;;353    
;;;354    		y = _usY;
0000d0  981c              LDR      r0,[sp,#0x70]
0000d2  9003              STR      r0,[sp,#0xc]
;;;355    		/* 开始刷LCD */
;;;356    		for (m = 0; m < font_height; m++)	/* 字符高度 */
0000d4  f04f0a00          MOV      r10,#0
0000d8  e035              B        |L8.326|
                  |L8.218|
;;;357    		{
;;;358    			x = _usX;
0000da  981b              LDR      r0,[sp,#0x6c]
0000dc  9004              STR      r0,[sp,#0x10]
;;;359    			for (i = 0; i < width; i++)	/* 字符宽度 */
0000de  f04f0b00          MOV      r11,#0
0000e2  e025              B        |L8.304|
                  |L8.228|
;;;360    			{
;;;361    				if ((buf[m * ((2 * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
0000e4  9806              LDR      r0,[sp,#0x18]
0000e6  0040              LSLS     r0,r0,#1
0000e8  fb90f0f8          SDIV     r0,r0,r8
0000ec  fb00f00a          MUL      r0,r0,r10
0000f0  eb0000db          ADD      r0,r0,r11,LSR #3
0000f4  a907              ADD      r1,sp,#0x1c
0000f6  5c08              LDRB     r0,[r1,r0]
0000f8  f00b0207          AND      r2,r11,#7
0000fc  2180              MOVS     r1,#0x80
0000fe  4111              ASRS     r1,r1,r2
000100  4008              ANDS     r0,r0,r1
000102  b128              CBZ      r0,|L8.272|
;;;362    				{
;;;363    					LCD_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
000104  887a              LDRH     r2,[r7,#2]
000106  e9dd1003          LDRD     r1,r0,[sp,#0xc]
00010a  f7fffffe          BL       LCD_PutPixel
00010e  e009              B        |L8.292|
                  |L8.272|
;;;364    				}
;;;365    				else
;;;366    				{
;;;367    					if (_tFont->BackColor != CL_MASK)	/* 透明色 */
000110  88b8              LDRH     r0,[r7,#4]
000112  f6491199          MOV      r1,#0x9999
000116  4288              CMP      r0,r1
000118  d004              BEQ      |L8.292|
;;;368    					{
;;;369    						LCD_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
00011a  88ba              LDRH     r2,[r7,#4]
00011c  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000120  f7fffffe          BL       LCD_PutPixel
                  |L8.292|
;;;370    					}
;;;371    				}
;;;372    
;;;373    				x++;
000124  9804              LDR      r0,[sp,#0x10]
000126  1c40              ADDS     r0,r0,#1
000128  b280              UXTH     r0,r0
00012a  9004              STR      r0,[sp,#0x10]
00012c  f10b0b01          ADD      r11,r11,#1            ;359
                  |L8.304|
000130  9806              LDR      r0,[sp,#0x18]         ;359
000132  4583              CMP      r11,r0                ;359
000134  d3d6              BCC      |L8.228|
;;;374    			}
;;;375    			y++;
000136  9803              LDR      r0,[sp,#0xc]
000138  1c40              ADDS     r0,r0,#1
00013a  b280              UXTH     r0,r0
00013c  9003              STR      r0,[sp,#0xc]
00013e  f10a0001          ADD      r0,r10,#1             ;356
000142  fa1ffa80          UXTH     r10,r0                ;356
                  |L8.326|
000146  9805              LDR      r0,[sp,#0x14]         ;356
000148  4582              CMP      r10,r0                ;356
00014a  dbc6              BLT      |L8.218|
;;;376    		}
;;;377    
;;;378    		if (_tFont->Space > 0)
;;;379    		{
;;;380    			/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;381    		}
;;;382    		_usX += width + _tFont->Space;	/* 列地址递增 */
00014c  88f9              LDRH     r1,[r7,#6]
00014e  9806              LDR      r0,[sp,#0x18]
000150  4401              ADD      r1,r1,r0
000152  981b              LDR      r0,[sp,#0x6c]
000154  4408              ADD      r0,r0,r1
000156  b280              UXTH     r0,r0
000158  901b              STR      r0,[sp,#0x6c]
;;;383    		_ptr++;			/* 指向下一个字符 */
00015a  f1090901          ADD      r9,r9,#1
                  |L8.350|
00015e  f8990000          LDRB     r0,[r9,#0]            ;298
000162  2800              CMP      r0,#0                 ;298
000164  f47faf64          BNE      |L8.48|
                  |L8.360|
000168  bf00              NOP                            ;312
;;;384    	}
;;;385    }
00016a  b01f              ADD      sp,sp,#0x7c
00016c  e8bd8ff0          POP      {r4-r11,pc}
;;;386    
                          ENDP

                  |L8.368|
                          DCD      g_Ascii12
                  |L8.372|
                          DCD      g_Hz12
                  |L8.376|
                          DCD      g_Ascii16
                  |L8.380|
                          DCD      g_Hz16

                          AREA ||i.LCD_DrawBMP||, CODE, READONLY, ALIGN=2

                  LCD_DrawBMP PROC
;;;562    */
;;;563    void LCD_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;564    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;565    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L9.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L9.38|
;;;566    	{
;;;567    		RA8875_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawBMP
000024  e006              B        |L9.52|
                  |L9.38|
;;;568    	}
;;;569    	else
;;;570    	{
;;;571    		SPFD5420_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawBMP
                  |L9.52|
;;;572    	}
;;;573    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;574    
                          ENDP

                  |L9.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawBmp32||, CODE, READONLY, ALIGN=1

                  LCD_DrawBmp32 PROC
;;;867    */
;;;868    void LCD_DrawBmp32(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t *_pBmp)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;869    {
000004  b087              SUB      sp,sp,#0x1c
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;870    	const uint8_t *p;
;;;871    	uint16_t usOldRGB, usNewRGB;
;;;872    	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;873    	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;874    	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;875    
;;;876    	p = (const uint8_t *)_pBmp;
00000a  9c14              LDR      r4,[sp,#0x50]
;;;877    	p += 54;		/* 直接指向图像数据区 */
00000c  3436              ADDS     r4,r4,#0x36
;;;878    
;;;879    	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;880    	for (y = _usHeight - 1; y >= 0; y--)
00000e  9809              LDR      r0,[sp,#0x24]
000010  1e40              SUBS     r0,r0,#1
000012  b207              SXTH     r7,r0
000014  e081              B        |L10.282|
                  |L10.22|
;;;881    	{
;;;882    		for (x = 0; x < _usWidth; x++)
000016  2600              MOVS     r6,#0
000018  e07a              B        |L10.272|
                  |L10.26|
;;;883    		{
;;;884    			B1 = *p++;
00001a  f8140b01          LDRB     r0,[r4],#1
00001e  9004              STR      r0,[sp,#0x10]
;;;885    			G1 = *p++;
000020  f8140b01          LDRB     r0,[r4],#1
000024  9005              STR      r0,[sp,#0x14]
;;;886    			R1 = *p++;
000026  f814bb01          LDRB     r11,[r4],#1
;;;887    			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002a  f8145b01          LDRB     r5,[r4],#1
;;;888    
;;;889    			if (A == 0x00)	/* 需要透明,显示背景 */
00002e  2d00              CMP      r5,#0
000030  d06c              BEQ      |L10.268|
;;;890    			{
;;;891    				;	/* 不用刷新背景 */
;;;892    			}
;;;893    			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000032  2dff              CMP      r5,#0xff
000034  d114              BNE      |L10.96|
;;;894    			{
;;;895    				usNewRGB = RGB(R1, G1, B1);
000036  ea4f00eb          ASR      r0,r11,#3
00003a  02c1              LSLS     r1,r0,#11
00003c  9805              LDR      r0,[sp,#0x14]
00003e  1080              ASRS     r0,r0,#2
000040  ea411140          ORR      r1,r1,r0,LSL #5
000044  9804              LDR      r0,[sp,#0x10]
000046  ea4100e0          ORR      r0,r1,r0,ASR #3
00004a  9006              STR      r0,[sp,#0x18]
;;;896    				//if (_ucFocusMode == 1)
;;;897    				//{
;;;898    				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;899    				//}
;;;900    				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
00004c  eb070209          ADD      r2,r7,r9
000050  b291              UXTH     r1,r2
000052  eb060208          ADD      r2,r6,r8
000056  b290              UXTH     r0,r2
000058  9a06              LDR      r2,[sp,#0x18]
00005a  f7fffffe          BL       LCD_PutPixel
00005e  e055              B        |L10.268|
                  |L10.96|
;;;901    			}
;;;902    			else 	/* 半透明 */
;;;903    			{
;;;904    				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;905    				usOldRGB = LCD_GetPixel(x + _usX, y + _usY);
000060  eb070209          ADD      r2,r7,r9
000064  b291              UXTH     r1,r2
000066  eb060208          ADD      r2,r6,r8
00006a  b290              UXTH     r0,r2
00006c  f7fffffe          BL       LCD_GetPixel
000070  4682              MOV      r10,r0
;;;906    				R0 = RGB565_R(usOldRGB);
000072  20f8              MOVS     r0,#0xf8
000074  ea00202a          AND      r0,r0,r10,ASR #8
000078  9003              STR      r0,[sp,#0xc]
;;;907    				G0 = RGB565_G(usOldRGB);
00007a  20fc              MOVS     r0,#0xfc
00007c  ea0000ea          AND      r0,r0,r10,ASR #3
000080  9002              STR      r0,[sp,#8]
;;;908    				B0 = RGB565_B(usOldRGB);
000082  20f8              MOVS     r0,#0xf8
000084  ea0000ca          AND      r0,r0,r10,LSL #3
000088  9001              STR      r0,[sp,#4]
;;;909    
;;;910    				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
00008a  fb0bf005          MUL      r0,r11,r5
00008e  21ff              MOVS     r1,#0xff
000090  fb90f2f1          SDIV     r2,r0,r1
000094  f1c501ff          RSB      r1,r5,#0xff
000098  9803              LDR      r0,[sp,#0xc]
00009a  4341              MULS     r1,r0,r1
00009c  20ff              MOVS     r0,#0xff
00009e  fb91f0f0          SDIV     r0,r1,r0
0000a2  4410              ADD      r0,r0,r2
0000a4  f0000bff          AND      r11,r0,#0xff
;;;911    				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000a8  9805              LDR      r0,[sp,#0x14]
0000aa  4368              MULS     r0,r5,r0
0000ac  21ff              MOVS     r1,#0xff
0000ae  fb90f2f1          SDIV     r2,r0,r1
0000b2  f1c501ff          RSB      r1,r5,#0xff
0000b6  9802              LDR      r0,[sp,#8]
0000b8  4341              MULS     r1,r0,r1
0000ba  20ff              MOVS     r0,#0xff
0000bc  fb91f0f0          SDIV     r0,r1,r0
0000c0  4410              ADD      r0,r0,r2
0000c2  b2c0              UXTB     r0,r0
0000c4  9005              STR      r0,[sp,#0x14]
;;;912    				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000c6  9804              LDR      r0,[sp,#0x10]
0000c8  4368              MULS     r0,r5,r0
0000ca  21ff              MOVS     r1,#0xff
0000cc  fb90f2f1          SDIV     r2,r0,r1
0000d0  f1c501ff          RSB      r1,r5,#0xff
0000d4  9801              LDR      r0,[sp,#4]
0000d6  4341              MULS     r1,r0,r1
0000d8  20ff              MOVS     r0,#0xff
0000da  fb91f0f0          SDIV     r0,r1,r0
0000de  4410              ADD      r0,r0,r2
0000e0  b2c0              UXTB     r0,r0
0000e2  9004              STR      r0,[sp,#0x10]
;;;913    				usNewRGB = RGB(R1, G1, B1);
0000e4  ea4f00eb          ASR      r0,r11,#3
0000e8  02c1              LSLS     r1,r0,#11
0000ea  9805              LDR      r0,[sp,#0x14]
0000ec  1080              ASRS     r0,r0,#2
0000ee  ea411140          ORR      r1,r1,r0,LSL #5
0000f2  9804              LDR      r0,[sp,#0x10]
0000f4  ea4100e0          ORR      r0,r1,r0,ASR #3
0000f8  9006              STR      r0,[sp,#0x18]
;;;914    				//if (_ucFocusMode == 1)
;;;915    				//{
;;;916    				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;917    				//}
;;;918    				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
0000fa  eb070209          ADD      r2,r7,r9
0000fe  b291              UXTH     r1,r2
000100  eb060208          ADD      r2,r6,r8
000104  b290              UXTH     r0,r2
000106  9a06              LDR      r2,[sp,#0x18]
000108  f7fffffe          BL       LCD_PutPixel
                  |L10.268|
00010c  1c70              ADDS     r0,r6,#1              ;882
00010e  b206              SXTH     r6,r0                 ;882
                  |L10.272|
000110  980a              LDR      r0,[sp,#0x28]         ;882
000112  4286              CMP      r6,r0                 ;882
000114  db81              BLT      |L10.26|
000116  1e78              SUBS     r0,r7,#1              ;880
000118  b207              SXTH     r7,r0                 ;880
                  |L10.282|
00011a  2f00              CMP      r7,#0                 ;880
00011c  f6bfaf7b          BGE      |L10.22|
;;;919    			}
;;;920    		}
;;;921    	}
;;;922    }
000120  b00b              ADD      sp,sp,#0x2c
000122  e8bd8ff0          POP      {r4-r11,pc}
;;;923    
                          ENDP


                          AREA ||i.LCD_DrawButton||, CODE, READONLY, ALIGN=1

                  LCD_DrawButton PROC
;;;1116   */
;;;1117   void LCD_DrawButton(BUTTON_T *_pBtn)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1118   {
000004  4604              MOV      r4,r0
;;;1119   #if 1
;;;1120   		uint16_t len, fwidth, x, y;
;;;1121   
;;;1122   		if (_pBtn->Focus == 1)
000006  7d20              LDRB     r0,[r4,#0x14]
000008  2801              CMP      r0,#1
00000a  d15f              BNE      |L11.204|
;;;1123   		{
;;;1124   			/* 仿XP风格，平面编辑框 */
;;;1125   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
00000c  2010              MOVS     r0,#0x10
00000e  9000              STR      r0,[sp,#0]
000010  8923              LDRH     r3,[r4,#8]
000012  88e2              LDRH     r2,[r4,#6]
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  f7fffffe          BL       LCD_DrawRect
;;;1126   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
00001c  f64f70ff          MOV      r0,#0xffff
000020  9000              STR      r0,[sp,#0]
000022  f8b4c008          LDRH     r12,[r4,#8]
000026  f1ac0c02          SUB      r12,r12,#2
00002a  fa1ff38c          UXTH     r3,r12
00002e  f8b4c006          LDRH     r12,[r4,#6]
000032  f1ac0c02          SUB      r12,r12,#2
000036  fa1ff28c          UXTH     r2,r12
00003a  f8b4c004          LDRH     r12,[r4,#4]
00003e  f10c0c01          ADD      r12,r12,#1
000042  fa1ff18c          UXTH     r1,r12
000046  f8b4c002          LDRH     r12,[r4,#2]
00004a  f10c0c01          ADD      r12,r12,#1
00004e  fa1ff08c          UXTH     r0,r12
000052  f7fffffe          BL       LCD_DrawRect
;;;1127   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000056  f24940b2          MOV      r0,#0x94b2
00005a  9000              STR      r0,[sp,#0]
00005c  f8b4c008          LDRH     r12,[r4,#8]
000060  f1ac0c04          SUB      r12,r12,#4
000064  fa1ff38c          UXTH     r3,r12
000068  f8b4c006          LDRH     r12,[r4,#6]
00006c  f1ac0c04          SUB      r12,r12,#4
000070  fa1ff28c          UXTH     r2,r12
000074  f8b4c004          LDRH     r12,[r4,#4]
000078  f10c0c02          ADD      r12,r12,#2
00007c  fa1ff18c          UXTH     r1,r12
000080  f8b4c002          LDRH     r12,[r4,#2]
000084  f10c0c02          ADD      r12,r12,#2
000088  fa1ff08c          UXTH     r0,r12
00008c  f7fffffe          BL       LCD_DrawRect
;;;1128   
;;;1129   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);	/* 选中后的底色 */
000090  f64770ff          MOV      r0,#0x7fff
000094  9000              STR      r0,[sp,#0]
000096  f8b4c008          LDRH     r12,[r4,#8]
00009a  f1ac0c06          SUB      r12,r12,#6
00009e  fa1ff38c          UXTH     r3,r12
0000a2  f8b4c006          LDRH     r12,[r4,#6]
0000a6  f1ac0c06          SUB      r12,r12,#6
0000aa  fa1ff28c          UXTH     r2,r12
0000ae  f8b4c004          LDRH     r12,[r4,#4]
0000b2  f10c0c03          ADD      r12,r12,#3
0000b6  fa1ff18c          UXTH     r1,r12
0000ba  f8b4c002          LDRH     r12,[r4,#2]
0000be  f10c0c03          ADD      r12,r12,#3
0000c2  fa1ff08c          UXTH     r0,r12
0000c6  f7fffffe          BL       LCD_Fill_Rect
0000ca  e05e              B        |L11.394|
                  |L11.204|
;;;1130   		}
;;;1131   		else
;;;1132   		{
;;;1133   			/* 仿XP风格，平面编辑框 */
;;;1134   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
0000cc  2010              MOVS     r0,#0x10
0000ce  9000              STR      r0,[sp,#0]
0000d0  8923              LDRH     r3,[r4,#8]
0000d2  88e2              LDRH     r2,[r4,#6]
0000d4  88a1              LDRH     r1,[r4,#4]
0000d6  8860              LDRH     r0,[r4,#2]
0000d8  f7fffffe          BL       LCD_DrawRect
;;;1135   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
0000dc  f64f70ff          MOV      r0,#0xffff
0000e0  9000              STR      r0,[sp,#0]
0000e2  f8b4c008          LDRH     r12,[r4,#8]
0000e6  f1ac0c02          SUB      r12,r12,#2
0000ea  fa1ff38c          UXTH     r3,r12
0000ee  f8b4c006          LDRH     r12,[r4,#6]
0000f2  f1ac0c02          SUB      r12,r12,#2
0000f6  fa1ff28c          UXTH     r2,r12
0000fa  f8b4c004          LDRH     r12,[r4,#4]
0000fe  f10c0c01          ADD      r12,r12,#1
000102  fa1ff18c          UXTH     r1,r12
000106  f8b4c002          LDRH     r12,[r4,#2]
00010a  f10c0c01          ADD      r12,r12,#1
00010e  fa1ff08c          UXTH     r0,r12
000112  f7fffffe          BL       LCD_DrawRect
;;;1136   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000116  f24940b2          MOV      r0,#0x94b2
00011a  9000              STR      r0,[sp,#0]
00011c  f8b4c008          LDRH     r12,[r4,#8]
000120  f1ac0c04          SUB      r12,r12,#4
000124  fa1ff38c          UXTH     r3,r12
000128  f8b4c006          LDRH     r12,[r4,#6]
00012c  f1ac0c04          SUB      r12,r12,#4
000130  fa1ff28c          UXTH     r2,r12
000134  f8b4c004          LDRH     r12,[r4,#4]
000138  f10c0c02          ADD      r12,r12,#2
00013c  fa1ff18c          UXTH     r1,r12
000140  f8b4c002          LDRH     r12,[r4,#2]
000144  f10c0c02          ADD      r12,r12,#2
000148  fa1ff08c          UXTH     r0,r12
00014c  f7fffffe          BL       LCD_DrawRect
;;;1137   
;;;1138   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);		/* 未选中的底色 */
000150  f64c6059          MOV      r0,#0xce59
000154  9000              STR      r0,[sp,#0]
000156  f8b4c008          LDRH     r12,[r4,#8]
00015a  f1ac0c06          SUB      r12,r12,#6
00015e  fa1ff38c          UXTH     r3,r12
000162  f8b4c006          LDRH     r12,[r4,#6]
000166  f1ac0c06          SUB      r12,r12,#6
00016a  fa1ff28c          UXTH     r2,r12
00016e  f8b4c004          LDRH     r12,[r4,#4]
000172  f10c0c03          ADD      r12,r12,#3
000176  fa1ff18c          UXTH     r1,r12
00017a  f8b4c002          LDRH     r12,[r4,#2]
00017e  f10c0c03          ADD      r12,r12,#3
000182  fa1ff08c          UXTH     r0,r12
000186  f7fffffe          BL       LCD_Fill_Rect
                  |L11.394|
;;;1139   		}
;;;1140   
;;;1141   		/* 文字居中 */
;;;1142   		len = strlen(_pBtn->pCaption);
00018a  6920              LDR      r0,[r4,#0x10]
00018c  f7fffffe          BL       strlen
000190  b286              UXTH     r6,r0
;;;1143   
;;;1144   		if (_pBtn->Font->FontCode == FC_ST_16)
000192  68e0              LDR      r0,[r4,#0xc]
000194  8800              LDRH     r0,[r0,#0]
000196  b908              CBNZ     r0,|L11.412|
;;;1145   		{
;;;1146   			fwidth = 8;		/* 字体宽度 */
000198  2508              MOVS     r5,#8
00019a  e006              B        |L11.426|
                  |L11.412|
;;;1147   		}
;;;1148   		else if (_pBtn->Font->FontCode == FC_ST_12)
00019c  68e0              LDR      r0,[r4,#0xc]
00019e  8800              LDRH     r0,[r0,#0]
0001a0  2801              CMP      r0,#1
0001a2  d101              BNE      |L11.424|
;;;1149   		{
;;;1150   			fwidth = 6;		/* 字体宽度 */
0001a4  2506              MOVS     r5,#6
0001a6  e000              B        |L11.426|
                  |L11.424|
;;;1151   		}
;;;1152   		else
;;;1153   		{
;;;1154   			fwidth = 8;		/* 字体宽度 */
0001a8  2508              MOVS     r5,#8
                  |L11.426|
;;;1155   		}
;;;1156   		x = _pBtn->Left + _pBtn->Width / 2 - (len * fwidth) / 2;
0001aa  8921              LDRH     r1,[r4,#8]
0001ac  eb0172d1          ADD      r2,r1,r1,LSR #31
0001b0  8863              LDRH     r3,[r4,#2]
0001b2  eb030362          ADD      r3,r3,r2,ASR #1
0001b6  fb06f005          MUL      r0,r6,r5
0001ba  eb0072d0          ADD      r2,r0,r0,LSR #31
0001be  eba30262          SUB      r2,r3,r2,ASR #1
0001c2  b297              UXTH     r7,r2
;;;1157   		y = _pBtn->Top + _pBtn->Height / 2 - fwidth;
0001c4  88e0              LDRH     r0,[r4,#6]
0001c6  eb0071d0          ADD      r1,r0,r0,LSR #31
0001ca  88a2              LDRH     r2,[r4,#4]
0001cc  eb020161          ADD      r1,r2,r1,ASR #1
0001d0  1b49              SUBS     r1,r1,r5
0001d2  fa1ff881          UXTH     r8,r1
;;;1158   
;;;1159   		LCD_DispStr(x, y, _pBtn->pCaption, _pBtn->Font);
0001d6  4641              MOV      r1,r8
0001d8  4638              MOV      r0,r7
0001da  e9d43203          LDRD     r3,r2,[r4,#0xc]
0001de  f7fffffe          BL       LCD_DispStr
;;;1160   #else
;;;1161   	if (g_ChipID == IC_8875)
;;;1162   	{
;;;1163   		uint16_t len, x, y;
;;;1164   
;;;1165   		if (_pBtn->Focus == 1)
;;;1166   		{
;;;1167   			/* 仿XP风格，平面编辑框 */
;;;1168   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1169   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1170   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1171   
;;;1172   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);
;;;1173   
;;;1174   			RA8875_SetBackColor(BUTTON_ACTIVE_COLOR);
;;;1175   		}
;;;1176   		else
;;;1177   		{
;;;1178   			/* 仿XP风格，平面编辑框 */
;;;1179   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1180   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1181   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1182   
;;;1183   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);
;;;1184   
;;;1185   			RA8875_SetBackColor(BUTTON_BACK_COLOR);
;;;1186   		}
;;;1187   
;;;1188   		#if 1	/* 按钮文字字体和颜色固定 */
;;;1189   			if (strcmp(_pBtn->Caption, "←") == 0)	/* 退格键特殊处理 */
;;;1190   			{
;;;1191   				/* 退格键符号是单像素笔画，太细了不协调，因此特殊处理 */
;;;1192   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1193   				RA8875_SetFrontColor(CL_BLACK);
;;;1194   				RA8875_SetTextZoom(RA_SIZE_X2, RA_SIZE_X2);	/* 放大2倍 */
;;;1195   			}
;;;1196   			else
;;;1197   			{
;;;1198   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1199   				RA8875_SetFrontColor(CL_BLACK);
;;;1200   				RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 放大1倍 */
;;;1201   			}
;;;1202   		#else	/* 按钮文字字体和颜色有应用程序指定 */
;;;1203   			RA8875_SetFont(_pBtn->Font.FontCode, 0, 0);
;;;1204   			RA8875_SetFrontColor(_pBtn->Font.FrontColor);
;;;1205   		#endif
;;;1206   
;;;1207   		/* 文字居中 */
;;;1208   		len = strlen(_pBtn->Caption);
;;;1209   
;;;1210   		/* 此处统计不等宽字符有问题。暂时特殊处理下 */
;;;1211   		if (len != 3)
;;;1212   		{
;;;1213   			x = _pBtn->Left + (_pBtn->Width - len * 16) / 2;
;;;1214   		}
;;;1215   		else
;;;1216   		{
;;;1217   			x = _pBtn->Left + (_pBtn->Width - len * 20) / 2;
;;;1218   		}
;;;1219   
;;;1220   		/* 对特殊字符特殊处理 */
;;;1221   		if ((len == 1) && (_pBtn->Caption[0] == '.'))
;;;1222   		{
;;;1223   			y = _pBtn->Top + 3;
;;;1224   			x += 3;
;;;1225   		}
;;;1226   		else
;;;1227   		{
;;;1228   			y = _pBtn->Top + 3;
;;;1229   		}
;;;1230   
;;;1231   		RA8875_DispStr(x, y, _pBtn->Caption);
;;;1232   
;;;1233   		RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 还原放大1倍 */
;;;1234   	}
;;;1235   #endif
;;;1236   }
0001e2  e8bd83f8          POP      {r3-r9,pc}
;;;1237   
                          ENDP


                          AREA ||i.LCD_DrawCheckBox||, CODE, READONLY, ALIGN=2

                  LCD_DrawCheckBox PROC
;;;983    */
;;;984    void LCD_DrawCheckBox(CHECK_T *_pCheckBox)
000000  b57c              PUSH     {r2-r6,lr}
;;;985    {
000002  4604              MOV      r4,r0
;;;986    #if 1
;;;987    	uint16_t x, y;
;;;988    
;;;989    	/* 目前只做了16点阵汉字的大小 */
;;;990    
;;;991    	/* 绘制外框 */
;;;992    	x = _pCheckBox->Left;
000004  8865              LDRH     r5,[r4,#2]
;;;993    	LCD_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  88a1              LDRH     r1,[r4,#4]
00000c  2318              MOVS     r3,#0x18
00000e  461a              MOV      r2,r3
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       LCD_DrawRect
;;;994    	LCD_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
000016  2010              MOVS     r0,#0x10
000018  9000              STR      r0,[sp,#0]
00001a  88a2              LDRH     r2,[r4,#4]
00001c  1c52              ADDS     r2,r2,#1
00001e  b291              UXTH     r1,r2
000020  1c6a              ADDS     r2,r5,#1
000022  b290              UXTH     r0,r2
000024  2316              MOVS     r3,#0x16
000026  461a              MOV      r2,r3
000028  f7fffffe          BL       LCD_DrawRect
;;;995    	LCD_Fill_Rect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
00002c  f64c6059          MOV      r0,#0xce59
000030  9000              STR      r0,[sp,#0]
000032  88a2              LDRH     r2,[r4,#4]
000034  1c92              ADDS     r2,r2,#2
000036  b291              UXTH     r1,r2
000038  1caa              ADDS     r2,r5,#2
00003a  b290              UXTH     r0,r2
00003c  2314              MOVS     r3,#0x14
00003e  461a              MOV      r2,r3
000040  f7fffffe          BL       LCD_Fill_Rect
;;;996    
;;;997    	/* 绘制文本标签 */
;;;998    	x = _pCheckBox->Left + CHECK_BOX_W + 2;
000044  8860              LDRH     r0,[r4,#2]
000046  301a              ADDS     r0,r0,#0x1a
000048  b285              UXTH     r5,r0
;;;999    	y = _pCheckBox->Top + CHECK_BOX_H / 2 - 8;
00004a  88a0              LDRH     r0,[r4,#4]
00004c  1d00              ADDS     r0,r0,#4
00004e  b286              UXTH     r6,r0
;;;1000   	LCD_DispStr(x, y, _pCheckBox->pCaption, _pCheckBox->Font);
000050  4631              MOV      r1,r6
000052  4628              MOV      r0,r5
000054  e9d43203          LDRD     r3,r2,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
;;;1001   
;;;1002   	if (_pCheckBox->Checked)
00005c  7d20              LDRB     r0,[r4,#0x14]
00005e  b1c0              CBZ      r0,|L12.146|
;;;1003   	{
;;;1004   		FONT_T font;
;;;1005   
;;;1006   	    font.FontCode = FC_ST_16;
000060  2000              MOVS     r0,#0
000062  f8ad0000          STRH     r0,[sp,#0]
;;;1007   		font.BackColor = CL_MASK;
000066  f6491099          MOV      r0,#0x9999
00006a  f8ad0004          STRH     r0,[sp,#4]
;;;1008   		font.FrontColor = CHECK_BOX_CHECKED_COLOR;	/* 钩的颜色 */
00006e  f44f4078          MOV      r0,#0xf800
000072  f8ad0002          STRH     r0,[sp,#2]
;;;1009   		font.Space = 0;
000076  2000              MOVS     r0,#0
000078  f8ad0006          STRH     r0,[sp,#6]
;;;1010   		x = _pCheckBox->Left;
00007c  8865              LDRH     r5,[r4,#2]
;;;1011   		LCD_DispStr(x + 3, _pCheckBox->Top + 3, "√", &font);
00007e  88a2              LDRH     r2,[r4,#4]
000080  1cd2              ADDS     r2,r2,#3
000082  b291              UXTH     r1,r2
000084  1cea              ADDS     r2,r5,#3
000086  b290              UXTH     r0,r2
000088  466b              MOV      r3,sp
00008a  a202              ADR      r2,|L12.148|
00008c  f7fffffe          BL       LCD_DispStr
;;;1012   	}
000090  bf00              NOP      
                  |L12.146|
;;;1013   #else
;;;1014   	if (g_ChipID == IC_8875)
;;;1015   	{
;;;1016   		uint16_t x;
;;;1017   
;;;1018   		RA8875_SetFont(_pCheckBox->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1019   
;;;1020   		/* 绘制标签 */
;;;1021   		//RA8875_SetBackColor(_pCheckBox->Font.BackColor);
;;;1022   		RA8875_SetBackColor(WIN_BODY_COLOR);
;;;1023   		RA8875_SetFrontColor(_pCheckBox->Font.FrontColor);
;;;1024   		RA8875_DispStr(_pCheckBox->Left, _pCheckBox->Top, _pCheckBox->Caption);
;;;1025   
;;;1026   		/* 绘制外框 */
;;;1027   		x = _pCheckBox->Left + _pCheckBox->Width - CHECK_BOX_W;
;;;1028   		RA8875_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
;;;1029   		RA8875_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
;;;1030   		RA8875_FillRect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
;;;1031   
;;;1032   		if (_pCheckBox->Checked)
;;;1033   		{
;;;1034   			RA8875_SetBackColor(CHECK_BOX_BACK_COLOR);
;;;1035   			RA8875_SetFrontColor(CL_RED);
;;;1036   			RA8875_DispStr(x + 3, _pCheckBox->Top + 3, "√");
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   
;;;1042   	}
;;;1043   #endif
;;;1044   
;;;1045   }
000092  bd7c              POP      {r2-r6,pc}
;;;1046   
                          ENDP

                  |L12.148|
000094  a1cc00            DCB      161,204,0
000097  00                DCB      0

                          AREA ||i.LCD_DrawCircle||, CODE, READONLY, ALIGN=2

                  LCD_DrawCircle PROC
;;;538    */
;;;539    void LCD_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;540    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;541    	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L13.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L13.34|
;;;542    	{
;;;543    		RA8875_DrawCircle(_usX, _usY, _usRadius, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawCircle
000020  e005              B        |L13.46|
                  |L13.34|
;;;544    	}
;;;545    	else
;;;546    	{
;;;547    		SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawCircle
                  |L13.46|
;;;548    	}
;;;549    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;550    
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawEdit||, CODE, READONLY, ALIGN=1

                  LCD_DrawEdit PROC
;;;1054   */
;;;1055   void LCD_DrawEdit(EDIT_T *_pEdit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1056   {
000004  4604              MOV      r4,r0
;;;1057   #if 1
;;;1058   	uint16_t len, x, y;
;;;1059   	uint8_t width;
;;;1060   
;;;1061   	/* 仿XP风格，平面编辑框 */
;;;1062   	LCD_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  8923              LDRH     r3,[r4,#8]
00000c  88e2              LDRH     r2,[r4,#6]
00000e  88a1              LDRH     r1,[r4,#4]
000010  8860              LDRH     r0,[r4,#2]
000012  f7fffffe          BL       LCD_DrawRect
;;;1063   	LCD_Fill_Rect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
000016  f64f70ff          MOV      r0,#0xffff
00001a  9000              STR      r0,[sp,#0]
00001c  f8b4c008          LDRH     r12,[r4,#8]
000020  f1ac0c02          SUB      r12,r12,#2
000024  fa1ff38c          UXTH     r3,r12
000028  f8b4c006          LDRH     r12,[r4,#6]
00002c  f1ac0c02          SUB      r12,r12,#2
000030  fa1ff28c          UXTH     r2,r12
000034  f8b4c004          LDRH     r12,[r4,#4]
000038  f10c0c01          ADD      r12,r12,#1
00003c  fa1ff18c          UXTH     r1,r12
000040  f8b4c002          LDRH     r12,[r4,#2]
000044  f10c0c01          ADD      r12,r12,#1
000048  fa1ff08c          UXTH     r0,r12
00004c  f7fffffe          BL       LCD_Fill_Rect
;;;1064   
;;;1065   	/* 文字居中 */
;;;1066   	if (_pEdit->Font->FontCode == FC_ST_12)
000050  68e0              LDR      r0,[r4,#0xc]
000052  8800              LDRH     r0,[r0,#0]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L14.92|
;;;1067   	{
;;;1068   		width = 6;
000058  2506              MOVS     r5,#6
00005a  e000              B        |L14.94|
                  |L14.92|
;;;1069   	}
;;;1070   	else
;;;1071   	{
;;;1072   		width = 8;
00005c  2508              MOVS     r5,#8
                  |L14.94|
;;;1073   	}
;;;1074   	len = strlen(_pEdit->pCaption);
00005e  6920              LDR      r0,[r4,#0x10]
000060  f7fffffe          BL       strlen
000064  b286              UXTH     r6,r0
;;;1075   	x = _pEdit->Left +  (_pEdit->Width - len * width) / 2;
000066  8921              LDRH     r1,[r4,#8]
000068  fb061015          MLS      r0,r6,r5,r1
00006c  eb0071d0          ADD      r1,r0,r0,LSR #31
000070  8862              LDRH     r2,[r4,#2]
000072  eb020161          ADD      r1,r2,r1,ASR #1
000076  b28f              UXTH     r7,r1
;;;1076   	y = _pEdit->Top + _pEdit->Height / 2 - width;
000078  88e0              LDRH     r0,[r4,#6]
00007a  eb0071d0          ADD      r1,r0,r0,LSR #31
00007e  88a2              LDRH     r2,[r4,#4]
000080  eb020161          ADD      r1,r2,r1,ASR #1
000084  1b49              SUBS     r1,r1,r5
000086  fa1ff881          UXTH     r8,r1
;;;1077   
;;;1078   	LCD_DispStr(x, y, _pEdit->pCaption, _pEdit->Font);
00008a  4641              MOV      r1,r8
00008c  4638              MOV      r0,r7
00008e  e9d43203          LDRD     r3,r2,[r4,#0xc]
000092  f7fffffe          BL       LCD_DispStr
;;;1079   #else
;;;1080   	if (g_ChipID == IC_8875)
;;;1081   	{
;;;1082   		uint16_t len, x;
;;;1083   
;;;1084   		/* 仿XP风格，平面编辑框 */
;;;1085   		RA8875_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
;;;1086   		RA8875_FillRect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
;;;1087   
;;;1088   		RA8875_SetFont(_pEdit->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1089   		RA8875_SetFrontColor(_pEdit->Font.FrontColor);
;;;1090   		RA8875_SetBackColor(EDIT_BACK_COLOR);
;;;1091   
;;;1092   		/* 文字居中 */
;;;1093   		len = strlen(_pEdit->Caption);
;;;1094   		x = (_pEdit->Width - len * 16) / 2;
;;;1095   
;;;1096   		RA8875_DispStr(_pEdit->Left + x, _pEdit->Top + 3, _pEdit->Caption);
;;;1097   	}
;;;1098   	else
;;;1099   	{
;;;1100   		//SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;1101   	}
;;;1102   #endif
;;;1103   }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;1104   
                          ENDP


                          AREA ||i.LCD_DrawGroupBox||, CODE, READONLY, ALIGN=1

                  LCD_DrawGroupBox PROC
;;;1245   */
;;;1246   void LCD_DrawGroupBox(GROUP_T *_pBox)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1247   {
000002  4604              MOV      r4,r0
;;;1248   	uint16_t x, y;
;;;1249   
;;;1250   	/* 画阴影线 */
;;;1251   	LCD_DrawRect(_pBox->Left + 1, _pBox->Top + 5, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER2);
000004  f64f70ff          MOV      r0,#0xffff
000008  9000              STR      r0,[sp,#0]
00000a  8927              LDRH     r7,[r4,#8]
00000c  1e7f              SUBS     r7,r7,#1
00000e  b2bb              UXTH     r3,r7
000010  88e2              LDRH     r2,[r4,#6]
000012  88a7              LDRH     r7,[r4,#4]
000014  1d7f              ADDS     r7,r7,#5
000016  b2b9              UXTH     r1,r7
000018  8867              LDRH     r7,[r4,#2]
00001a  1c7f              ADDS     r7,r7,#1
00001c  b2b8              UXTH     r0,r7
00001e  f7fffffe          BL       LCD_DrawRect
;;;1252   
;;;1253   	/* 画主框线 */
;;;1254   	LCD_DrawRect(_pBox->Left, _pBox->Top + 4, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER1);
000022  f64a5053          MOV      r0,#0xad53
000026  9000              STR      r0,[sp,#0]
000028  8927              LDRH     r7,[r4,#8]
00002a  1e7f              SUBS     r7,r7,#1
00002c  b2bb              UXTH     r3,r7
00002e  88e2              LDRH     r2,[r4,#6]
000030  88a7              LDRH     r7,[r4,#4]
000032  1d3f              ADDS     r7,r7,#4
000034  b2b9              UXTH     r1,r7
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       LCD_DrawRect
;;;1255   
;;;1256   	/* 显示分组框标题（文字在左上角） */
;;;1257   	x = _pBox->Left + 9;
00003c  8860              LDRH     r0,[r4,#2]
00003e  3009              ADDS     r0,r0,#9
000040  b285              UXTH     r5,r0
;;;1258   	y = _pBox->Top;
000042  88a6              LDRH     r6,[r4,#4]
;;;1259   	LCD_DispStr(x, y, _pBox->pCaption, _pBox->Font);
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  e9d43203          LDRD     r3,r2,[r4,#0xc]
00004c  f7fffffe          BL       LCD_DispStr
;;;1260   }
000050  bdf8              POP      {r3-r7,pc}
;;;1261   
                          ENDP


                          AREA ||i.LCD_DrawHColorLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawHColorLine PROC
;;;1341   */
;;;1342   void LCD_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1343   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1344   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L16.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L16.34|
;;;1345   	{
;;;1346   		RA8875_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHColorLine
000020  e005              B        |L16.46|
                  |L16.34|
;;;1347   	}
;;;1348   	else
;;;1349   	{
;;;1350   		SPFD5420_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHColorLine
                  |L16.46|
;;;1351   	}
;;;1352   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1353   
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawIcon||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon PROC
;;;643    */
;;;644    void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;645    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;646    	const uint16_t *p;
;;;647    	uint16_t usNewRGB;
;;;648    	uint16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;649    
;;;650    	p = _tIcon->pBmp;
000008  f8d4a00c          LDR      r10,[r4,#0xc]
;;;651    	for (y = 0; y < _tIcon->Height; y++)
00000c  2600              MOVS     r6,#0
00000e  e0ad              B        |L17.364|
                  |L17.16|
;;;652    	{
;;;653    		for (x = 0; x < _tIcon->Width; x++)
000010  2500              MOVS     r5,#0
000012  e0a5              B        |L17.352|
                  |L17.20|
;;;654    		{
;;;655    			usNewRGB = *p++;	/* 读取图标的颜色值后指针加1 */
000014  f83a8b02          LDRH     r8,[r10],#2
;;;656    			/* 将图标的4个直角切割为弧角，弧角外是背景图标 */
;;;657    			if ((y == 0 && (x < 6 || x > _tIcon->Width - 7)) ||
000018  b92e              CBNZ     r6,|L17.38|
00001a  2d06              CMP      r5,#6
                  |L17.28|
00001c  db77              BLT      |L17.270|
00001e  8920              LDRH     r0,[r4,#8]
000020  1fc0              SUBS     r0,r0,#7
000022  42a8              CMP      r0,r5
000024  dbfa              BLT      |L17.28|
                  |L17.38|
;;;658    				(y == 1 && (x < 4 || x > _tIcon->Width - 5)) ||
000026  2e01              CMP      r6,#1
000028  d105              BNE      |L17.54|
00002a  2d04              CMP      r5,#4
00002c  dbf6              BLT      |L17.28|
00002e  8920              LDRH     r0,[r4,#8]
000030  1f40              SUBS     r0,r0,#5
000032  42a8              CMP      r0,r5
000034  dbf2              BLT      |L17.28|
                  |L17.54|
;;;659    				(y == 2 && (x < 3 || x > _tIcon->Width - 4)) ||
000036  2e02              CMP      r6,#2
000038  d105              BNE      |L17.70|
00003a  2d03              CMP      r5,#3
00003c  dbee              BLT      |L17.28|
00003e  8920              LDRH     r0,[r4,#8]
000040  1f00              SUBS     r0,r0,#4
000042  42a8              CMP      r0,r5
000044  dbea              BLT      |L17.28|
                  |L17.70|
;;;660    				(y == 3 && (x < 2 || x > _tIcon->Width - 3)) ||
000046  2e03              CMP      r6,#3
000048  d105              BNE      |L17.86|
00004a  2d02              CMP      r5,#2
00004c  dbe6              BLT      |L17.28|
00004e  8920              LDRH     r0,[r4,#8]
000050  1ec0              SUBS     r0,r0,#3
000052  42a8              CMP      r0,r5
000054  dbe2              BLT      |L17.28|
                  |L17.86|
;;;661    				(y == 4 && (x < 1 || x > _tIcon->Width - 2)) ||
000056  2e04              CMP      r6,#4
000058  d105              BNE      |L17.102|
00005a  2d01              CMP      r5,#1
00005c  db7e              BLT      |L17.348|
00005e  8920              LDRH     r0,[r4,#8]
000060  1e80              SUBS     r0,r0,#2
000062  42a8              CMP      r0,r5
000064  db7a              BLT      |L17.348|
                  |L17.102|
;;;662    				(y == 5 && (x < 1 || x > _tIcon->Width - 2))	||
000066  2e05              CMP      r6,#5
000068  d105              BNE      |L17.118|
00006a  2d01              CMP      r5,#1
00006c  db76              BLT      |L17.348|
00006e  8920              LDRH     r0,[r4,#8]
000070  1e80              SUBS     r0,r0,#2
000072  42a8              CMP      r0,r5
000074  db72              BLT      |L17.348|
                  |L17.118|
;;;663    
;;;664    				(y == _tIcon->Height - 1 && (x < 6 || x > _tIcon->Width - 7)) ||
000076  88e0              LDRH     r0,[r4,#6]
000078  1e40              SUBS     r0,r0,#1
00007a  42b0              CMP      r0,r6
00007c  d105              BNE      |L17.138|
00007e  2d06              CMP      r5,#6
000080  db6c              BLT      |L17.348|
000082  8920              LDRH     r0,[r4,#8]
000084  1fc0              SUBS     r0,r0,#7
000086  42a8              CMP      r0,r5
000088  db68              BLT      |L17.348|
                  |L17.138|
;;;665    				(y == _tIcon->Height - 2 && (x < 4 || x > _tIcon->Width - 5)) ||
00008a  88e0              LDRH     r0,[r4,#6]
00008c  1e80              SUBS     r0,r0,#2
00008e  42b0              CMP      r0,r6
000090  d105              BNE      |L17.158|
000092  2d04              CMP      r5,#4
000094  db62              BLT      |L17.348|
000096  8920              LDRH     r0,[r4,#8]
000098  1f40              SUBS     r0,r0,#5
00009a  42a8              CMP      r0,r5
00009c  db5e              BLT      |L17.348|
                  |L17.158|
;;;666    				(y == _tIcon->Height - 3 && (x < 3 || x > _tIcon->Width - 4)) ||
00009e  88e0              LDRH     r0,[r4,#6]
0000a0  1ec0              SUBS     r0,r0,#3
0000a2  42b0              CMP      r0,r6
0000a4  d105              BNE      |L17.178|
0000a6  2d03              CMP      r5,#3
0000a8  db58              BLT      |L17.348|
0000aa  8920              LDRH     r0,[r4,#8]
0000ac  1f00              SUBS     r0,r0,#4
0000ae  42a8              CMP      r0,r5
0000b0  db54              BLT      |L17.348|
                  |L17.178|
;;;667    				(y == _tIcon->Height - 4 && (x < 2 || x > _tIcon->Width - 3)) ||
0000b2  88e0              LDRH     r0,[r4,#6]
0000b4  1f00              SUBS     r0,r0,#4
0000b6  42b0              CMP      r0,r6
0000b8  d105              BNE      |L17.198|
0000ba  2d02              CMP      r5,#2
0000bc  db4e              BLT      |L17.348|
0000be  8920              LDRH     r0,[r4,#8]
0000c0  1ec0              SUBS     r0,r0,#3
0000c2  42a8              CMP      r0,r5
0000c4  db4a              BLT      |L17.348|
                  |L17.198|
;;;668    				(y == _tIcon->Height - 5 && (x < 1 || x > _tIcon->Width - 2)) ||
0000c6  88e0              LDRH     r0,[r4,#6]
0000c8  1f40              SUBS     r0,r0,#5
0000ca  42b0              CMP      r0,r6
0000cc  d105              BNE      |L17.218|
0000ce  2d01              CMP      r5,#1
0000d0  db44              BLT      |L17.348|
0000d2  8920              LDRH     r0,[r4,#8]
0000d4  1e80              SUBS     r0,r0,#2
0000d6  42a8              CMP      r0,r5
0000d8  db40              BLT      |L17.348|
                  |L17.218|
;;;669    				(y == _tIcon->Height - 6 && (x < 1 || x > _tIcon->Width - 2))
0000da  88e0              LDRH     r0,[r4,#6]
0000dc  1f80              SUBS     r0,r0,#6
0000de  42b0              CMP      r0,r6
0000e0  d105              BNE      |L17.238|
0000e2  2d01              CMP      r5,#1
0000e4  db3a              BLT      |L17.348|
0000e6  8920              LDRH     r0,[r4,#8]
0000e8  1e80              SUBS     r0,r0,#2
0000ea  42a8              CMP      r0,r5
0000ec  db36              BLT      |L17.348|
                  |L17.238|
;;;670    				)
;;;671    			{
;;;672    				;
;;;673    			}
;;;674    			else
;;;675    			{
;;;676    				if (_ucFocusMode != 0)	/* 1表示选中的图标 */
0000ee  9802              LDR      r0,[sp,#8]
0000f0  b358              CBZ      r0,|L17.330|
;;;677    				{
;;;678    					/* 降低原始像素的亮度，实现图标被激活选中的效果 */
;;;679    					uint16_t R,G,B;
;;;680    					uint16_t bright = 15;
0000f2  200f              MOVS     r0,#0xf
;;;681    
;;;682    					/* rrrr rggg gggb bbbb */
;;;683    					R = (usNewRGB & 0xF800) >> 11;
0000f4  ea4f21d8          LSR      r1,r8,#11
;;;684    					G = (usNewRGB & 0x07E0) >> 5;
0000f8  f3c81245          UBFX     r2,r8,#5,#6
;;;685    					B =  usNewRGB & 0x001F;
0000fc  f008031f          AND      r3,r8,#0x1f
;;;686    					if (R > bright)
000100  4281              CMP      r1,r0
000102  dd05              BLE      |L17.272|
;;;687    					{
;;;688    						R -= bright;
000104  eba10c00          SUB      r12,r1,r0
000108  fa1ff18c          UXTH     r1,r12
00010c  e001              B        |L17.274|
                  |L17.270|
00010e  e025              B        |L17.348|
                  |L17.272|
;;;689    					}
;;;690    					else
;;;691    					{
;;;692    						R = 0;
000110  2100              MOVS     r1,#0
                  |L17.274|
;;;693    					}
;;;694    					if (G > 2 * bright)
000112  ea4f0c40          LSL      r12,r0,#1
000116  4594              CMP      r12,r2
000118  da06              BGE      |L17.296|
;;;695    					{
;;;696    						G -= 2 * bright;
00011a  f04f0c02          MOV      r12,#2
00011e  fb0c2c10          MLS      r12,r12,r0,r2
000122  fa1ff28c          UXTH     r2,r12
000126  e000              B        |L17.298|
                  |L17.296|
;;;697    					}
;;;698    					else
;;;699    					{
;;;700    						G = 0;
000128  2200              MOVS     r2,#0
                  |L17.298|
;;;701    					}
;;;702    					if (B > bright)
00012a  4283              CMP      r3,r0
00012c  dd04              BLE      |L17.312|
;;;703    					{
;;;704    						B -= bright;
00012e  eba30c00          SUB      r12,r3,r0
000132  fa1ff38c          UXTH     r3,r12
000136  e000              B        |L17.314|
                  |L17.312|
;;;705    					}
;;;706    					else
;;;707    					{
;;;708    						B = 0;
000138  2300              MOVS     r3,#0
                  |L17.314|
;;;709    					}
;;;710    					usNewRGB = (R << 11) + (G << 5) + B;
00013a  ea4f2cc1          LSL      r12,r1,#11
00013e  eb0c1c42          ADD      r12,r12,r2,LSL #5
000142  449c              ADD      r12,r12,r3
000144  fa1ff88c          UXTH     r8,r12
;;;711    				}
000148  bf00              NOP      
                  |L17.330|
;;;712    
;;;713    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
00014a  88a2              LDRH     r2,[r4,#4]
00014c  4432              ADD      r2,r2,r6
00014e  b291              UXTH     r1,r2
000150  8862              LDRH     r2,[r4,#2]
000152  442a              ADD      r2,r2,r5
000154  b290              UXTH     r0,r2
000156  4642              MOV      r2,r8
000158  f7fffffe          BL       LCD_PutPixel
                  |L17.348|
00015c  1c68              ADDS     r0,r5,#1              ;653
00015e  b285              UXTH     r5,r0                 ;653
                  |L17.352|
000160  8920              LDRH     r0,[r4,#8]            ;653
000162  42a8              CMP      r0,r5                 ;653
000164  f73faf56          BGT      |L17.20|
000168  1c70              ADDS     r0,r6,#1              ;651
00016a  b286              UXTH     r6,r0                 ;651
                  |L17.364|
00016c  88e0              LDRH     r0,[r4,#6]            ;651
00016e  42b0              CMP      r0,r6                 ;651
000170  f73faf4e          BGT      |L17.16|
;;;714    			}
;;;715    		}
;;;716    	}
;;;717    
;;;718    	/* 绘制图标下的文字 */
;;;719    	{
;;;720    		uint16_t len;
;;;721    		uint16_t width;
;;;722    
;;;723    		len = strlen(_tIcon->Text);
000174  f1040010          ADD      r0,r4,#0x10
000178  f7fffffe          BL       strlen
00017c  fa1ffb80          UXTH     r11,r0
;;;724    
;;;725    		if  (len == 0)
000180  f1bb0f00          CMP      r11,#0
000184  d101              BNE      |L17.394|
                  |L17.390|
;;;726    		{
;;;727    			return;	/* 如果图标文本长度为0，则不显示 */
;;;728    		}
;;;729    
;;;730    		/* 计算文本的总宽度 */
;;;731    		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;732    		{
;;;733    			width = 6 * (len + _tFont->Space);
;;;734    		}
;;;735    		else	/* FC_ST_16 */
;;;736    		{
;;;737    			width = 8 * (len + _tFont->Space);
;;;738    		}
;;;739    
;;;740    
;;;741    		/* 水平居中 */
;;;742    		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;743    		y = _tIcon->Top + _tIcon->Height + 2;
;;;744    		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;745    	}
;;;746    }
000186  e8bd8ffe          POP      {r1-r11,pc}
                  |L17.394|
00018a  8838              LDRH     r0,[r7,#0]            ;731
00018c  2801              CMP      r0,#1                 ;731
00018e  d107              BNE      |L17.416|
000190  88f8              LDRH     r0,[r7,#6]            ;733
000192  4458              ADD      r0,r0,r11             ;733
000194  eb000040          ADD      r0,r0,r0,LSL #1       ;733
000198  0440              LSLS     r0,r0,#17             ;733
00019a  ea4f4910          LSR      r9,r0,#16             ;733
00019e  e004              B        |L17.426|
                  |L17.416|
0001a0  88f8              LDRH     r0,[r7,#6]            ;737
0001a2  4458              ADD      r0,r0,r11             ;737
0001a4  04c0              LSLS     r0,r0,#19             ;737
0001a6  ea4f4910          LSR      r9,r0,#16             ;737
                  |L17.426|
0001aa  8920              LDRH     r0,[r4,#8]            ;742
0001ac  eb0072d0          ADD      r2,r0,r0,LSR #31      ;742
0001b0  8863              LDRH     r3,[r4,#2]            ;742
0001b2  eb030262          ADD      r2,r3,r2,ASR #1       ;742
0001b6  4649              MOV      r1,r9                 ;742
0001b8  eb0973d1          ADD      r3,r9,r1,LSR #31      ;742
0001bc  eba20263          SUB      r2,r2,r3,ASR #1       ;742
0001c0  b295              UXTH     r5,r2                 ;742
0001c2  88a0              LDRH     r0,[r4,#4]            ;743
0001c4  88e1              LDRH     r1,[r4,#6]            ;743
0001c6  4408              ADD      r0,r0,r1              ;743
0001c8  1c80              ADDS     r0,r0,#2              ;743
0001ca  b286              UXTH     r6,r0                 ;743
0001cc  463b              MOV      r3,r7                 ;744
0001ce  f1040210          ADD      r2,r4,#0x10           ;744
0001d2  4631              MOV      r1,r6                 ;744
0001d4  4628              MOV      r0,r5                 ;744
0001d6  f7fffffe          BL       LCD_DispStr
0001da  bf00              NOP      
0001dc  e7d3              B        |L17.390|
;;;747    
                          ENDP


                          AREA ||i.LCD_DrawIcon32||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon32 PROC
;;;772    */
;;;773    void LCD_DrawIcon32(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;774    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;775    	const uint8_t *p;
;;;776    	uint16_t usOldRGB, usNewRGB;
;;;777    	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;778    	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;779    	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;780    
;;;781    	p = (const uint8_t *)_tIcon->pBmp;
00000a  68e5              LDR      r5,[r4,#0xc]
;;;782    	p += 54;		/* 直接指向图像数据区 */
00000c  3536              ADDS     r5,r5,#0x36
;;;783    
;;;784    	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;785    	for (y = _tIcon->Height - 1; y >= 0; y--)
00000e  88e0              LDRH     r0,[r4,#6]
000010  1e40              SUBS     r0,r0,#1
000012  fa0ff880          SXTH     r8,r0
000016  e099              B        |L18.332|
                  |L18.24|
;;;786    	{
;;;787    		for (x = 0; x < _tIcon->Width; x++)
000018  2700              MOVS     r7,#0
00001a  e08f              B        |L18.316|
                  |L18.28|
;;;788    		{
;;;789    			B1 = *p++;
00001c  f8150b01          LDRB     r0,[r5],#1
000020  9004              STR      r0,[sp,#0x10]
;;;790    			G1 = *p++;
000022  f8150b01          LDRB     r0,[r5],#1
000026  9005              STR      r0,[sp,#0x14]
;;;791    			R1 = *p++;
000028  f8150b01          LDRB     r0,[r5],#1
00002c  9006              STR      r0,[sp,#0x18]
;;;792    			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002e  f8156b01          LDRB     r6,[r5],#1
;;;793    
;;;794    			if (A == 0x00)	/* 需要透明,显示背景 */
000032  2e00              CMP      r6,#0
000034  d01f              BEQ      |L18.118|
;;;795    			{
;;;796    				;	/* 不用刷新背景 */
;;;797    			}
;;;798    			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000036  2eff              CMP      r6,#0xff
000038  d11e              BNE      |L18.120|
;;;799    			{
;;;800    				usNewRGB = RGB(R1, G1, B1);
00003a  9806              LDR      r0,[sp,#0x18]
00003c  10c0              ASRS     r0,r0,#3
00003e  02c1              LSLS     r1,r0,#11
000040  9805              LDR      r0,[sp,#0x14]
000042  1080              ASRS     r0,r0,#2
000044  ea411140          ORR      r1,r1,r0,LSL #5
000048  9804              LDR      r0,[sp,#0x10]
00004a  ea4100e0          ORR      r0,r1,r0,ASR #3
00004e  9007              STR      r0,[sp,#0x1c]
;;;801    				if (_ucFocusMode == 1)
000050  980a              LDR      r0,[sp,#0x28]
000052  2801              CMP      r0,#1
000054  d106              BNE      |L18.100|
;;;802    				{
;;;803    					usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
000056  220a              MOVS     r2,#0xa
000058  f64f71e0          MOV      r1,#0xffe0
00005c  9807              LDR      r0,[sp,#0x1c]
00005e  f7fffffe          BL       Blend565
000062  9007              STR      r0,[sp,#0x1c]
                  |L18.100|
;;;804    				}
;;;805    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000064  88a2              LDRH     r2,[r4,#4]
000066  4442              ADD      r2,r2,r8
000068  b291              UXTH     r1,r2
00006a  8862              LDRH     r2,[r4,#2]
00006c  443a              ADD      r2,r2,r7
00006e  b290              UXTH     r0,r2
000070  9a07              LDR      r2,[sp,#0x1c]
000072  f7fffffe          BL       LCD_PutPixel
                  |L18.118|
000076  e05f              B        |L18.312|
                  |L18.120|
;;;806    			}
;;;807    			else 	/* 半透明 */
;;;808    			{
;;;809    				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;810    				usOldRGB = LCD_GetPixel(x + _tIcon->Left, y + _tIcon->Top);
000078  88a2              LDRH     r2,[r4,#4]
00007a  4442              ADD      r2,r2,r8
00007c  b291              UXTH     r1,r2
00007e  8862              LDRH     r2,[r4,#2]
000080  443a              ADD      r2,r2,r7
000082  b290              UXTH     r0,r2
000084  f7fffffe          BL       LCD_GetPixel
000088  4682              MOV      r10,r0
;;;811    				R0 = RGB565_R(usOldRGB);
00008a  21f8              MOVS     r1,#0xf8
00008c  ea01202a          AND      r0,r1,r10,ASR #8
000090  9003              STR      r0,[sp,#0xc]
;;;812    				G0 = RGB565_G(usOldRGB);
000092  21fc              MOVS     r1,#0xfc
000094  ea0100ea          AND      r0,r1,r10,ASR #3
000098  9002              STR      r0,[sp,#8]
;;;813    				B0 = RGB565_B(usOldRGB);
00009a  21f8              MOVS     r1,#0xf8
00009c  ea0100ca          AND      r0,r1,r10,LSL #3
0000a0  9001              STR      r0,[sp,#4]
;;;814    
;;;815    				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
0000a2  9806              LDR      r0,[sp,#0x18]
0000a4  4370              MULS     r0,r6,r0
0000a6  21ff              MOVS     r1,#0xff
0000a8  fb90f2f1          SDIV     r2,r0,r1
0000ac  f1c601ff          RSB      r1,r6,#0xff
0000b0  9803              LDR      r0,[sp,#0xc]
0000b2  4341              MULS     r1,r0,r1
0000b4  20ff              MOVS     r0,#0xff
0000b6  fb91f0f0          SDIV     r0,r1,r0
0000ba  4410              ADD      r0,r0,r2
0000bc  b2c0              UXTB     r0,r0
0000be  9006              STR      r0,[sp,#0x18]
;;;816    				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000c0  9805              LDR      r0,[sp,#0x14]
0000c2  4370              MULS     r0,r6,r0
0000c4  21ff              MOVS     r1,#0xff
0000c6  fb90f2f1          SDIV     r2,r0,r1
0000ca  f1c601ff          RSB      r1,r6,#0xff
0000ce  9802              LDR      r0,[sp,#8]
0000d0  4341              MULS     r1,r0,r1
0000d2  20ff              MOVS     r0,#0xff
0000d4  fb91f0f0          SDIV     r0,r1,r0
0000d8  4410              ADD      r0,r0,r2
0000da  b2c0              UXTB     r0,r0
0000dc  9005              STR      r0,[sp,#0x14]
;;;817    				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000de  9804              LDR      r0,[sp,#0x10]
0000e0  4370              MULS     r0,r6,r0
0000e2  21ff              MOVS     r1,#0xff
0000e4  fb90f2f1          SDIV     r2,r0,r1
0000e8  f1c601ff          RSB      r1,r6,#0xff
0000ec  9801              LDR      r0,[sp,#4]
0000ee  4341              MULS     r1,r0,r1
0000f0  20ff              MOVS     r0,#0xff
0000f2  fb91f0f0          SDIV     r0,r1,r0
0000f6  4410              ADD      r0,r0,r2
0000f8  b2c0              UXTB     r0,r0
0000fa  9004              STR      r0,[sp,#0x10]
;;;818    				usNewRGB = RGB(R1, G1, B1);
0000fc  9806              LDR      r0,[sp,#0x18]
0000fe  10c0              ASRS     r0,r0,#3
000100  02c1              LSLS     r1,r0,#11
000102  9805              LDR      r0,[sp,#0x14]
000104  1080              ASRS     r0,r0,#2
000106  ea411140          ORR      r1,r1,r0,LSL #5
00010a  9804              LDR      r0,[sp,#0x10]
00010c  ea4100e0          ORR      r0,r1,r0,ASR #3
000110  9007              STR      r0,[sp,#0x1c]
;;;819    				if (_ucFocusMode == 1)
000112  980a              LDR      r0,[sp,#0x28]
000114  2801              CMP      r0,#1
000116  d106              BNE      |L18.294|
;;;820    				{
;;;821    					usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
000118  220a              MOVS     r2,#0xa
00011a  f64f71e0          MOV      r1,#0xffe0
00011e  9807              LDR      r0,[sp,#0x1c]
000120  f7fffffe          BL       Blend565
000124  9007              STR      r0,[sp,#0x1c]
                  |L18.294|
;;;822    				}
;;;823    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000126  88a2              LDRH     r2,[r4,#4]
000128  4442              ADD      r2,r2,r8
00012a  b291              UXTH     r1,r2
00012c  8862              LDRH     r2,[r4,#2]
00012e  443a              ADD      r2,r2,r7
000130  b290              UXTH     r0,r2
000132  9a07              LDR      r2,[sp,#0x1c]
000134  f7fffffe          BL       LCD_PutPixel
                  |L18.312|
000138  1c78              ADDS     r0,r7,#1              ;787
00013a  b207              SXTH     r7,r0                 ;787
                  |L18.316|
00013c  8920              LDRH     r0,[r4,#8]            ;787
00013e  42b8              CMP      r0,r7                 ;787
000140  f73faf6c          BGT      |L18.28|
000144  f1a80001          SUB      r0,r8,#1              ;785
000148  fa0ff880          SXTH     r8,r0                 ;785
                  |L18.332|
00014c  f1b80f00          CMP      r8,#0                 ;785
000150  f6bfaf62          BGE      |L18.24|
;;;824    			}
;;;825    		}
;;;826    	}
;;;827    
;;;828    	/* 绘制图标下的文字 */
;;;829    	{
;;;830    		uint16_t len;
;;;831    		uint16_t width;
;;;832    
;;;833    		len = strlen(_tIcon->Text);
000154  f1040010          ADD      r0,r4,#0x10
000158  f7fffffe          BL       strlen
00015c  b280              UXTH     r0,r0
00015e  9000              STR      r0,[sp,#0]
;;;834    
;;;835    		if  (len == 0)
000160  9800              LDR      r0,[sp,#0]
000162  b910              CBNZ     r0,|L18.362|
                  |L18.356|
;;;836    		{
;;;837    			return;	/* 如果图标文本长度为0，则不显示 */
;;;838    		}
;;;839    
;;;840    		/* 计算文本的总宽度 */
;;;841    		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;842    		{
;;;843    			width = 6 * (len + _tFont->Space);
;;;844    		}
;;;845    		else	/* FC_ST_16 */
;;;846    		{
;;;847    			width = 8 * (len + _tFont->Space);
;;;848    		}
;;;849    
;;;850    
;;;851    		/* 水平居中 */
;;;852    		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;853    		y = _tIcon->Top + _tIcon->Height + 2;
;;;854    		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;855    	}
;;;856    }
000164  b00b              ADD      sp,sp,#0x2c
000166  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.362|
00016a  f8b90000          LDRH     r0,[r9,#0]            ;841
00016e  2801              CMP      r0,#1                 ;841
000170  d109              BNE      |L18.390|
000172  f8b91006          LDRH     r1,[r9,#6]            ;843
000176  9800              LDR      r0,[sp,#0]            ;843
000178  4408              ADD      r0,r0,r1              ;843
00017a  eb000040          ADD      r0,r0,r0,LSL #1       ;843
00017e  0440              LSLS     r0,r0,#17             ;843
000180  ea4f4b10          LSR      r11,r0,#16            ;843
000184  e006              B        |L18.404|
                  |L18.390|
000186  f8b91006          LDRH     r1,[r9,#6]            ;847
00018a  9800              LDR      r0,[sp,#0]            ;847
00018c  4408              ADD      r0,r0,r1              ;847
00018e  04c0              LSLS     r0,r0,#19             ;847
000190  ea4f4b10          LSR      r11,r0,#16            ;847
                  |L18.404|
000194  8920              LDRH     r0,[r4,#8]            ;852
000196  eb0072d0          ADD      r2,r0,r0,LSR #31      ;852
00019a  8863              LDRH     r3,[r4,#2]            ;852
00019c  eb030262          ADD      r2,r3,r2,ASR #1       ;852
0001a0  4659              MOV      r1,r11                ;852
0001a2  eb0b73d1          ADD      r3,r11,r1,LSR #31     ;852
0001a6  eba20263          SUB      r2,r2,r3,ASR #1       ;852
0001aa  b217              SXTH     r7,r2                 ;852
0001ac  88a0              LDRH     r0,[r4,#4]            ;853
0001ae  88e1              LDRH     r1,[r4,#6]            ;853
0001b0  4408              ADD      r0,r0,r1              ;853
0001b2  1c80              ADDS     r0,r0,#2              ;853
0001b4  fa0ff880          SXTH     r8,r0                 ;853
0001b8  fa1ff188          UXTH     r1,r8                 ;854
0001bc  b2b8              UXTH     r0,r7                 ;854
0001be  464b              MOV      r3,r9                 ;854
0001c0  f1040210          ADD      r2,r4,#0x10           ;854
0001c4  f7fffffe          BL       LCD_DispStr
0001c8  bf00              NOP      
0001ca  e7cb              B        |L18.356|
;;;857    
                          ENDP


                          AREA ||i.LCD_DrawLabel||, CODE, READONLY, ALIGN=1

                  LCD_DrawLabel PROC
;;;931    */
;;;932    void LCD_DrawLabel(LABEL_T *_pLabel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;933    {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
;;;934    #if 1
;;;935    	char dispbuf[256];
;;;936    	uint16_t i;
;;;937    	uint16_t NewLen;
;;;938    
;;;939    	NewLen = strlen(_pLabel->pCaption);
000006  6920              LDR      r0,[r4,#0x10]
000008  f7fffffe          BL       strlen
00000c  b286              UXTH     r6,r0
;;;940    
;;;941    	if (NewLen > _pLabel->MaxLen)
00000e  8960              LDRH     r0,[r4,#0xa]
000010  42b0              CMP      r0,r6
000012  da07              BGE      |L19.36|
;;;942    	{
;;;943    		LCD_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->pCaption, _pLabel->Font);
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  e9d43203          LDRD     r3,r2,[r4,#0xc]
00001c  f7fffffe          BL       LCD_DispStr
;;;944    		_pLabel->MaxLen = NewLen;
000020  8166              STRH     r6,[r4,#0xa]
000022  e01b              B        |L19.92|
                  |L19.36|
;;;945    	}
;;;946    	else
;;;947    	{
;;;948    		for (i = 0; i < NewLen; i++)
000024  2500              MOVS     r5,#0
000026  e005              B        |L19.52|
                  |L19.40|
;;;949    		{
;;;950    			dispbuf[i] = _pLabel->pCaption[i];
000028  6920              LDR      r0,[r4,#0x10]
00002a  5d40              LDRB     r0,[r0,r5]
00002c  a901              ADD      r1,sp,#4
00002e  5548              STRB     r0,[r1,r5]
000030  1c68              ADDS     r0,r5,#1              ;948
000032  b285              UXTH     r5,r0                 ;948
                  |L19.52|
000034  42b5              CMP      r5,r6                 ;948
000036  dbf7              BLT      |L19.40|
;;;951    		}
;;;952    		for (; i < _pLabel->MaxLen; i++)
000038  e004              B        |L19.68|
                  |L19.58|
;;;953    		{
;;;954    			dispbuf[i] = ' ';		/* 末尾填充空格 */
00003a  2020              MOVS     r0,#0x20
00003c  a901              ADD      r1,sp,#4
00003e  5548              STRB     r0,[r1,r5]
000040  1c68              ADDS     r0,r5,#1              ;952
000042  b285              UXTH     r5,r0                 ;952
                  |L19.68|
000044  8960              LDRH     r0,[r4,#0xa]          ;952
000046  42a8              CMP      r0,r5                 ;952
000048  dcf7              BGT      |L19.58|
;;;955    		}
;;;956    		dispbuf[i] = 0;
00004a  2000              MOVS     r0,#0
00004c  a901              ADD      r1,sp,#4
00004e  5548              STRB     r0,[r1,r5]
;;;957    		LCD_DispStr(_pLabel->Left, _pLabel->Top, dispbuf, _pLabel->Font);
000050  88a1              LDRH     r1,[r4,#4]
000052  8860              LDRH     r0,[r4,#2]
000054  aa01              ADD      r2,sp,#4
000056  68e3              LDR      r3,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
                  |L19.92|
;;;958    	}
;;;959    #else
;;;960    	if (g_ChipID == IC_8875)
;;;961    	{
;;;962    		RA8875_SetFont(_pLabel->Font->FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;963    
;;;964    		RA8875_SetBackColor(_pLabel->Font->BackColor);
;;;965    		RA8875_SetFrontColor(_pLabel->Font->FrontColor);
;;;966    
;;;967    		RA8875_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->Caption);
;;;968    	}
;;;969    	else
;;;970    	{
;;;971    
;;;972    	}
;;;973    #endif
;;;974    }
00005c  b041              ADD      sp,sp,#0x104
00005e  bdf0              POP      {r4-r7,pc}
;;;975    
                          ENDP


                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;445    */
;;;446    void LCD_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;447    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;448    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L20.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L20.38|
;;;449    	{
;;;450    		RA8875_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawLine
000024  e006              B        |L20.52|
                  |L20.38|
;;;451    	}
;;;452    	else
;;;453    	{
;;;454    		SPFD5420_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawLine
                  |L20.52|
;;;455    	}
;;;456    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;457    
                          ENDP

                  |L20.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineH||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineH PROC
;;;1318   */
;;;1319   void LCD_DrawLineH(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1320   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1321   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L21.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L21.34|
;;;1322   	{
;;;1323   		RA8875_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHLine
000020  e005              B        |L21.46|
                  |L21.34|
;;;1324   	}
;;;1325   	else
;;;1326   	{
;;;1327   		SPFD5420_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHLine
                  |L21.46|
;;;1328   	}
;;;1329   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1330   
                          ENDP

000032  0000              DCW      0x0000
                  |L21.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineV||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineV PROC
;;;1364   */
;;;1365   void LCD_DrawLineV(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1366   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1367   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L22.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L22.34|
;;;1368   	{
;;;1369   		RA8875_DrawVLine(_usX1 , _usY1 , _usY2 , _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawVLine
000020  e005              B        |L22.46|
                  |L22.34|
;;;1370   	}
;;;1371   	else
;;;1372   	{
;;;1373   		SPFD5420_DrawVLine(_usX1 , _usY1 , _usY2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawVLine
                  |L22.46|
;;;1374   	}
;;;1375   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1376   
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawPoints||, CODE, READONLY, ALIGN=1

                  LCD_DrawPoints PROC
;;;467    */
;;;468    void LCD_DrawPoints(uint16_t *x, uint16_t *y, uint16_t _usSize, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;469    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;470    	uint16_t i;
;;;471    
;;;472    	for (i = 0 ; i < _usSize - 1; i++)
00000c  2400              MOVS     r4,#0
00000e  e00f              B        |L23.48|
                  |L23.16|
;;;473    	{
;;;474    		LCD_DrawLine(x[i], y[i], x[i + 1], y[i + 1], _usColor);
000010  f1040c01          ADD      r12,r4,#1
000014  f8cd8000          STR      r8,[sp,#0]
000018  f836301c          LDRH     r3,[r6,r12,LSL #1]
00001c  f835201c          LDRH     r2,[r5,r12,LSL #1]
000020  f8361014          LDRH     r1,[r6,r4,LSL #1]
000024  f8350014          LDRH     r0,[r5,r4,LSL #1]
000028  f7fffffe          BL       LCD_DrawLine
00002c  1c60              ADDS     r0,r4,#1              ;472
00002e  b284              UXTH     r4,r0                 ;472
                  |L23.48|
000030  1e78              SUBS     r0,r7,#1              ;472
000032  42a0              CMP      r0,r4                 ;472
000034  dcec              BGT      |L23.16|
;;;475    	}
;;;476    }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;477    
                          ENDP


                          AREA ||i.LCD_DrawRect||, CODE, READONLY, ALIGN=2

                  LCD_DrawRect PROC
;;;488    */
;;;489    void LCD_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;490    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;491    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L24.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L24.38|
;;;492    	{
;;;493    		RA8875_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000016  4643              MOV      r3,r8
000018  4622              MOV      r2,r4
00001a  4639              MOV      r1,r7
00001c  4630              MOV      r0,r6
00001e  9500              STR      r5,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawRect
000024  e006              B        |L24.52|
                  |L24.38|
;;;494    	}
;;;495    	else
;;;496    	{
;;;497    		SPFD5420_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000026  b2e2              UXTB     r2,r4
000028  4643              MOV      r3,r8
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  9500              STR      r5,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawRect
                  |L24.52|
;;;498    	}
;;;499    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;500    
                          ENDP

                  |L24.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawWin||, CODE, READONLY, ALIGN=1

                  LCD_DrawWin PROC
;;;582    */
;;;583    void LCD_DrawWin(WIN_T *_pWin)
000000  b5f8              PUSH     {r3-r7,lr}
;;;584    {
000002  4604              MOV      r4,r0
;;;585    #if 1
;;;586    	uint16_t TitleHegiht;
;;;587    
;;;588    	TitleHegiht = 20;
000004  2514              MOVS     r5,#0x14
;;;589    
;;;590    	/* 绘制窗口外框 */
;;;591    	LCD_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
000006  f44f7004          MOV      r0,#0x210
00000a  9000              STR      r0,[sp,#0]
00000c  8923              LDRH     r3,[r4,#8]
00000e  88e2              LDRH     r2,[r4,#6]
000010  88a1              LDRH     r1,[r4,#4]
000012  8860              LDRH     r0,[r4,#2]
000014  f7fffffe          BL       LCD_DrawRect
;;;592    	LCD_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
000018  f44f7004          MOV      r0,#0x210
00001c  9000              STR      r0,[sp,#0]
00001e  8926              LDRH     r6,[r4,#8]
000020  1eb6              SUBS     r6,r6,#2
000022  b2b3              UXTH     r3,r6
000024  88e6              LDRH     r6,[r4,#6]
000026  1eb6              SUBS     r6,r6,#2
000028  b2b2              UXTH     r2,r6
00002a  88a6              LDRH     r6,[r4,#4]
00002c  1c76              ADDS     r6,r6,#1
00002e  b2b1              UXTH     r1,r6
000030  8866              LDRH     r6,[r4,#2]
000032  1c76              ADDS     r6,r6,#1
000034  b2b0              UXTH     r0,r6
000036  f7fffffe          BL       LCD_DrawRect
;;;593    
;;;594    	/* 窗口标题栏 */
;;;595    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
00003a  f244203f          MOV      r0,#0x423f
00003e  9000              STR      r0,[sp,#0]
000040  8922              LDRH     r2,[r4,#8]
000042  1f12              SUBS     r2,r2,#4
000044  b293              UXTH     r3,r2
000046  88a2              LDRH     r2,[r4,#4]
000048  1c92              ADDS     r2,r2,#2
00004a  b291              UXTH     r1,r2
00004c  8862              LDRH     r2,[r4,#2]
00004e  1c92              ADDS     r2,r2,#2
000050  b290              UXTH     r0,r2
000052  462a              MOV      r2,r5
000054  f7fffffe          BL       LCD_Fill_Rect
;;;596    
;;;597    	/* 窗体填充 */
;;;598    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht,
000058  f24b50b6          MOV      r0,#0xb5b6
00005c  9000              STR      r0,[sp,#0]
00005e  8926              LDRH     r6,[r4,#8]
000060  1f36              SUBS     r6,r6,#4
000062  b2b3              UXTH     r3,r6
000064  88e6              LDRH     r6,[r4,#6]
000066  1f36              SUBS     r6,r6,#4
000068  1b76              SUBS     r6,r6,r5
00006a  b2b2              UXTH     r2,r6
00006c  88a6              LDRH     r6,[r4,#4]
00006e  442e              ADD      r6,r6,r5
000070  1cb6              ADDS     r6,r6,#2
000072  b2b1              UXTH     r1,r6
000074  8866              LDRH     r6,[r4,#2]
000076  1cb6              ADDS     r6,r6,#2
000078  b2b0              UXTH     r0,r6
00007a  f7fffffe          BL       LCD_Fill_Rect
;;;599    		_pWin->Width - 4, WIN_BODY_COLOR);
;;;600    
;;;601    	LCD_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->pCaption, _pWin->Font);
00007e  88a6              LDRH     r6,[r4,#4]
000080  1cb6              ADDS     r6,r6,#2
000082  b2b1              UXTH     r1,r6
000084  8866              LDRH     r6,[r4,#2]
000086  1cf6              ADDS     r6,r6,#3
000088  b2b0              UXTH     r0,r6
00008a  e9d43203          LDRD     r3,r2,[r4,#0xc]
00008e  f7fffffe          BL       LCD_DispStr
;;;602    #else
;;;603    	if (g_ChipID == IC_8875)
;;;604    	{
;;;605    		uint16_t TitleHegiht;
;;;606    
;;;607    		TitleHegiht = 28;
;;;608    
;;;609    		/* 绘制窗口外框 */
;;;610    		RA8875_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
;;;611    		RA8875_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
;;;612    
;;;613    		/* 窗口标题栏 */
;;;614    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
;;;615    
;;;616    		/* 窗体填充 */
;;;617    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht, _pWin->Width - 4, WIN_BODY_COLOR);
;;;618    
;;;619    		//RA8875_SetFont(_pWin->Font.FontCode, 0, 0);
;;;620    		RA8875_SetFont(RA_FONT_24, 0, 0);
;;;621    
;;;622    		RA8875_SetBackColor(WIN_TITLE_COLOR);
;;;623    		RA8875_SetFrontColor(WIN_CAPTION_COLOR);
;;;624    		RA8875_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->Caption);
;;;625    	}
;;;626    	else
;;;627    	{
;;;628    		;
;;;629    	}
;;;630    #endif
;;;631    }
000092  bdf8              POP      {r3-r7,pc}
;;;632    
                          ENDP


                          AREA ||i.LCD_FSMCConfig||, CODE, READONLY, ALIGN=1

                  LCD_FSMCConfig PROC
;;;1497   */
;;;1498   static void LCD_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;1499   {
000002  b09d              SUB      sp,sp,#0x74
;;;1500   	FSMC_NORSRAMInitTypeDef  init;
;;;1501   	FSMC_NORSRAMTimingInitTypeDef  timingWrite;
;;;1502   	FSMC_NORSRAMTimingInitTypeDef  timingRead;
;;;1503   
;;;1504   	/*-- FSMC Configuration ------------------------------------------------------*/
;;;1505   	/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;1506   	/* FSMC_Bank1_NORSRAM4 configuration */
;;;1507   	/* 摄像头DMA麻点，需设置 4 0 5 2 0 0 */
;;;1508   	timingWrite.FSMC_AddressSetupTime = 4;
000004  2004              MOVS     r0,#4
000006  9007              STR      r0,[sp,#0x1c]
;;;1509   	timingWrite.FSMC_AddressHoldTime = 0;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
;;;1510   	timingWrite.FSMC_DataSetupTime = 6;
00000c  2006              MOVS     r0,#6
00000e  9009              STR      r0,[sp,#0x24]
;;;1511   	timingWrite.FSMC_BusTurnAroundDuration = 1;
000010  2001              MOVS     r0,#1
000012  900a              STR      r0,[sp,#0x28]
;;;1512   	timingWrite.FSMC_CLKDivision = 0;
000014  2000              MOVS     r0,#0
000016  900b              STR      r0,[sp,#0x2c]
;;;1513   	timingWrite.FSMC_DataLatency = 0;
000018  900c              STR      r0,[sp,#0x30]
;;;1514   	timingWrite.FSMC_AccessMode = FSMC_AccessMode_A;
00001a  900d              STR      r0,[sp,#0x34]
;;;1515   
;;;1516   	timingRead.FSMC_AddressSetupTime = 4;
00001c  2004              MOVS     r0,#4
00001e  9000              STR      r0,[sp,#0]
;;;1517   	timingRead.FSMC_AddressHoldTime = 0;
000020  2000              MOVS     r0,#0
000022  9001              STR      r0,[sp,#4]
;;;1518   	timingRead.FSMC_DataSetupTime = 8;
000024  2008              MOVS     r0,#8
000026  9002              STR      r0,[sp,#8]
;;;1519   	timingRead.FSMC_BusTurnAroundDuration = 1;
000028  2001              MOVS     r0,#1
00002a  9003              STR      r0,[sp,#0xc]
;;;1520   	timingRead.FSMC_CLKDivision = 0;
00002c  2000              MOVS     r0,#0
00002e  9004              STR      r0,[sp,#0x10]
;;;1521   	timingRead.FSMC_DataLatency = 0;
000030  9005              STR      r0,[sp,#0x14]
;;;1522   	timingRead.FSMC_AccessMode = FSMC_AccessMode_A;
000032  9006              STR      r0,[sp,#0x18]
;;;1523   
;;;1524   
;;;1525   	/*
;;;1526   	 LCD configured as follow:
;;;1527   	    - Data/Address MUX = Disable
;;;1528   	    - Memory Type = SRAM
;;;1529   	    - Data Width = 16bit
;;;1530   	    - Write Operation = Enable
;;;1531   	    - Extended Mode = Enable
;;;1532   	    - Asynchronous Wait = Disable
;;;1533   	*/
;;;1534   	init.FSMC_Bank = FSMC_Bank1_NORSRAM4;
000034  2006              MOVS     r0,#6
000036  900e              STR      r0,[sp,#0x38]
;;;1535   	init.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
000038  2000              MOVS     r0,#0
00003a  900f              STR      r0,[sp,#0x3c]
;;;1536   	init.FSMC_MemoryType = FSMC_MemoryType_SRAM;
00003c  9010              STR      r0,[sp,#0x40]
;;;1537   	init.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
00003e  2010              MOVS     r0,#0x10
000040  9011              STR      r0,[sp,#0x44]
;;;1538   	init.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
000042  2000              MOVS     r0,#0
000044  9012              STR      r0,[sp,#0x48]
;;;1539   	init.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;	/* 注意旧库无这个成员 */
000046  9013              STR      r0,[sp,#0x4c]
;;;1540   	init.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000048  9014              STR      r0,[sp,#0x50]
;;;1541   	init.FSMC_WrapMode = FSMC_WrapMode_Disable;
00004a  9015              STR      r0,[sp,#0x54]
;;;1542   	init.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
00004c  9016              STR      r0,[sp,#0x58]
;;;1543   	init.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
00004e  f44f5080          MOV      r0,#0x1000
000052  9017              STR      r0,[sp,#0x5c]
;;;1544   	init.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
000054  2000              MOVS     r0,#0
000056  9018              STR      r0,[sp,#0x60]
;;;1545   	init.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000058  9019              STR      r0,[sp,#0x64]
;;;1546   	init.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
00005a  901a              STR      r0,[sp,#0x68]
;;;1547   
;;;1548   	init.FSMC_ReadWriteTimingStruct = &timingRead;
00005c  f8cdd06c          STR      sp,[sp,#0x6c]
;;;1549   	init.FSMC_WriteTimingStruct = &timingWrite;
000060  a807              ADD      r0,sp,#0x1c
000062  901c              STR      r0,[sp,#0x70]
;;;1550   
;;;1551   	FSMC_NORSRAMInit(&init);
000064  a80e              ADD      r0,sp,#0x38
000066  f7fffffe          BL       FSMC_NORSRAMInit
;;;1552   
;;;1553   	/* - BANK 1 (of NOR/SRAM Bank 1~4) is enabled */
;;;1554   	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2006              MOVS     r0,#6
00006e  f7fffffe          BL       FSMC_NORSRAMCmd
;;;1555   }
000072  b01d              ADD      sp,sp,#0x74
000074  bd00              POP      {pc}
;;;1556   
                          ENDP


                          AREA ||i.LCD_Fill_Rect||, CODE, READONLY, ALIGN=2

                  LCD_Fill_Rect PROC
;;;511    */
;;;512    void LCD_Fill_Rect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;513    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;514    	uint16_t i;
;;;515    
;;;516    	if (g_ChipID == IC_8875)
000010  480e              LDR      r0,|L27.76|
000012  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000014  2875              CMP      r0,#0x75
000016  d108              BNE      |L27.42|
;;;517    	{
;;;518    		RA8875_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4649              MOV      r1,r9
00001e  4628              MOV      r0,r5
000020  f8cd8000          STR      r8,[sp,#0]
000024  f7fffffe          BL       RA8875_FillRect
000028  e00d              B        |L27.70|
                  |L27.42|
;;;519    	}
;;;520    	else
;;;521    	{
;;;522    		for (i = 0; i < _usHeight; i++)
00002a  2400              MOVS     r4,#0
00002c  e009              B        |L27.66|
                  |L27.46|
;;;523    		{
;;;524    			SPFD5420_DrawHLine(_usX, _usY, _usX + _usWidth - 1, _usColor);
00002e  19e8              ADDS     r0,r5,r7
000030  1e40              SUBS     r0,r0,#1
000032  b282              UXTH     r2,r0
000034  4643              MOV      r3,r8
000036  4649              MOV      r1,r9
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SPFD5420_DrawHLine
00003e  1c60              ADDS     r0,r4,#1              ;522
000040  b284              UXTH     r4,r0                 ;522
                  |L27.66|
000042  42b4              CMP      r4,r6                 ;522
000044  dbf3              BLT      |L27.46|
                  |L27.70|
;;;525    		}
;;;526    	}
;;;527    }
000046  e8bd83f8          POP      {r3-r9,pc}
;;;528    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_GetBackLight PROC
;;;1587   */
;;;1588   uint8_t LCD_GetBackLight(void)
000000  4801              LDR      r0,|L28.8|
;;;1589   {
;;;1590   	return s_ucBright;
000002  7800              LDRB     r0,[r0,#0]  ; s_ucBright
;;;1591   }
000004  4770              BX       lr
;;;1592   /*
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      s_ucBright

                          AREA ||i.LCD_GetChipDescribe||, CODE, READONLY, ALIGN=2

                  LCD_GetChipDescribe PROC
;;;124    */
;;;125    void LCD_GetChipDescribe(char *_str)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127    	switch (g_ChipID)
000004  4815              LDR      r0,|L29.92|
000006  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000008  2875              CMP      r0,#0x75
00000a  d01b              BEQ      |L29.68|
00000c  f46f4180          MVN      r1,#0x4000
000010  4408              ADD      r0,r0,r1
000012  b168              CBZ      r0,|L29.48|
000014  f5a050a0          SUB      r0,r0,#0x1400
000018  381f              SUBS     r0,r0,#0x1f
00001a  b120              CBZ      r0,|L29.38|
00001c  f5a040c0          SUB      r0,r0,#0x6000
000020  38e9              SUBS     r0,r0,#0xe9
000022  b9a0              CBNZ     r0,|L29.78|
000024  e009              B        |L29.58|
                  |L29.38|
;;;128    	{
;;;129    		case IC_5420:
;;;130    			strcpy(_str, CHIP_STR_5420);
000026  a10e              ADR      r1,|L29.96|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       strcpy
;;;131    			break;
00002e  e013              B        |L29.88|
                  |L29.48|
;;;132    
;;;133    		case IC_4001:
;;;134    			strcpy(_str, CHIP_STR_4001);
000030  a10e              ADR      r1,|L29.108|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       strcpy
;;;135    			break;
000038  e00e              B        |L29.88|
                  |L29.58|
;;;136    
;;;137    		case IC_61509:
;;;138    			strcpy(_str, CHIP_STR_61509);
00003a  a10f              ADR      r1,|L29.120|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       strcpy
;;;139    			break;
000042  e009              B        |L29.88|
                  |L29.68|
;;;140    
;;;141    		case IC_8875:
;;;142    			strcpy(_str, CHIP_STR_8875);
000044  a10e              ADR      r1,|L29.128|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       strcpy
;;;143    			break;
00004c  e004              B        |L29.88|
                  |L29.78|
;;;144    
;;;145    		default:
;;;146    			strcpy(_str, "Unknow");
00004e  a10e              ADR      r1,|L29.136|
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       strcpy
;;;147    			break;
000056  bf00              NOP      
                  |L29.88|
000058  bf00              NOP                            ;131
;;;148    	}
;;;149    }
00005a  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  |L29.92|
                          DCD      g_ChipID
                  |L29.96|
000060  53504644          DCB      "SPFD5420A",0
000064  35343230
000068  4100    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L29.108|
00006c  4f544d34          DCB      "OTM4001A",0
000070  30303141
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L29.120|
000078  52363135          DCB      "R61509V",0
00007c  30395600
                  |L29.128|
000080  52413838          DCB      "RA8875",0
000084  373500  
000087  00                DCB      0
                  |L29.136|
000088  556e6b6e          DCB      "Unknow",0
00008c  6f7700  
00008f  00                DCB      0

                          AREA ||i.LCD_GetHeight||, CODE, READONLY, ALIGN=2

                  LCD_GetHeight PROC
;;;158    */
;;;159    uint16_t LCD_GetHeight(void)
000000  4801              LDR      r0,|L30.8|
;;;160    {
;;;161    	return g_LcdHeight;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
;;;162    }
000004  4770              BX       lr
;;;163    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      g_LcdHeight

                          AREA ||i.LCD_GetPixel||, CODE, READONLY, ALIGN=2

                  LCD_GetPixel PROC
;;;418    */
;;;419    uint16_t LCD_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;421    	uint16_t usRGB;
;;;422    
;;;423    	if (g_ChipID == IC_8875)
000006  4808              LDR      r0,|L31.40|
000008  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000a  2875              CMP      r0,#0x75
00000c  d105              BNE      |L31.26|
;;;424    	{
;;;425    		usRGB = RA8875_GetPixel(_usX, _usY);
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       RA8875_GetPixel
000016  4604              MOV      r4,r0
000018  e004              B        |L31.36|
                  |L31.26|
;;;426    	}
;;;427    	else
;;;428    	{
;;;429    		usRGB = SPFD5420_GetPixel(_usX, _usY);
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       SPFD5420_GetPixel
000022  4604              MOV      r4,r0
                  |L31.36|
;;;430    	}
;;;431    
;;;432    	return usRGB;
000024  4620              MOV      r0,r4
;;;433    }
000026  bd70              POP      {r4-r6,pc}
;;;434    
                          ENDP

                  |L31.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetWidth||, CODE, READONLY, ALIGN=2

                  LCD_GetWidth PROC
;;;171    */
;;;172    uint16_t LCD_GetWidth(void)
000000  4801              LDR      r0,|L32.8|
;;;173    {
;;;174    	return g_LcdWidth;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
;;;175    }
000004  4770              BX       lr
;;;176    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      g_LcdWidth

                          AREA ||i.LCD_InitHard||, CODE, READONLY, ALIGN=2

                  LCD_InitHard PROC
;;;70     */
;;;71     void LCD_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73     	uint16_t id;
;;;74     
;;;75     	/* 配置LCD控制口线GPIO */
;;;76     	LCD_CtrlLinesConfig();
000002  f7fffffe          BL       LCD_CtrlLinesConfig
;;;77     
;;;78     	/* 配置FSMC接口，数据总线 */
;;;79     	LCD_FSMCConfig();
000006  f7fffffe          BL       LCD_FSMCConfig
;;;80     
;;;81     	#ifdef IF_SPI_EN
;;;82     		RA8875_InitSPI();
;;;83     	#endif
;;;84     
;;;85     	/* FSMC重置后必须加延迟才能访问总线设备  */
;;;86     //	bsp_DelayMS(20);
;;;87     	Bus_Delay(1000000);
00000a  4818              LDR      r0,|L33.108|
00000c  f7fffffe          BL       Bus_Delay
;;;88     	
;;;89     	id = SPFD5420_ReadID();  	/* 读取LCD驱动芯片ID */
000010  f7fffffe          BL       SPFD5420_ReadID
000014  4604              MOV      r4,r0
;;;90     	if ((id == 0x5420) || (id ==  0xB509) || (id == 0x5520))
000016  f2454020          MOV      r0,#0x5420
00001a  4284              CMP      r4,r0
00001c  d007              BEQ      |L33.46|
00001e  f24b5009          MOV      r0,#0xb509
000022  4284              CMP      r4,r0
000024  d003              BEQ      |L33.46|
000026  f2455020          MOV      r0,#0x5520
00002a  4284              CMP      r4,r0
00002c  d102              BNE      |L33.52|
                  |L33.46|
;;;91     	{
;;;92     		SPFD5420_InitHard();	/* 初始化5420和4001屏硬件 */
00002e  f7fffffe          BL       SPFD5420_InitHard
000032  e013              B        |L33.92|
                  |L33.52|
;;;93     		/* g_ChipID 在函数内部设置了 */
;;;94     	}
;;;95     	else
;;;96     	{
;;;97     		if (RA8875_ReadID() == 0x75)
000034  f7fffffe          BL       RA8875_ReadID
000038  2875              CMP      r0,#0x75
00003a  d104              BNE      |L33.70|
;;;98     		{
;;;99     			g_ChipID = IC_8875;
00003c  490c              LDR      r1,|L33.112|
00003e  8008              STRH     r0,[r1,#0]
;;;100    			RA8875_InitHard();	/* 初始化RA8875芯片 */
000040  f7fffffe          BL       RA8875_InitHard
000044  e00a              B        |L33.92|
                  |L33.70|
;;;101    		}
;;;102    		else
;;;103    		{
;;;104    			/* 如果未能成功识别，则缺省按4001屏处理 */
;;;105    			g_ChipID = IC_4001;
000046  f2440001          MOV      r0,#0x4001
00004a  4909              LDR      r1,|L33.112|
00004c  8008              STRH     r0,[r1,#0]
;;;106    			g_LcdHeight = LCD_30_HEIGHT;
00004e  20f0              MOVS     r0,#0xf0
000050  4908              LDR      r1,|L33.116|
000052  8008              STRH     r0,[r1,#0]
;;;107    			g_LcdWidth = LCD_30_WIDTH;
000054  f44f70c8          MOV      r0,#0x190
000058  4907              LDR      r1,|L33.120|
00005a  8008              STRH     r0,[r1,#0]
                  |L33.92|
;;;108    		}
;;;109    	}
;;;110    
;;;111    	LCD_ClrScr(CL_BLACK);	/* 清屏，显示全黑 */
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       LCD_ClrScr
;;;112    
;;;113    	LCD_SetBackLight(BRIGHT_MAX);	 /* 打开背光，设置为缺省亮度 */
000062  20ff              MOVS     r0,#0xff
000064  f7fffffe          BL       LCD_SetBackLight
;;;114    }
000068  bd10              POP      {r4,pc}
;;;115    
                          ENDP

00006a  0000              DCW      0x0000
                  |L33.108|
                          DCD      0x000f4240
                  |L33.112|
                          DCD      g_ChipID
                  |L33.116|
                          DCD      g_LcdHeight
                  |L33.120|
                          DCD      g_LcdWidth

                          AREA ||i.LCD_PutPixel||, CODE, READONLY, ALIGN=2

                  LCD_PutPixel PROC
;;;396    */
;;;397    void LCD_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;398    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;399    	if (g_ChipID == IC_8875)
000008  4807              LDR      r0,|L34.40|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d105              BNE      |L34.28|
;;;400    	{
;;;401    		RA8875_PutPixel(_usX, _usY, _usColor);
000010  4632              MOV      r2,r6
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RA8875_PutPixel
00001a  e004              B        |L34.38|
                  |L34.28|
;;;402    	}
;;;403    	else
;;;404    	{
;;;405    		SPFD5420_PutPixel(_usX, _usY, _usColor);
00001c  4632              MOV      r2,r6
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPFD5420_PutPixel
                  |L34.38|
;;;406    	}
;;;407    }
000026  bd70              POP      {r4-r6,pc}
;;;408    
                          ENDP

                  |L34.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetBackLight PROC
;;;1565   */
;;;1566   void LCD_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1567   {
000002  4604              MOV      r4,r0
;;;1568   	s_ucBright =  _bright;	/* 保存背光值 */
000004  4806              LDR      r0,|L35.32|
000006  7004              STRB     r4,[r0,#0]
;;;1569   
;;;1570   	if (g_ChipID == IC_8875)
000008  4806              LDR      r0,|L35.36|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d103              BNE      |L35.24|
;;;1571   	{
;;;1572   		RA8875_SetBackLight(_bright);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetBackLight
000016  e002              B        |L35.30|
                  |L35.24|
;;;1573   	}
;;;1574   	else
;;;1575   	{
;;;1576   		SPFD5420_SetBackLight(_bright);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPFD5420_SetBackLight
                  |L35.30|
;;;1577   	}
;;;1578   }
00001e  bd10              POP      {r4,pc}
;;;1579   
                          ENDP

                  |L35.32|
                          DCD      s_ucBright
                  |L35.36|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetDirection||, CODE, READONLY, ALIGN=2

                  LCD_SetDirection PROC
;;;1599   */
;;;1600   void LCD_SetDirection(uint8_t _dir)
000000  b510              PUSH     {r4,lr}
;;;1601   {
000002  4604              MOV      r4,r0
;;;1602   	g_LcdDirection =  _dir;		/* 保存在全局变量 */
000004  4806              LDR      r0,|L36.32|
000006  7004              STRB     r4,[r0,#0]
;;;1603   
;;;1604   	if (g_ChipID == IC_8875)
000008  4806              LDR      r0,|L36.36|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d103              BNE      |L36.24|
;;;1605   	{
;;;1606   		RA8875_SetDirection(_dir);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetDirection
000016  e002              B        |L36.30|
                  |L36.24|
;;;1607   	}
;;;1608   	else
;;;1609   	{
;;;1610   		ILI9488_SetDirection(_dir);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ILI9488_SetDirection
                  |L36.30|
;;;1611   	}
;;;1612   }
00001e  bd10              POP      {r4,pc}
;;;1613   /***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/
                          ENDP

                  |L36.32|
                          DCD      g_LcdDirection
                  |L36.36|
                          DCD      g_ChipID

                          AREA ||.data||, DATA, ALIGN=1

                  g_ChipID
000000  4001              DCW      0x4001
                  g_LcdHeight
000002  00f0              DCW      0x00f0
                  g_LcdWidth
000004  0190              DCW      0x0190
                  s_ucBright
000006  00                DCB      0x00
                  g_LcdDirection
000007  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_tft_lcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_tft_lcd_c_g_ChipID____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH|
#line 144
|__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
