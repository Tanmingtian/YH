; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\lcdconf.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\lcdconf.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\User -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\User\fonts -I..\emWin\GUI_X -I..\emWin\Config -I..\emWin\Include -I..\emWin\emWinTask -I..\User\bsp_stm32f4xx -I..\User\bsp_stm32f4xx\inc -I..\User\images -I..\User\bsp_stm32f4xx\src -I..\User\DSP_Lib\inc -I..\User\DSP_Lib\src -I..\Libraries\STM32F4x7_ETH_Driver\src -I..\Libraries\STM32F4x7_ETH_Driver\inc -IF:\keil\ARM\RV31\INC -IF:\keil\ARM\CMSIS\Include -IF:\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F427_437xx -DSTM32F427_437xx --omf_browse=.\flash\obj\lcdconf.crf ..\emWin\Config\LCDConf.c]
                          THUMB

                          AREA ||i.LCD_X_Config||, CODE, READONLY, ALIGN=2

                  LCD_X_Config PROC
;;;104    */
;;;105    void LCD_X_Config(void) 
000000  b508              PUSH     {r3,lr}
;;;106    {
;;;107    	/* 读取EEPROM中的参数 */	
;;;108    	ee_ReadBytes((uint8_t *)&g_tTPSL, 1024, sizeof(g_tTPSL));
000002  220a              MOVS     r2,#0xa
000004  f44f6180          MOV      r1,#0x400
000008  4849              LDR      r0,|L1.304|
00000a  f7fffffe          BL       ee_ReadBytes
;;;109    	
;;;110     	/* Set display driver and color conversion for 1st layer */
;;;111        GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  4948              LDR      r1,|L1.308|
000014  4848              LDR      r0,|L1.312|
000016  f7fffffe          BL       GUI_DEVICE_CreateAndLink
;;;112    
;;;113         if (g_ChipID == IC_8875)
00001a  4848              LDR      r0,|L1.316|
00001c  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00001e  2875              CMP      r0,#0x75
000020  d163              BNE      |L1.234|
;;;114     	{
;;;115     		if (g_ucGPIX == 1)	/* 	GPIX = 1  4.3  480x272 */
000022  4847              LDR      r0,|L1.320|
000024  7800              LDRB     r0,[r0,#0]  ; g_ucGPIX
000026  2801              CMP      r0,#1
000028  d12f              BNE      |L1.138|
;;;116     		{
;;;117    			/* Display driver configuration */
;;;118    			LCD_SetSizeEx    (0, 480, 272);
00002a  f44f7288          MOV      r2,#0x110
00002e  f44f71f0          MOV      r1,#0x1e0
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       LCD_SetSizeEx
;;;119    			LCD_SetVSizeEx   (0, 480, 272);
000038  f44f7288          MOV      r2,#0x110
00003c  f44f71f0          MOV      r1,#0x1e0
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       LCD_SetVSizeEx
;;;120    			
;;;121    			/* Touch calibration */ 
;;;122    			GUI_TOUCH_Calibrate(GUI_COORD_X, 0, 479, g_tTPSL.usAdcX1,  g_tTPSL.usAdcX2);
000046  483a              LDR      r0,|L1.304|
000048  f9b00002          LDRSH    r0,[r0,#2]  ; g_tTPSL
00004c  9000              STR      r0,[sp,#0]
00004e  4838              LDR      r0,|L1.304|
000050  f9b03000          LDRSH    r3,[r0,#0]  ; g_tTPSL
000054  f24012df          MOV      r2,#0x1df
000058  2100              MOVS     r1,#0
00005a  4608              MOV      r0,r1
00005c  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;123    			GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, 271, g_tTPSL.usAdcY1,  g_tTPSL.usAdcY2);
000060  4833              LDR      r0,|L1.304|
000062  f9b00006          LDRSH    r0,[r0,#6]  ; g_tTPSL
000066  9000              STR      r0,[sp,#0]
000068  4831              LDR      r0,|L1.304|
00006a  f9b03004          LDRSH    r3,[r0,#4]  ; g_tTPSL
00006e  f240120f          MOV      r2,#0x10f
000072  2100              MOVS     r1,#0
000074  2001              MOVS     r0,#1
000076  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;124    			
;;;125    			/* 查看是否需要切换X,Y*/
;;;126    			if(g_tTPSL.XYChange == 1)
00007a  482d              LDR      r0,|L1.304|
00007c  8900              LDRH     r0,[r0,#8]  ; g_tTPSL
00007e  2801              CMP      r0,#1
000080  d154              BNE      |L1.300|
;;;127    			{
;;;128    				GUI_TOUCH_SetOrientation(GUI_SWAP_XY);
000082  2004              MOVS     r0,#4
000084  f7fffffe          BL       GUI_TOUCH_SetOrientation
000088  e050              B        |L1.300|
                  |L1.138|
;;;129    			}
;;;130     		}
;;;131     		else 	/* 	GPIX = 0  7  800*480 */
;;;132     		{
;;;133     			/* Display driver configuration */
;;;134     			LCD_SetSizeEx    (0, XSIZE_PHYS, YSIZE_PHYS);
00008a  f44f72f0          MOV      r2,#0x1e0
00008e  f44f7148          MOV      r1,#0x320
000092  2000              MOVS     r0,#0
000094  f7fffffe          BL       LCD_SetSizeEx
;;;135     			LCD_SetVSizeEx   (0, VXSIZE_PHYS, VYSIZE_PHYS);
000098  f44f72f0          MOV      r2,#0x1e0
00009c  f44f7148          MOV      r1,#0x320
0000a0  2000              MOVS     r0,#0
0000a2  f7fffffe          BL       LCD_SetVSizeEx
;;;136     			
;;;137     			GUI_TOUCH_Calibrate(GUI_COORD_X, 0, XSIZE_PHYS - 1, g_tTPSL.usAdcX1,  g_tTPSL.usAdcX2);
0000a6  4822              LDR      r0,|L1.304|
0000a8  f9b00002          LDRSH    r0,[r0,#2]  ; g_tTPSL
0000ac  9000              STR      r0,[sp,#0]
0000ae  4820              LDR      r0,|L1.304|
0000b0  f9b03000          LDRSH    r3,[r0,#0]  ; g_tTPSL
0000b4  f240321f          MOV      r2,#0x31f
0000b8  2100              MOVS     r1,#0
0000ba  4608              MOV      r0,r1
0000bc  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;138     			GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, YSIZE_PHYS - 1, g_tTPSL.usAdcY1,  g_tTPSL.usAdcY2);	
0000c0  481b              LDR      r0,|L1.304|
0000c2  f9b00006          LDRSH    r0,[r0,#6]  ; g_tTPSL
0000c6  9000              STR      r0,[sp,#0]
0000c8  4819              LDR      r0,|L1.304|
0000ca  f9b03004          LDRSH    r3,[r0,#4]  ; g_tTPSL
0000ce  f24012df          MOV      r2,#0x1df
0000d2  2100              MOVS     r1,#0
0000d4  2001              MOVS     r0,#1
0000d6  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;139    			
;;;140    			/* 查看是否需要切换X,Y*/
;;;141    			if(g_tTPSL.XYChange == 1)
0000da  4815              LDR      r0,|L1.304|
0000dc  8900              LDRH     r0,[r0,#8]  ; g_tTPSL
0000de  2801              CMP      r0,#1
0000e0  d124              BNE      |L1.300|
;;;142    			{
;;;143    				GUI_TOUCH_SetOrientation(GUI_SWAP_XY);
0000e2  2004              MOVS     r0,#4
0000e4  f7fffffe          BL       GUI_TOUCH_SetOrientation
0000e8  e020              B        |L1.300|
                  |L1.234|
;;;144    			}
;;;145     		}
;;;146     	}
;;;147     	else
;;;148     	{
;;;149     		LCD_SetSizeEx    (0, 400, 240);
0000ea  22f0              MOVS     r2,#0xf0
0000ec  f44f71c8          MOV      r1,#0x190
0000f0  2000              MOVS     r0,#0
0000f2  f7fffffe          BL       LCD_SetSizeEx
;;;150     		LCD_SetVSizeEx   (0, 400, 240);
0000f6  22f0              MOVS     r2,#0xf0
0000f8  f44f71c8          MOV      r1,#0x190
0000fc  2000              MOVS     r0,#0
0000fe  f7fffffe          BL       LCD_SetVSizeEx
;;;151     		
;;;152     		/* Touch calibration */ 
;;;153     		GUI_TOUCH_Calibrate(GUI_COORD_X, 0, 399, 300, 3600);
000102  f44f6061          MOV      r0,#0xe10
000106  f44f7396          MOV      r3,#0x12c
00010a  f240128f          MOV      r2,#0x18f
00010e  2100              MOVS     r1,#0
000110  9000              STR      r0,[sp,#0]
000112  4608              MOV      r0,r1
000114  f7fffffe          BL       GUI_TOUCH_Calibrate
;;;154     		GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, 239, 273,  3671);	
000118  f6406057          MOV      r0,#0xe57
00011c  f2401311          MOV      r3,#0x111
000120  22ef              MOVS     r2,#0xef
000122  2100              MOVS     r1,#0
000124  9000              STR      r0,[sp,#0]
000126  2001              MOVS     r0,#1
000128  f7fffffe          BL       GUI_TOUCH_Calibrate
                  |L1.300|
;;;155     	}
;;;156    
;;;157    }
00012c  bd08              POP      {r3,pc}
;;;158    
                          ENDP

00012e  0000              DCW      0x0000
                  |L1.304|
                          DCD      g_tTPSL
                  |L1.308|
                          DCD      LCD_API_ColorConv_M565
                  |L1.312|
                          DCD      GUIDRV_Template_API
                  |L1.316|
                          DCD      g_ChipID
                  |L1.320|
                          DCD      g_ucGPIX

                          AREA ||i.LCD_X_DisplayDriver||, CODE, READONLY, ALIGN=1

                  LCD_X_DisplayDriver PROC
;;;181    */
;;;182    int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData) 
000000  b530              PUSH     {r4,r5,lr}
;;;183    {
000002  4605              MOV      r5,r0
;;;184    	int r;
;;;185    	switch (Cmd) 
000004  2904              CMP      r1,#4
000006  d019              BEQ      |L2.60|
000008  dc06              BGT      |L2.24|
00000a  2901              CMP      r1,#1
00000c  d00b              BEQ      |L2.38|
00000e  2902              CMP      r1,#2
000010  d00b              BEQ      |L2.42|
000012  2903              CMP      r1,#3
000014  d119              BNE      |L2.74|
000016  e00b              B        |L2.48|
                  |L2.24|
000018  2905              CMP      r1,#5
00001a  d012              BEQ      |L2.66|
00001c  2906              CMP      r1,#6
00001e  d012              BEQ      |L2.70|
000020  290e              CMP      r1,#0xe
000022  d112              BNE      |L2.74|
000024  e007              B        |L2.54|
                  |L2.38|
;;;186    	{
;;;187    		case LCD_X_INITCONTROLLER: 
;;;188    		{
;;;189    			//
;;;190    			// Called during the initialization process in order to set up the
;;;191    			// display controller and put it into operation. If the display
;;;192    			// controller is not initialized by any external routine this needs
;;;193    			// to be adapted by the customer...
;;;194    			//
;;;195    			// ...
;;;196    			//  已经在前面初始化了，这里不再初始化
;;;197    			
;;;198    			return 0;
000026  2000              MOVS     r0,#0
                  |L2.40|
;;;199    		}
;;;200    		case LCD_X_SETVRAMADDR: 
;;;201    		{
;;;202    			//
;;;203    			// Required for setting the address of the video RAM for drivers
;;;204    			// with memory mapped video RAM which is passed in the 'pVRAM' element of p
;;;205    			//
;;;206    			LCD_X_SETVRAMADDR_INFO * p;
;;;207    			(void)p;
;;;208    			p = (LCD_X_SETVRAMADDR_INFO *)pData;
;;;209    			//...
;;;210    			return 0;
;;;211    		}
;;;212    		case LCD_X_SETORG: 
;;;213    		{
;;;214    			//
;;;215    			// Required for setting the display origin which is passed in the 'xPos' and 'yPos' element of p
;;;216    			//
;;;217    			LCD_X_SETORG_INFO * p;
;;;218    			(void)p;
;;;219    			p = (LCD_X_SETORG_INFO *)pData;
;;;220    
;;;221    			//...
;;;222    			return 0;
;;;223    		}
;;;224    		case LCD_X_SHOWBUFFER: 
;;;225    		{
;;;226    			//
;;;227    			// Required if multiple buffers are used. The 'Index' element of p contains the buffer index.
;;;228    			//
;;;229    			LCD_X_SHOWBUFFER_INFO * p;
;;;230    			(void)p;
;;;231    			p = (LCD_X_SHOWBUFFER_INFO *)pData;
;;;232    			//...
;;;233    			return 0;
;;;234    		}
;;;235    		case LCD_X_SETLUTENTRY: 
;;;236    		{
;;;237    			//
;;;238    			// Required for setting a lookup table entry which is passed in the 'Pos' and 'Color' element of p
;;;239    			//
;;;240    			LCD_X_SETLUTENTRY_INFO * p;
;;;241    			(void)p;
;;;242    			p = (LCD_X_SETLUTENTRY_INFO *)pData;
;;;243    			//...
;;;244    			return 0;
;;;245    		}
;;;246    		case LCD_X_ON: 
;;;247    		{
;;;248    			//
;;;249    			// Required if the display controller should support switching on and off
;;;250    			//
;;;251    			return 0;
;;;252    		}
;;;253    		case LCD_X_OFF: 
;;;254    		{
;;;255    			//
;;;256    			// Required if the display controller should support switching on and off
;;;257    			//
;;;258    			// ...
;;;259    			return 0;
;;;260    		}
;;;261    		default:
;;;262    		r = -1;
;;;263    	}
;;;264    	return r;
;;;265    }
000028  bd30              POP      {r4,r5,pc}
                  |L2.42|
00002a  4614              MOV      r4,r2                 ;208
00002c  2000              MOVS     r0,#0                 ;210
00002e  e7fb              B        |L2.40|
                  |L2.48|
000030  4614              MOV      r4,r2                 ;219
000032  2000              MOVS     r0,#0                 ;222
000034  e7f8              B        |L2.40|
                  |L2.54|
000036  4614              MOV      r4,r2                 ;231
000038  2000              MOVS     r0,#0                 ;233
00003a  e7f5              B        |L2.40|
                  |L2.60|
00003c  4614              MOV      r4,r2                 ;242
00003e  2000              MOVS     r0,#0                 ;244
000040  e7f2              B        |L2.40|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;251
000044  e7f0              B        |L2.40|
                  |L2.70|
000046  2000              MOVS     r0,#0                 ;259
000048  e7ee              B        |L2.40|
                  |L2.74|
00004a  f04f33ff          MOV      r3,#0xffffffff        ;262
00004e  bf00              NOP                            ;185
000050  bf00              NOP                            ;185
000052  4618              MOV      r0,r3                 ;264
000054  e7e8              B        |L2.40|
;;;266    /*************************** End of file ****************************/
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\emWin\\Config\\LCDConf.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_LCDConf_c_0a169049____REV16|
#line 129 "F:\\keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_LCDConf_c_0a169049____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_LCDConf_c_0a169049____REVSH|
#line 144
|__asm___9_LCDConf_c_0a169049____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
