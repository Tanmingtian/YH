#include "stm32f4xx_it.h"
#include <stdio.h>
#include "motor.h"
#include "bsp.h"
#define ERR_INFO "\r\nEnter HardFault_Handler, System Halt.\r\n"
const unsigned int Speedup_moto[162]=
{2048,2033,2025,2017,2007,1996,1983,1970,1956,1940,1924,1907,1889,1870,1851,1832,1811,1791,1770,1749,1728,1706,1685,1663,1642,1620,1599,1577,1556,1535,1514,1493,1472,1452,1432,1412,1392,1373,1354,1335,1316,1298,1280,1262,1245,1227,1210,1194,1177,1161,1145,1129,1114,1099,1084,1069,1054,1040,1026,1012,998,985,971,958,945,933,920,907,895,883,871,859,847,835,823,812,800,789,777,766,755,743,732,720,709,697,687,677,668,661,654,649,644,639,634,630,627,623,620,617,614,611,608,606,603,601,599,597,595,593,591,589,588,586,585,583,582,580,579,578,577,575,574,573,572,571,570,569,569,568,567,566,565,565,564,563,563,562,562,561,561,560,560,559,559,558,558,558,557,557,557,557,556,556,556,556,556,556,556,556,556,556};
//{2048,2033,2025,2017,2007,1996,1983,1970,1956,1940,1924,1907,1889,1870,1851,1832,1811,1791,1770,1749,1728,1706,1685,1663,1642,1620,1599,1577,1556,1535,1514,1493,1472,1452,1432,1412,1392,1373,1354,1335,1316,1298,1280,1262,1245,1227,1210,1194,1177,1161,1145,1129,1114,1099,1084,1069,1054,1040,1026,1012,998,985,971,958,945,933,920,907,895,883,871,859,847,835,823,812,800,789,777,766,755,743,732,720,709,697,687,677,668,661,654,649,644,639,634,630,627,623,620,617,614,611,608,606,603,601,599,597,595,593,591,589,588,586,585,583,582,580,579,578,577,575,574,573,572,571,570,569,569,568,567,566,565,565,564,563,563,562,562,561,561,560,560,559,559,558,558,558,557,557,557,557,556,556,556,556,556,556,556,556,556,556};
//{2048,2045,2038,2026,2010,1990,1966,1940,1910,1879,1846,1812,1777,1742,1706,1671,1636,1602,1568,1535,1504,1473,1443,1414,1385,1358,1332,1307,1283,1260,1237,1216,1195,1175,1156,1137,1119,1102,1085,1069,1054,1039,1025,1011,998,985,972,960,949,938,927,916,906,896,887,877,868,860,851,843,835,827,820,813,806,799,792,785,779,773,767,761,756,750,745,739,734,729,725,720,715,711,706,702,698,694,690,686,682,679,675,671,668,665,661,658,655,652,649,646,643,641,638,635,633,630,628,625,623,621,618,616,614,612,610,608,606,604,602,601,599,597,596,594,592,591,589,588,586,585,584,582,581,580,579,577,576,575,574,573,572,571,570,569,568,568,567,566,565,565,564,563,563,562,561,561,560,560,559,559,558,558,558,557,557,557,557,556,556,556,556,556,556,556,556};
const unsigned int moto_ac[147]=
	{2048,2047,2047,2046,2045,2044,2042,2040,2038,2035,2032,2029,2026,2022,2018,2014,2010,2005,2000,1995,1990,1984,1978,1972,1966,1959,1952,1946,1939,1931,1924,1916,1909,1901,1893,1885,1877,1868,1860,1852,1843,1834,1825,1817,1808,1799,1790,1781,1772,1763,1753,1744,1735,1726,1716,1707,1698,1689,1679,1670,1661,1652,1643,1633,1624,1615,1606,1597,1588,1579,1570,1561,1552,1543,1535,1526,1517,1508,1500,1491,1483,1474,1466,1458,1449,1441,1433,1425,1417,1409,1401,1393,1385,1377,1370,1362,1355,1347,1340,1332,1325,1318,1310,1303,1296,1289,1282,1275,1268,1262,1258,1252,1246,1240,1235,1229,1224,1220,1215,1211,1207,1203,1199,1195,1192,1189,1186,1183,1180,1178,1176,1173,1171,1169,1168,1166,1165,1163,1162,1161,1160,1159,1159,1158,1158,1158,1157};

volatile int LastCh=-1;
/*
*********************************************************************************************************
*	Cortex-M3 内核异常中断服务程序
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*	函 数 名: NMI_Handler
*	功能说明: 不可屏蔽中断服务程序。
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void NMI_Handler(void)
{
}

/*
*********************************************************************************************************
*	函 数 名: HardFault_Handler
*	功能说明: 硬件故障中断服务程序。其他异常处理被关闭，而又发生了异常，则触发。
*			  执行异常处理时，发生了异常，则触发。复位时默认使能。
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void HardFault_Handler(void)
{
#if 1
  const char *pError = ERR_INFO;
  uint8_t i;

  for (i = 0; i < sizeof(ERR_INFO); i++)
  {
     USART1->DR = pError[i];
     /* 等待发送结束 */
     while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
  }
#endif

  /* 当硬件失效异常发生时进入死循环 */
  while (1)
  {
  }
}

/*
*********************************************************************************************************
*	函 数 名: MemManage_Handler
*	功能说明: 内存管理异常中断服务程序。违反MPU设定的存储器访问规则时触发。 复位时默认未使能
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void MemManage_Handler(void)
{
  /* 当内存管理异常发生时进入死循环 */
  while (1)
  {
  }
}

/*
*********************************************************************************************************
*	函 数 名: BusFault_Handler
*	功能说明: 总线访问异常中断服务程序。取指令、数据读写、堆栈操作出现异常。 复位时默认未使能
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void BusFault_Handler(void)
{
  /* 当总线异常时进入死循环 */
  while (1)
  {
  }
}

/*
*********************************************************************************************************
*	函 数 名: UsageFault_Handler
*	功能说明: 用法错误中断服务程序。执行未定义指令、非对齐操作、除零时触发。 复位时默认未使能
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void UsageFault_Handler(void)
{
  /* 当用法异常时进入死循环 */
  while (1)
  {
  }
}

/*
*********************************************************************************************************
*	函 数 名: DebugMon_Handler
*	功能说明: 调试监视器中断服务程序。
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void DebugMon_Handler(void)
{
}

/*******************************************************************************
外部中断用于光电开关信号检测
*******************************************************************************/
void EXTI15_10_IRQHandler(void)
{
if(EXTI_GetITStatus(EXTI_LINE_TripSwitch) != RESET)
	{
		if(cw_status==BACKWARD)
		{
			//补足脉冲数
			PulseCount=PulseNum+AddedNum+500;
			//电机中断和定时器关闭
			TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE);
			TIM_Cmd(TIM2,DISABLE);
			//关闭外部中断					 
			EXTI->IMR&=0xFFFFDFFF;
			TripSwitchStatus=1;
		}
		EXTI_ClearITPendingBit(EXTI_LINE_TripSwitch);
	}
}


//	BitAction f=0;

//切光片电机使用TIM1中断
void TIM5_IRQHandler(void)
{
	if(Step_LM<10000)	//加速过程
	{
		//清除中断标志
		TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
		TIM5->ARR=(Speedup[(u8)((Step_LM++)/50)]<<1)-1;
	}
	else
	{					
		//转速达到启动PWM
		TIM_ITConfig(TIM5, TIM_IT_Update, DISABLE);
		TIM5->ARR=4499;
//		TIM5->CCER=0x000B;
//		TIM5->CNT=0x1193;//8b3
//		TIM5->ARR=3071;
//		TIM5->CCER=0x000B;
//		TIM5->CNT=0x08b3;
	}	 	
}


//AK5351中断
void SPI2_IRQHandler(void)
{
	u16 temp;
	//用于AK5351中断
	if (SPI_I2S_GetITStatus(SPI2, SPI_I2S_IT_RXNE) == SET)
	{
		temp=SPI_I2S_ReceiveData(SPI2);
		SPI_I2S_ClearITPendingBit(SPI2,SPI_I2S_IT_RXNE);
		if(LastCh<10)
		{			
			LastCh++;
			return;
		}
		if(RxLeftIdx==0 && RxRightIdx==0 && temp%0x100==0)
		{
			LastCh=11;
		}
		else if(LastCh==11)
		{ 
			//如果为左声道
			if(SPI_I2S_GetFlagStatus(SPI2,I2S_FLAG_CHSIDE)==0)
			{
				AK_Left_Data[RxLeftIdx]=temp;
				RxLeftIdx++;
			}
			//如果为右声道
			else
			{
				AK_Right_Data[RxRightIdx]=temp;
				RxRightIdx++;
			}
			//语音芯片数据计数器
			//如果数据采集完毕
			if(RxRightIdx>=DataLength*2 && RxLeftIdx>=DataLength*2)
			{
				//关闭I2S 中断
				SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, DISABLE);
				LastCh=-1;
			}
		}
	}
}
//这么基础的C语言知识都忘了！
//c语言的static在使用位置不同时是不同的，在全局上使用，表明该变量只能在本文件使用，在函数中使用，表该变量固定占据一个内存，且初始值在编译时决定，所以再次进入函数时，该变量不会重新被初始化且保留上一次退出函数的值。	

/*******************************************************************************
Timer2 用于汽缸电机中断
*******************************************************************************/
void TIM2_IRQHandler(void)
{ 
	static u8 pulsetype;
	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_Update)!=RESET)
	{
		GPIO_WriteBit(GPIO_M1CL, GPIO_Pin_M1CL,(BitAction)pulsetype);
		pulsetype=~pulsetype;
		
		//如果脉冲够数
		if(PulseCount>=PulseNum+AddedNum)
		{
			//关闭中断及timer2
			TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE);
			TIM_Cmd(TIM2,DISABLE);
		}
		//加压有加减速
		if(flagPress)
		{
			//如果出于匀速运行阶段
			if(PulseCount>294&&PulseCount<=PulseNum-294)
				TIM2->ARR=1157;
			//如果处于加速阶段
			else if(PulseCount<294)
				TIM2->ARR=moto_ac[PulseCount/2];
			//如果出于减速阶段
			else if((PulseNum-PulseCount)<294&&(PulseNum-PulseCount)>0)
				TIM2->ARR=moto_ac[(PulseNum-PulseCount)/2];
			//如果是AddedNum 部分，最低速度运行
			else
				TIM2->ARR=moto_ac[0];				
		}
		else
		{	//匀速
			if(StartSpeed==TargeSpeed)
			{
				TIM2->ARR=1157;
			}
			else
			{
				//不加压有加减速
				//如果出于匀速运行阶段
				if(PulseCount>324&&PulseCount<=PulseNum-324)
					TIM2->ARR=556;
				//如果处于加速阶段
				else if(PulseCount<324)
					TIM2->ARR=Speedup_moto[PulseCount/2];
				//如果出于减速阶段
				else if((PulseNum-PulseCount)<324&&(PulseNum-PulseCount)>0)
					TIM2->ARR=Speedup_moto[(PulseNum-PulseCount)/2];
				//如果是AddedNum 部分，最低速度运行
				else
					TIM2->ARR=Speedup_moto[0];	
			}
		}
		PulseCount++;
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);	
	}
}	

/***************************** END OF FILE *********************************/
